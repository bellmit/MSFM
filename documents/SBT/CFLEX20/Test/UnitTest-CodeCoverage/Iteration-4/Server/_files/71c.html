<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Mon Aug 01 06:28:17 CDT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../Coverage.html">all classes</A>][<A HREF="69.html">com.cboe.businessServices.tradeService</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">AuctionTradeHelper.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>AuctionTradeHelper.java</TD><TD>100% (1/1)</TD><TD CLASS="h">9%   (3/33)</TD><TD CLASS="h">3%   (61/2056)</TD><TD CLASS="h">4%   (19.6/466)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">AuctionTradeHelper</A></TD><TD>100% (1/1)</TD><TD CLASS="h">9%   (3/33)</TD><TD CLASS="h">3%   (61/2056)</TD><TD CLASS="h">4%   (19.6/466)</TD></TR><TR><TD CLASS="f"><A HREF="#0">AuctionTradeHelper (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">addMoreParticipants (ParticipantList, ParticipantList): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#3">calculateTradePriceNTicksBetter (Price, Side, TradingClass, short, int): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">calculateTradePriceOneTickBetter (Price, Side, TradingClass, short): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5">checkOppositeNonQincomingTradableCrossesBook (Tradable, Price, AuctionInterna...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/151)</TD><TD CLASS="h">0%   (0/28)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">continueToTradeWithAuctionRemainder (Tradable, AuctionInternal, OrderBook, Tr...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#7">createAuctionTradeContext (AuctionInternal, boolean, boolean): AllocationAuct...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">createFlexAuctionTrade (OrderBook, Price, int, Tradable): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR><TD CLASS="f"><A HREF="#9">createInternalizationAuctionParticipantLists (AuctionInternal, ArrayList, Arr...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/89)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">createInternalizationAuctionTrade (TradeService, AuctionInternal, OrderBook, ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#b">createInternalizationParticipantLists (InternalizationPair, ArrayList, ArrayL...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">createParticipantLists (Iterator, Side, TradingProduct, int, ArrayList, Array...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/92)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR><TD CLASS="f"><A HREF="#d">getAuctionInfoForOppositeSideIncomingTradable (Tradable, AuctionInternal, Pri...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">getAuctionInfoForOppositeSideIncomingTradable (Tradable, AuctionInternal, Pri...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getAuctionInfoForSameSideIncomingTradable (Tradable, AuctionInternal, Price):...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getBestBookPriceForInternalization (OrderBook, InternalizationPair, Side): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getBestBookPriceOrOneTickBetter (Side, OrderBook, short, int): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getBestPricePointOfAuction (AuctionInternal, OrderBook): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getMidPointAuctionPrice (Price, Price, TradingClass): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getNBBOPrice (Side, String, int): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getRemainingQuantity (TradingClass, AuctionInternal, Tradable): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/96)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getSameSideNBBOPrice (Price, AuctionInternal): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#17">prepareParticipantsForTrade (ArrayList, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">tradeAuction (TradeService, AuctionInternal, OrderBook, Price, int, Allocatio...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/151)</TD><TD CLASS="h">0%   (0/34)</TD></TR><TR><TD CLASS="f"><A HREF="#19">tradeOppositeNonQTradableWithAuction (TradeService, Tradable, AuctionInternal...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">tradeOppositeResponseQTradableWithAuction (TradeService, Price, Tradable, Auc...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/183)</TD><TD CLASS="h">0%   (0/38)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">tradeOppositeTradableWithAuction (TradeService, OrderBook, AuctionInternal, T...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">tradeSameSideIncomingTradableWithAuction (TradeService, AuctionInternal, Orde...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">tradeWithAuctionRemainder (TradeService, AuctionInternal, ArrayList, int, Pri...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">tradeWithRemainderOfIncomingAuctionResponse (TradeService, Tradable, OrderBoo...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/98)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">createFlexInternalizedAutionTrade (OrderBook, AuctionInternal, Tradable, Pric...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">6%   (15/232)</TD><TD CLASS="h">11%  (4.8/45)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">isMarketCrossedOrLocked (OrderBook): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">63%  (27/43)</TD><TD CLASS="h">64%  (7/11)</TD></TR><TR><TD CLASS="f"><A HREF="#21">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (8/8)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>package com.cboe.businessServices.tradeService;</TD></TR><TR><TD CLASS="l">2</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">3</TD><TD>import java.util.Collections;</TD></TR><TR><TD CLASS="l">4</TD><TD>import java.util.Enumeration;</TD></TR><TR><TD CLASS="l">5</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">6</TD><TD>import java.util.Random;</TD></TR><TR><TD CLASS="l">7</TD><TD> </TD></TR><TR><TD CLASS="l">8</TD><TD>import com.cboe.businessServices.orderBookService.AllocationStrategy;</TD></TR><TR><TD CLASS="l">9</TD><TD>import com.cboe.businessServices.orderBookService.OrderBookImpl;</TD></TR><TR><TD CLASS="l">10</TD><TD>import com.cboe.businessServices.orderBookService.OrderBookPriceDetailTransientImpl;</TD></TR><TR><TD CLASS="l">11</TD><TD>import com.cboe.businessServices.orderBookService.OrderBookPriceDetailUndoLog;</TD></TR><TR><TD CLASS="l">12</TD><TD>import com.cboe.businessServices.orderBookService.OrderBookPriceItem;</TD></TR><TR><TD CLASS="l">13</TD><TD>import com.cboe.businessServices.orderBookService.SideTradableIterator;</TD></TR><TR><TD CLASS="l">14</TD><TD>import com.cboe.domain.util.MarketPrice;</TD></TR><TR><TD CLASS="l">15</TD><TD>import com.cboe.domain.util.NoPrice;</TD></TR><TR><TD CLASS="l">16</TD><TD>import com.cboe.domain.util.PriceFactory;</TD></TR><TR><TD CLASS="l">17</TD><TD>import com.cboe.domain.util.SideFactory;</TD></TR><TR><TD CLASS="l">18</TD><TD>import com.cboe.domain.util.TradeContext;</TD></TR><TR><TD CLASS="l">19</TD><TD>import com.cboe.exceptions.AlreadyExistsException;</TD></TR><TR><TD CLASS="l">20</TD><TD>import com.cboe.exceptions.DataValidationException;</TD></TR><TR><TD CLASS="l">21</TD><TD>import com.cboe.exceptions.NotAcceptedException;</TD></TR><TR><TD CLASS="l">22</TD><TD>import com.cboe.exceptions.SpreadProcessingException;</TD></TR><TR><TD CLASS="l">23</TD><TD>import com.cboe.exceptions.SystemException;</TD></TR><TR><TD CLASS="l">24</TD><TD>import com.cboe.idl.cmiConstants.AuctionTypes;</TD></TR><TR><TD CLASS="l">25</TD><TD>import com.cboe.idl.cmiConstants.ContingencyTypes;</TD></TR><TR><TD CLASS="l">26</TD><TD>import com.cboe.idl.cmiConstants.MatchTypes;</TD></TR><TR><TD CLASS="l">27</TD><TD>import com.cboe.idl.cmiMarketData.NBBOStruct;</TD></TR><TR><TD CLASS="l">28</TD><TD>import com.cboe.idl.constants.AllocationTradeTypes;</TD></TR><TR><TD CLASS="l">29</TD><TD>import com.cboe.idl.tradingProperty.InternalizationPercentageStruct;</TD></TR><TR><TD CLASS="l">30</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Log;</TD></TR><TR><TD CLASS="l">31</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Transaction;</TD></TR><TR><TD CLASS="l">32</TD><TD>import com.cboe.interfaces.businessServices.TradeService;</TD></TR><TR><TD CLASS="l">33</TD><TD>import com.cboe.interfaces.domain.AllocationAuctionTradeContext;</TD></TR><TR><TD CLASS="l">34</TD><TD>import com.cboe.interfaces.domain.AuctionBook;</TD></TR><TR><TD CLASS="l">35</TD><TD>import com.cboe.interfaces.domain.AuctionBookTradableNotFoundException;</TD></TR><TR><TD CLASS="l">36</TD><TD>import com.cboe.interfaces.domain.AuctionInternal;</TD></TR><TR><TD CLASS="l">37</TD><TD>import com.cboe.interfaces.domain.InternalizationPair;</TD></TR><TR><TD CLASS="l">38</TD><TD>import com.cboe.interfaces.domain.Order;</TD></TR><TR><TD CLASS="l">39</TD><TD>import com.cboe.interfaces.domain.OrderBook;</TD></TR><TR><TD CLASS="l">40</TD><TD>import com.cboe.interfaces.domain.OrderBookPriceDetail;</TD></TR><TR><TD CLASS="l">41</TD><TD>import com.cboe.interfaces.domain.ParticipantItem;</TD></TR><TR><TD CLASS="l">42</TD><TD>import com.cboe.interfaces.domain.ParticipantList;</TD></TR><TR><TD CLASS="l">43</TD><TD>import com.cboe.interfaces.domain.Price;</TD></TR><TR><TD CLASS="l">44</TD><TD>import com.cboe.interfaces.domain.PriorityTradableSet;</TD></TR><TR><TD CLASS="l">45</TD><TD>import com.cboe.interfaces.domain.Side;</TD></TR><TR><TD CLASS="l">46</TD><TD>import com.cboe.interfaces.domain.Tradable;</TD></TR><TR><TD CLASS="l">47</TD><TD>import com.cboe.interfaces.domain.TradableList;</TD></TR><TR><TD CLASS="l">48</TD><TD>import com.cboe.interfaces.domain.TradingClass;</TD></TR><TR><TD CLASS="l">49</TD><TD>import com.cboe.interfaces.domain.TradingProduct;</TD></TR><TR><TD CLASS="l">50</TD><TD>import com.cboe.server.util.BusinessServicesHelper;</TD></TR><TR><TD CLASS="l">51</TD><TD>import com.cboe.server.util.StructToString;</TD></TR><TR><TD CLASS="l">52</TD><TD>import com.cboe.util.ExceptionBuilder;</TD></TR><TR><TD CLASS="l">53</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="0">54</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">55</TD><TD> * This class holds only static methods to implement auction related auction trade logic</TD></TR><TR><TD CLASS="l"><A NAME="21">56</A></TD><TD> * which can be called by TradeService.</TD></TR><TR><TD CLASS="l">57</TD><TD> */</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="86% line coverage (19 out of 22 instructions)">58</TD><TD TITLE="86% line coverage (19 out of 22 instructions)">public class AuctionTradeHelper extends TradeHelper</TD></TR><TR><TD CLASS="l">59</TD><TD>{</TD></TR><TR CLASS="c"><TD CLASS="l">60</TD><TD>    private static final Price noPrice = new NoPrice();</TD></TR><TR CLASS="c"><TD CLASS="l">61</TD><TD>    private static String myClassName = &#34;AuctionTradeHelper&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">62</TD><TD>    private static Random flexTradePriceSelector = new Random();</TD></TR><TR><TD CLASS="l">63</TD><TD>    </TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>    private static Side buySide = SideFactory.getBuySide();</TD></TR><TR CLASS="c"><TD CLASS="l">65</TD><TD>    private static Side sellSide = SideFactory.getSellSide();</TD></TR><TR CLASS="c"><TD CLASS="l">66</TD><TD>    private static Side definedSide = SideFactory.getAsDefinedSide();</TD></TR><TR CLASS="c"><TD CLASS="l">67</TD><TD>    private static Side oppositeSide = SideFactory.getOppositeSide();</TD></TR><TR><TD CLASS="l"><A NAME="1b">68</A></TD><TD> </TD></TR><TR><TD CLASS="l">69</TD><TD>    protected static int tradeOppositeTradableWithAuction(TradeService tradeService,OrderBook book, AuctionInternal auction, Tradable incomingTradable)</TD></TR><TR><TD CLASS="l">70</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">71</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">72</TD><TD>        int result = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">73</TD><TD>        Price bestBookPrice = book.getBestPrice( auction.getSide());</TD></TR><TR CLASS="z"><TD CLASS="l">74</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">75</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">76</TD><TD>            String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">77</TD><TD>            Log.debug(msg);</TD></TR><TR><TD CLASS="l">78</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">79</TD><TD>        if (incomingTradable.treatedLikeQuote()</TD></TR><TR CLASS="z"><TD CLASS="l">80</TD><TD>                || incomingTradable.getContingencyType() == ContingencyTypes.AUCTION_RESPONSE)</TD></TR><TR><TD CLASS="l">81</TD><TD>        {</TD></TR><TR><TD CLASS="l">82</TD><TD>            // opposite quote/auction response ends auction</TD></TR><TR CLASS="z"><TD CLASS="l">83</TD><TD>            result = tradeOppositeResponseQTradableWithAuction(tradeService, bestBookPrice, incomingTradable, auction, book);</TD></TR><TR><TD CLASS="l">84</TD><TD>        }</TD></TR><TR><TD CLASS="l">85</TD><TD>        else</TD></TR><TR><TD CLASS="l">86</TD><TD>        {   // opposite NonQ order, crosses auction starting price</TD></TR><TR CLASS="z"><TD CLASS="l">87</TD><TD>            result = tradeOppositeNonQTradableWithAuction(tradeService, incomingTradable, auction, bestBookPrice, book);</TD></TR><TR><TD CLASS="l">88</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">89</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">90</TD><TD>    }</TD></TR><TR><TD CLASS="l">91</TD><TD> </TD></TR><TR><TD CLASS="l">92</TD><TD>    /**</TD></TR><TR><TD CLASS="l">93</TD><TD>     * method to return the best book price on the side specified for auction.</TD></TR><TR><TD CLASS="l">94</TD><TD>     * Currently returns the best non-contingency price based on requirement.</TD></TR><TR><TD CLASS="l">95</TD><TD>     * </TD></TR><TR><TD CLASS="l">96</TD><TD>     * @param pair</TD></TR><TR><TD CLASS="l">97</TD><TD>     * @param side</TD></TR><TR><TD CLASS="l"><A NAME="10">98</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">99</TD><TD>     */</TD></TR><TR><TD CLASS="l">100</TD><TD>    public static Price getBestBookPriceForInternalization(OrderBook orderBook, InternalizationPair pair, Side side)</TD></TR><TR><TD CLASS="l">101</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>        synchronized(orderBook)</TD></TR><TR><TD CLASS="l">103</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">104</TD><TD>            if(side.isBuySide() || side.isAsDefinedSide())</TD></TR><TR><TD CLASS="l">105</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>                return orderBook.getBestNonContingentBidPrice();</TD></TR><TR><TD CLASS="l">107</TD><TD>            }</TD></TR><TR><TD CLASS="l">108</TD><TD>            else </TD></TR><TR><TD CLASS="l">109</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">110</TD><TD>                return orderBook.getBestNonContingentAskPrice();</TD></TR><TR><TD CLASS="l">111</TD><TD>            }</TD></TR><TR><TD CLASS="l">112</TD><TD>        }</TD></TR><TR><TD CLASS="l">113</TD><TD>    } </TD></TR><TR><TD CLASS="l">114</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="19">115</A></TD><TD>    private static int tradeOppositeNonQTradableWithAuction(TradeService tradeService,Tradable incomingTradable, AuctionInternal auction, Price bestBookPrice, OrderBook book)</TD></TR><TR><TD CLASS="l">116</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">117</TD><TD>    {</TD></TR><TR><TD CLASS="l">118</TD><TD>        int result;</TD></TR><TR CLASS="z"><TD CLASS="l">119</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">120</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">121</TD><TD>            Log.debug( &#34;The opposite side incoming NonQ-Order ends auction, going to trade with the remainder volume of the action participants if any&#34;);</TD></TR><TR><TD CLASS="l">122</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>        if (incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), auction.getStartingPrice()))</TD></TR><TR><TD CLASS="l">124</TD><TD>        {</TD></TR><TR><TD CLASS="l">125</TD><TD>            // check if the nonQ incomingTradable is marketable book, and if the price needs to be widened.</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>            checkOppositeNonQincomingTradableCrossesBook(incomingTradable, bestBookPrice, auction, book);</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">128</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">129</TD><TD>                Log.debug(  &#34;The final incoming opposite NonQ tradable price = &#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">130</TD><TD>            }</TD></TR><TR><TD CLASS="l">131</TD><TD>            // this NonQ tradable could n't be matched by firm auto-match order.</TD></TR><TR CLASS="z"><TD CLASS="l">132</TD><TD>            result = createInternalizationAuctionTrade(tradeService, auction, book, incomingTradable, false);</TD></TR><TR><TD CLASS="l">133</TD><TD>        }</TD></TR><TR><TD CLASS="l">134</TD><TD>        else</TD></TR><TR><TD CLASS="l">135</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>            Log.alarm( &#34; The current auction should n't be terminated by this opposite incoming NonQ order, its price is not marketable against the auction starting price, though we have to continue to allocate the auction trade&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">137</TD><TD>            String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>            Log.alarm( msg);</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>            result = createInternalizationAuctionTrade(tradeService, auction, book, null, false);</TD></TR><TR><TD CLASS="l">140</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">142</TD><TD>    }</TD></TR><TR><TD CLASS="l">143</TD><TD> </TD></TR><TR><TD CLASS="l">144</TD><TD>    /**</TD></TR><TR><TD CLASS="l">145</TD><TD>     * An incoming opposite quote/auction response ends auction,</TD></TR><TR><TD CLASS="l">146</TD><TD>     * its price should cross the same side book as the best auction participant price</TD></TR><TR><TD CLASS="l">147</TD><TD>     * @param bestBookPrice</TD></TR><TR><TD CLASS="l">148</TD><TD>     * @param incomingTradable</TD></TR><TR><TD CLASS="l">149</TD><TD>     * @param auction</TD></TR><TR><TD CLASS="l">150</TD><TD>     * @param book</TD></TR><TR><TD CLASS="l">151</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">152</TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l"><A NAME="1a">153</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">154</TD><TD>    private static int tradeOppositeResponseQTradableWithAuction(TradeService tradeService,Price bestBookPrice, Tradable incomingTradable, AuctionInternal auction, OrderBook book)</TD></TR><TR><TD CLASS="l">155</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">156</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>        int result = 0;</TD></TR><TR><TD CLASS="l">158</TD><TD>        // needs to widen the price of the incoming tradable to the better price</TD></TR><TR><TD CLASS="l">159</TD><TD>        // of the best Q book Price or 1 tick better than best Customer price on the same side as the auction</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>        if ( incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestBookPrice) )</TD></TR><TR><TD CLASS="l">161</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>            int remainingOppositeQty = getRemainingQuantity (book.getTradingProduct().getTradingClass(),</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                                        auction, incomingTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>            Price tradePrice = getBestBookPriceOrOneTickBetter(auction.getSide(), book, AuctionTypes.AUCTION_INTERNALIZATION, remainingOppositeQty);</TD></TR><TR CLASS="z"><TD CLASS="l">165</TD><TD>            if  (incomingTradable.getSide().isFirstBetter(incomingTradable.getPrice(), tradePrice))</TD></TR><TR><TD CLASS="l">166</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>                incomingTradable.setWidenPrice(tradePrice);</TD></TR><TR><TD CLASS="l">168</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">170</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">171</TD><TD>                Log.debug(  &#34;The opposite incoming Quote/Q-Like order/auction response ends auction, will trade at the best book price (/ 1 tick better) =&#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">172</TD><TD>            }</TD></TR><TR><TD CLASS="l">173</TD><TD>        }</TD></TR><TR><TD CLASS="l">174</TD><TD>        else</TD></TR><TR><TD CLASS="l">175</TD><TD>        {   // the opposite incoming tradable price doesn't cross the regular book for some reason</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>            Log.alarm( &#34;The current auction should n't be terminated by this opposite incoming quote/response, its price is not marketable against the book, though we have to continue to allocate the auction trade&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>            String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>            Log.alarm( msg);</TD></TR><TR><TD CLASS="l">179</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>        if (incomingTradable.getContingencyType() == ContingencyTypes.AUCTION_RESPONSE)</TD></TR><TR><TD CLASS="l">181</TD><TD>        {</TD></TR><TR><TD CLASS="l">182</TD><TD>            try</TD></TR><TR><TD CLASS="l">183</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">184</TD><TD>                auction.getAuctionBook().bookTradable(incomingTradable); // book it into the auctionbook</TD></TR><TR><TD CLASS="l">185</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>            catch (AlreadyExistsException e)</TD></TR><TR><TD CLASS="l">187</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                Log.exception(e.toString(), e);</TD></TR><TR><TD CLASS="l">189</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>            catch (NotAcceptedException ex)</TD></TR><TR><TD CLASS="l">191</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">192</TD><TD>                Log.exception(ex.toString(), ex);</TD></TR><TR><TD CLASS="l">193</TD><TD>            }</TD></TR><TR><TD CLASS="l">194</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>            result = createInternalizationAuctionTrade(tradeService,auction, book, null, false);</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>            if (incomingTradable.isWidened())</TD></TR><TR><TD CLASS="l">197</TD><TD>            {</TD></TR><TR><TD CLASS="l">198</TD><TD>                try</TD></TR><TR><TD CLASS="l">199</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                    auction.getAuctionBook().cancelTradable(incomingTradable, incomingTradable.getQuantityAllowed());</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                    incomingTradable.setWidenPrice( null);</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>                    auction.getAuctionBook().bookTradable(incomingTradable);</TD></TR><TR><TD CLASS="l">203</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                catch (AuctionBookTradableNotFoundException nfe)</TD></TR><TR><TD CLASS="l">205</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                    Log.exception(&#34;Couldn't trade the remainder of the incoming response with the book, since it couldnot cancel the widened the auction response from the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                            + StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34; &#34; + &#34;, current price = &#34; + incomingTradable.getPrice() + nfe, nfe);</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>                    return result;</TD></TR><TR><TD CLASS="l">209</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">210</TD><TD>                catch (AlreadyExistsException aee)</TD></TR><TR><TD CLASS="l">211</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                    Log.exception(&#34;Couldn't re-book the narrowed the auction response into the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                            +  StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34; &#34; + aee , aee);</TD></TR><TR><TD CLASS="l">214</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>                catch (NotAcceptedException nae)</TD></TR><TR><TD CLASS="l">216</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>                    Log.exception(&#34;Couldn't re-book the narrowed the auction response into the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                            +  StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34;, current price = &#34; + incomingTradable.getPrice() + nae , nae);</TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>                    return result;</TD></TR><TR><TD CLASS="l">220</TD><TD>                }</TD></TR><TR><TD CLASS="l">221</TD><TD>            }</TD></TR><TR><TD CLASS="l">222</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>            int allocatedQty2 = tradeWithRemainderOfIncomingAuctionResponse(tradeService,incomingTradable, book, auction);</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>            result = result + allocatedQty2;</TD></TR><TR><TD CLASS="l">225</TD><TD>        }</TD></TR><TR><TD CLASS="l">226</TD><TD>        else</TD></TR><TR><TD CLASS="l">227</TD><TD>        {   // Quote/Q-like order crosses the book</TD></TR><TR><TD CLASS="l">228</TD><TD>            // this tradable will participate the auction and, it should be matched by firm auto-match order.</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>            result = createInternalizationAuctionTrade(tradeService,auction, book, incomingTradable, true);</TD></TR><TR><TD CLASS="l">230</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">231</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">232</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="1e">233</A></TD><TD> </TD></TR><TR><TD CLASS="l">234</TD><TD>    private static int tradeWithRemainderOfIncomingAuctionResponse(TradeService tradeService, Tradable incomingResponse, OrderBook book, AuctionInternal auction)</TD></TR><TR><TD CLASS="l">235</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">236</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>        int allocatedQty2 = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>        if (incomingResponse.getQuantityAllowed() &gt; 0)</TD></TR><TR><TD CLASS="l">239</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">240</TD><TD>            Side theSide = auction.getSide();</TD></TR><TR><TD CLASS="l">241</TD><TD>            //get the same Side book NonQ market, which could trade with the leftover of the incoming auction response</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>            int sameSideNonQQty = book.getNonQQuantityAhead(theSide, book.getBestPrice(theSide));</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>            ArrayList nonQsameSideTradablesList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>            if (sameSideNonQQty &gt; 0 )</TD></TR><TR><TD CLASS="l">245</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                int theNonQLmtQty = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>                Enumeration sameSideBookTradables = book.getTradables( theSide, book.getBestPrice(theSide));</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                while (sameSideBookTradables.hasMoreElements())</TD></TR><TR><TD CLASS="l">249</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                    Tradable sameSideTradable = (Tradable) sameSideBookTradables.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                    if (!sameSideTradable.treatedLikeQuote() &amp;&amp; sameSideTradable.getPrice().isValuedPrice())</TD></TR><TR><TD CLASS="l">252</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>                        nonQsameSideTradablesList.add(sameSideTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                        theNonQLmtQty = sameSideTradable.getQuantityAllowed() + theNonQLmtQty;</TD></TR><TR><TD CLASS="l">255</TD><TD>                    }</TD></TR><TR><TD CLASS="l">256</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">258</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                    Log.debug(  &#34;The total same side NonQ Qty = &#34; + sameSideNonQQty + &#34; @ or better than the price of the incoming response =&#34; + incomingResponse.getPrice() );</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                    Log.debug(  &#34;The total same side NonQ LMT Qty = &#34; + theNonQLmtQty + &#34; @ or better than the price of the incoming response =&#34; + incomingResponse.getPrice() );</TD></TR><TR><TD CLASS="l">261</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                sameSideNonQQty = theNonQLmtQty; // though these two values should be always same, since the auction side book should never have MKT orders</TD></TR><TR><TD CLASS="l">263</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>            if (sameSideNonQQty &gt; 0)</TD></TR><TR><TD CLASS="l">265</TD><TD>            {</TD></TR><TR><TD CLASS="l">266</TD><TD>                // it could trade with same side book if any remaining left.</TD></TR><TR><TD CLASS="l">267</TD><TD>                // will continue to trade the NonQsameSideBookTradables with the remainder auction responses</TD></TR><TR><TD CLASS="l">268</TD><TD>                // @ the incoming response price.</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                allocatedQty2  = tradeWithAuctionRemainder(tradeService, auction, nonQsameSideTradablesList, sameSideNonQQty, incomingResponse.getPrice(), book, true);</TD></TR><TR><TD CLASS="l">270</TD><TD>            }</TD></TR><TR><TD CLASS="l">271</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>        return allocatedQty2;</TD></TR><TR><TD CLASS="l">273</TD><TD>    }</TD></TR><TR><TD CLASS="l">274</TD><TD> </TD></TR><TR><TD CLASS="l">275</TD><TD>    // trade same side incoming tradable when same side tradable crosses auction best price point</TD></TR><TR><TD CLASS="l"><A NAME="1c">276</A></TD><TD>    protected static int tradeSameSideIncomingTradableWithAuction(TradeService tradeService, AuctionInternal auction, OrderBook book, Tradable incomingTradable)</TD></TR><TR><TD CLASS="l">277</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">278</TD><TD>    {</TD></TR><TR><TD CLASS="l">279</TD><TD>        int result;</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>        Price bestAuctionPrice =  getBestPricePointOfAuction(auction, book);</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">282</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>            String msg = getAuctionInfoForSameSideIncomingTradable(incomingTradable, auction, bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>            Log.debug(  msg);</TD></TR><TR><TD CLASS="l">285</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>        result = createInternalizationAuctionTrade(tradeService, auction, book, null, false);</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>        if (!incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestAuctionPrice) )</TD></TR><TR><TD CLASS="l">288</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>            Log.alarm( &#34;The current auction should NOT be terminated by the incoming order/quote, its price is not marketable against the best auction price, though still terminated &amp; traded the auction&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>            String msg = getAuctionInfoForSameSideIncomingTradable(incomingTradable, auction, bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>            Log.alarm( msg);</TD></TR><TR><TD CLASS="l">292</TD><TD>        }</TD></TR><TR><TD CLASS="l">293</TD><TD>        else</TD></TR><TR><TD CLASS="l">294</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>            if (incomingTradable.treatedLikeQuote())</TD></TR><TR><TD CLASS="l">296</TD><TD>            {   // same side quote ends auction, will not participate auction trade though</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">298</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                    Log.debug(  &#34;The same side incoming Quote/Q-Like order ends auction, it didn't participate auction trade though&#34;);</TD></TR><TR><TD CLASS="l">300</TD><TD>                }</TD></TR><TR><TD CLASS="l">301</TD><TD>            }</TD></TR><TR><TD CLASS="l">302</TD><TD>            else</TD></TR><TR><TD CLASS="l">303</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">305</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">306</TD><TD>                    Log.debug(  &#34;The same side incoming NonQ-Order ends auction, it continues to trade with the remainder of the action participants if any&#34;);</TD></TR><TR><TD CLASS="l">307</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>                result = result + continueToTradeWithAuctionRemainder(incomingTradable, auction, book, tradeService);</TD></TR><TR><TD CLASS="l">309</TD><TD>            }</TD></TR><TR><TD CLASS="l">310</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">311</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">312</TD><TD>    }</TD></TR><TR><TD CLASS="l">313</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="6">314</A></TD><TD>    // try to trade the incoming same side Non-Q order with the remaining of the auction response only</TD></TR><TR><TD CLASS="l">315</TD><TD>    private static int continueToTradeWithAuctionRemainder(Tradable incomingTradable, AuctionInternal auction, OrderBook book, TradeService tradeService)</TD></TR><TR><TD CLASS="l">316</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">317</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>        int allocatedQty = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>        if (incomingTradable.getQuantityAllowed() == 0 )</TD></TR><TR><TD CLASS="l">320</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>            return allocatedQty;</TD></TR><TR><TD CLASS="l">322</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>        ArrayList  sameSidePriceDetailList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>        sameSidePriceDetailList.add(incomingTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>        Price tradePrice = incomingTradable.getPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>        if (tradePrice.isMarketPrice())</TD></TR><TR><TD CLASS="l">327</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>           tradePrice = auction.getStartingPrice();</TD></TR><TR><TD CLASS="l">329</TD><TD>        }</TD></TR><TR><TD CLASS="l">330</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>        boolean responseOnly = true;</TD></TR><TR><TD CLASS="l">332</TD><TD>        // check if it also crosses book; it can only trade with responses only if it doesn't cross book</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>        Price bestOppositeBookPrice = book.getBestLimitPrice(auction.getSide().getOtherSide());</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>        responseOnly = !incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestOppositeBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>        allocatedQty = tradeWithAuctionRemainder(tradeService, auction, sameSidePriceDetailList, incomingTradable.getQuantityAllowed(), tradePrice, book, responseOnly);</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>        return allocatedQty;</TD></TR><TR><TD CLASS="l">337</TD><TD>    }</TD></TR><TR><TD CLASS="l">338</TD><TD> </TD></TR><TR><TD CLASS="l">339</TD><TD>    /**</TD></TR><TR><TD CLASS="l">340</TD><TD>     * This method will determine if the incoming NonQ Tradable's price needs to be widened.</TD></TR><TR><TD CLASS="l">341</TD><TD>     * 1) when its price crosses book of the auction side,</TD></TR><TR><TD CLASS="l">342</TD><TD>     * it will use the midpoint price between the best auction price and the best NBBO price, which is round to favor auction</TD></TR><TR><TD CLASS="l">343</TD><TD>     * or use the best auction price if the same side NBBO price crosses the best auction price.</TD></TR><TR><TD CLASS="l">344</TD><TD>     * 2) when the new midpoint price still crosses the best book (BBO),</TD></TR><TR><TD CLASS="l">345</TD><TD>     * it will be widened to the better price of the best Q price of the book and 1 tick better than the best Customer book Price of the acution side</TD></TR><TR><TD CLASS="l">346</TD><TD>     *</TD></TR><TR><TD CLASS="l">347</TD><TD>     * @param incomingTradable</TD></TR><TR><TD CLASS="l">348</TD><TD>     * @param bestBookPrice</TD></TR><TR><TD CLASS="l">349</TD><TD>     * @param auction</TD></TR><TR><TD CLASS="l"><A NAME="5">350</A></TD><TD>     * @param book</TD></TR><TR><TD CLASS="l">351</TD><TD>     */</TD></TR><TR><TD CLASS="l">352</TD><TD>    private static void checkOppositeNonQincomingTradableCrossesBook(Tradable incomingTradable, Price bestBookPrice, AuctionInternal auction, OrderBook book)</TD></TR><TR><TD CLASS="l">353</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">354</TD><TD>        if ( incomingTradable.getPrice().isMarketPrice()</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>             || incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestBookPrice))</TD></TR><TR><TD CLASS="l">356</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>            Price bestAuctionPrice = getBestPricePointOfAuction(auction, book);</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>            Price theSameSideNBBO = getSameSideNBBOPrice(bestBookPrice, auction);</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">360</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                 String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice, bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>                 Log.debug(  msg + &#34;, Same side NBBO pirce = &#34; + theSameSideNBBO);</TD></TR><TR><TD CLASS="l">363</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>            if ( !bestBookPrice.isValuedPrice()</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                 || incomingTradable.getSide().getOtherSide().isFirstBetter(theSameSideNBBO, bestAuctionPrice) )</TD></TR><TR><TD CLASS="l">366</TD><TD>            {  // noPrice in book, using the best auction price</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>               incomingTradable.setWidenPrice(bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">369</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                    if  (!bestBookPrice.isValuedPrice())</TD></TR><TR><TD CLASS="l">371</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                        Log.debug(  &#34;NoPrice found in the rest market, The incoming Marketable tradable's widened to: &#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">373</TD><TD>                    }</TD></TR><TR><TD CLASS="l">374</TD><TD>                    else</TD></TR><TR><TD CLASS="l">375</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                        Log.debug(  &#34;The same side NBBO(&#34; + theSameSideNBBO  + &#34;) crosses the best auction price (&#34; + bestAuctionPrice + &#34;), The incoming Marketable tradable's widened to: &#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">377</TD><TD>                    }</TD></TR><TR><TD CLASS="l">378</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>               return;</TD></TR><TR><TD CLASS="l">380</TD><TD>            }</TD></TR><TR><TD CLASS="l">381</TD><TD>            // to trade @ mid-point between the best auction price and the rest market price of the auction side</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>            Price newPrice = getMidPointAuctionPrice(bestAuctionPrice, theSameSideNBBO, book.getTradingProduct().getTradingClass());</TD></TR><TR CLASS="z"><TD CLASS="l">383</TD><TD>            incomingTradable.setWidenPrice(newPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">385</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                Log.debug(  &#34;The opposite incoming order ends auction, will trade at the mid point price(of NBBO and best auction)= &#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">387</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>            if ( bestBookPrice.isValuedPrice() )</TD></TR><TR><TD CLASS="l">389</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>                if ( incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestBookPrice))</TD></TR><TR><TD CLASS="l">391</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                    int remainingOppositeQty = getRemainingQuantity (book.getTradingProduct().getTradingClass(), auction, incomingTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>                    Price tradePrice = getBestBookPriceOrOneTickBetter(auction.getSide(), book, AuctionTypes.AUCTION_INTERNALIZATION, remainingOppositeQty);</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                    if ( incomingTradable.getSide().isFirstBetter(incomingTradable.getPrice(), tradePrice))</TD></TR><TR><TD CLASS="l">395</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>                        incomingTradable.setWidenPrice(tradePrice);</TD></TR><TR><TD CLASS="l">397</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">398</TD><TD>                    if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">399</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                        Log.debug(  &#34;The opposite incoming order ends auction, will trade at the best book price (/ 1 tick better) =&#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">401</TD><TD>                    }</TD></TR><TR><TD CLASS="l">402</TD><TD>                }</TD></TR><TR><TD CLASS="l">403</TD><TD>            }</TD></TR><TR><TD CLASS="l">404</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="16">405</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">406</TD><TD>    // Get the smae side Nbbo Price by querying MDS</TD></TR><TR><TD CLASS="l">407</TD><TD>    private static Price getSameSideNBBOPrice(Price bestBookPrice, AuctionInternal auction)</TD></TR><TR><TD CLASS="l">408</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>        Price theSameSideNBBO = bestBookPrice;</TD></TR><TR><TD CLASS="l">410</TD><TD>        try</TD></TR><TR><TD CLASS="l">411</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>            NBBOStruct nbboStruct = BusinessServicesHelper.getMarketDataService().getNBBOForProduct(auction.getSession(), auction.getProductKey());</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>            if (auction.getSide().isBuySide())</TD></TR><TR><TD CLASS="l">414</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>                theSameSideNBBO = PriceFactory.createValuedPrice (nbboStruct.bidPrice);</TD></TR><TR><TD CLASS="l">416</TD><TD>            }</TD></TR><TR><TD CLASS="l">417</TD><TD>            else</TD></TR><TR><TD CLASS="l">418</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                theSameSideNBBO = PriceFactory.createValuedPrice (nbboStruct.askPrice);</TD></TR><TR><TD CLASS="l">420</TD><TD>            }</TD></TR><TR><TD CLASS="l">421</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">422</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">423</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>            Log.exception(&#34;Hit the exception when to get same side NBBO, so will use best Book price as NBBO&#34; + e, e);</TD></TR><TR><TD CLASS="l">425</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>        return theSameSideNBBO;</TD></TR><TR><TD CLASS="l"><A NAME="14">427</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">428</TD><TD>    </TD></TR><TR><TD CLASS="l">429</TD><TD>    public static Price getNBBOPrice(Side side,String session,int productKey)</TD></TR><TR><TD CLASS="l">430</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>        Price nbboPrice = null;</TD></TR><TR><TD CLASS="l">432</TD><TD>        try</TD></TR><TR><TD CLASS="l">433</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>            NBBOStruct nbboStruct = BusinessServicesHelper.getMarketDataService().getNBBOForProduct(session, productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>            if (side.isBuySide())</TD></TR><TR><TD CLASS="l">436</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                    nbboPrice = PriceFactory.createValuedPrice (nbboStruct.bidPrice);</TD></TR><TR><TD CLASS="l">438</TD><TD>            }</TD></TR><TR><TD CLASS="l">439</TD><TD>            else</TD></TR><TR><TD CLASS="l">440</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>                    nbboPrice = PriceFactory.createValuedPrice (nbboStruct.askPrice);</TD></TR><TR><TD CLASS="l">442</TD><TD>            }</TD></TR><TR><TD CLASS="l">443</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">445</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>            Log.exception(&#34;Hit the exception when to get NBBO for product:&#34;+productKey+ e, e);</TD></TR><TR><TD CLASS="l">447</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>        return nbboPrice;</TD></TR><TR><TD CLASS="l">449</TD><TD>    }</TD></TR><TR><TD CLASS="l">450</TD><TD> </TD></TR><TR><TD CLASS="l">451</TD><TD>    /**</TD></TR><TR><TD CLASS="l">452</TD><TD>     * pre-calculate the remainder of the opposite incoming tradable after the auction trade</TD></TR><TR><TD CLASS="l">453</TD><TD>     * @param tradingClass</TD></TR><TR><TD CLASS="l">454</TD><TD>     * @param auction</TD></TR><TR><TD CLASS="l">455</TD><TD>     * @param incomingTradable - the opposite incoming tradable only</TD></TR><TR><TD CLASS="l"><A NAME="15">456</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">457</TD><TD>     */</TD></TR><TR><TD CLASS="l">458</TD><TD>    private static int getRemainingQuantity(TradingClass tradingClass, AuctionInternal auction, Tradable incomingTradable)</TD></TR><TR><TD CLASS="l">459</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>        int result = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">461</TD><TD>        int incomingQty = incomingTradable.getQuantityAllowed();</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>        if (incomingQty &lt;=0)</TD></TR><TR><TD CLASS="l">463</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>            return result;</TD></TR><TR><TD CLASS="l">465</TD><TD>        }</TD></TR><TR><TD CLASS="l">466</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>        short matchType = MatchTypes.UNSPECIFIED;</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>        if (auction.getAuctionType() == AuctionTypes.AUCTION_INTERNALIZATION )</TD></TR><TR><TD CLASS="l">469</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>            if (auction.getFirmMatchOrder().getPrice().isMarketPrice())</TD></TR><TR><TD CLASS="l">471</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>               matchType =MatchTypes.AUTO_MATCH;</TD></TR><TR><TD CLASS="l">473</TD><TD>            }</TD></TR><TR><TD CLASS="l">474</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>        if (matchType != MatchTypes.AUTO_MATCH</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                || !(incomingTradable.treatedLikeQuote() || incomingTradable.getContingencyType() == ContingencyTypes.AUCTION_RESPONSE) )</TD></TR><TR><TD CLASS="l">477</TD><TD>        {   // not aucto match type, or not a matchable inbound tradable</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>            result =  incomingQty - auction.getAuctionedOrder().getRemainingQuantity();</TD></TR><TR><TD CLASS="l">479</TD><TD>        }</TD></TR><TR><TD CLASS="l">480</TD><TD>        else</TD></TR><TR><TD CLASS="l">481</TD><TD>        {   // for auto-match, we need to find out the match percentage for one group other than match order</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>            InternalizationPercentageStruct[] percentageScale =  tradingClass.getTradingPropertyInternalizationGuaranteedPercentage();</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>            double rate = 0.0d;</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>            int otherGroupNumber = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>            for (int i=0; i&lt; percentageScale.length; i++)</TD></TR><TR><TD CLASS="l">486</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                if (otherGroupNumber &gt;= percentageScale[i].lowerRange &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>                    otherGroupNumber &lt; percentageScale[i].upperRange &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>                    auction.getAuctionType()== percentageScale[i].auctionType)</TD></TR><TR><TD CLASS="l">490</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                    rate = percentageScale[i].percentage;</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">493</TD><TD>                }</TD></TR><TR><TD CLASS="l">494</TD><TD>            }</TD></TR><TR><TD CLASS="l">495</TD><TD>            // calculate the remainder</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>            int auctionedQty = auction.getAuctionedOrder().getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>            result = incomingQty -  Math.round((float)((1.0- rate)* auctionedQty));</TD></TR><TR><TD CLASS="l">498</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">500</TD><TD>    }</TD></TR><TR><TD CLASS="l">501</TD><TD> </TD></TR><TR><TD CLASS="l">502</TD><TD>    /**</TD></TR><TR><TD CLASS="l">503</TD><TD>     * get mid-point between the best auction price of the oppoiste side and the rest market (NBBO) price of the auction side</TD></TR><TR><TD CLASS="l">504</TD><TD>     * the two input prices should always never cross with each other, though they can be equal</TD></TR><TR><TD CLASS="l">505</TD><TD>     * @param bestAuctionPrice - the current best valid price point of auction participants,</TD></TR><TR><TD CLASS="l">506</TD><TD>     * which include auction reponses, quotes and orders on the oppoiste side of the auciton</TD></TR><TR><TD CLASS="l">507</TD><TD>     * @param bestNBBOPrice - the best NBBO price of the same side of the auction</TD></TR><TR><TD CLASS="l">508</TD><TD>     * @param tradingClass - a TradingClass</TD></TR><TR><TD CLASS="l"><A NAME="13">509</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">510</TD><TD>     */</TD></TR><TR><TD CLASS="l">511</TD><TD>    private static Price getMidPointAuctionPrice(Price bestAuctionPrice, Price bestNBBOPrice, TradingClass tradingClass)</TD></TR><TR><TD CLASS="l">512</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>        Price midPoint = PriceFactory.create((bestAuctionPrice.toDouble() + bestNBBOPrice.toDouble())/2.0D);</TD></TR><TR><TD CLASS="l">514</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>        Price midPointFloor = tradingClass.floorPremiumToAuctionTick(midPoint, AuctionTypes.AUCTION_INTERNALIZATION, bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">516</TD><TD>        Price midPointCeil = tradingClass.ceilPremiumToAuctionTick(midPoint, AuctionTypes.AUCTION_INTERNALIZATION, bestAuctionPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">517</TD><TD>        Price newPrice = midPointFloor;</TD></TR><TR CLASS="z"><TD CLASS="l">518</TD><TD>        if (!midPointFloor.equals(midPointCeil))</TD></TR><TR><TD CLASS="l">519</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>            if (bestAuctionPrice.toDouble() &gt; bestNBBOPrice.toDouble())</TD></TR><TR><TD CLASS="l">521</TD><TD>            { // auction(book) side is buy side, to favor auction, price goes down.</TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>                  newPrice = midPointFloor ;</TD></TR><TR><TD CLASS="l">523</TD><TD>            }</TD></TR><TR><TD CLASS="l">524</TD><TD>            else</TD></TR><TR><TD CLASS="l">525</TD><TD>            { // auction(book) side is sell side, to favor auction, price goes up.</TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>                  newPrice = midPointCeil;</TD></TR><TR><TD CLASS="l">527</TD><TD>            }</TD></TR><TR><TD CLASS="l">528</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">529</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">530</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>            Log.debug(  &#34;Get the midPoint price between the bestAuctionPrice (&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                    + bestAuctionPrice + &#34;) and bestNBBOPrice (&#34; + bestNBBOPrice + &#34;) = &#34; + newPrice);</TD></TR><TR><TD CLASS="l">533</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>        return newPrice;</TD></TR><TR><TD CLASS="l"><A NAME="f">535</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">536</TD><TD> </TD></TR><TR><TD CLASS="l">537</TD><TD>    private static String getAuctionInfoForSameSideIncomingTradable(Tradable incomingTradable, AuctionInternal auction, Price bestPrice)</TD></TR><TR><TD CLASS="l">538</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">539</TD><TD>        String msg = &#34; Price of the same side incoming Tradable = &#34; + incomingTradable.getPrice()</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                      + &#34;, productKey = &#34; + incomingTradable.getProductKey()</TD></TR><TR CLASS="z"><TD CLASS="l">541</TD><TD>                      + &#34;, Ending auctionnId = &#34; + StructToString.toString(auction.getAuctionId())</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                      + &#34;, TradableSide = &#34; + incomingTradable.getSide()</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>                      + &#34;, AuctionSide = &#34; + auction.getSide()</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>                      + &#34;, Best price point of auction participants = &#34; + bestPrice;</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>        return msg;</TD></TR><TR><TD CLASS="l"><A NAME="d">546</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">547</TD><TD> </TD></TR><TR><TD CLASS="l">548</TD><TD>    private static String getAuctionInfoForOppositeSideIncomingTradable(Tradable incomingTradable, AuctionInternal auction, Price bestBookPrice)</TD></TR><TR><TD CLASS="l">549</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>        String msg = &#34; Price of the opposite side incoming Tradable = &#34; + incomingTradable.getPrice()</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>                  + &#34;, productKey = &#34; + incomingTradable.getProductKey()</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                  + &#34;, Ending auctionnId = &#34; + StructToString.toString(auction.getAuctionId())</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                  + &#34;, TradableSide = &#34; + incomingTradable.getSide()</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                  + &#34;, AuctionSide = &#34; + auction.getSide()</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                  + &#34;, auctionStartingPrice = &#34; + auction.getStartingPrice()</TD></TR><TR><TD CLASS="l">556</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>                  + &#34;, Best book Price of auctionSide = &#34; + bestBookPrice ;</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>        return msg;</TD></TR><TR><TD CLASS="l"><A NAME="e">559</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">560</TD><TD> </TD></TR><TR><TD CLASS="l">561</TD><TD>    private static String getAuctionInfoForOppositeSideIncomingTradable(Tradable incomingTradable, AuctionInternal auction, Price bestBookPrice, Price bestAuctionPrice)</TD></TR><TR><TD CLASS="l">562</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="12">563</A></TD><TD>        return getAuctionInfoForOppositeSideIncomingTradable (incomingTradable, auction, bestBookPrice ) + &#34;, Best price point of auction participants = &#34; + bestAuctionPrice;</TD></TR><TR><TD CLASS="l">564</TD><TD>    }</TD></TR><TR><TD CLASS="l">565</TD><TD>    private static Price getBestPricePointOfAuction(AuctionInternal auction, OrderBook book)</TD></TR><TR><TD CLASS="l">566</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">567</TD><TD>        Price bestResponsePrice = noPrice;</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>        if (auction.getAuctionBook().getBestAuctionResponsePriceItem() != null)</TD></TR><TR><TD CLASS="l">569</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>            bestResponsePrice = auction.getAuctionBook().getBestAuctionResponsePriceItem().getItemPrice();</TD></TR><TR><TD CLASS="l">571</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>        Price bestPrice = auction.getStartingPrice() ;</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>        if (auction.getSide().getOtherSide().isFirstBetter(bestResponsePrice, bestPrice))</TD></TR><TR><TD CLASS="l">574</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>            bestPrice = bestResponsePrice;</TD></TR><TR><TD CLASS="l">576</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>        Price bestBookPrice = book.getBestPrice( auction.getSide().getOtherSide());</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>        if (auction.getSide().getOtherSide().isFirstBetter(bestBookPrice, bestPrice))</TD></TR><TR><TD CLASS="l">579</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>            bestPrice = bestBookPrice;</TD></TR><TR><TD CLASS="l">581</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>        return bestPrice;</TD></TR><TR><TD CLASS="l">583</TD><TD>    }</TD></TR><TR><TD CLASS="l">584</TD><TD> </TD></TR><TR><TD CLASS="l">585</TD><TD> </TD></TR><TR><TD CLASS="l">586</TD><TD>    /**</TD></TR><TR><TD CLASS="l">587</TD><TD>     * This method tries to trade the incoming same side NonQ order with the auction remainder,</TD></TR><TR><TD CLASS="l">588</TD><TD>     * or to trade the rest same side NonQ book with the remainder of the incoming auction response.</TD></TR><TR><TD CLASS="l">589</TD><TD>     * Here the auction remainder excludes the firm match order.</TD></TR><TR><TD CLASS="l">590</TD><TD>     */</TD></TR><TR><TD CLASS="l">591</TD><TD>    private static int tradeWithAuctionRemainder(TradeService tradeService, AuctionInternal auction,</TD></TR><TR><TD CLASS="l">592</TD><TD>                                          ArrayList sameSideNonQPriceDetailList,</TD></TR><TR><TD CLASS="l"><A NAME="1d">593</A></TD><TD>                                          int quantityToAllocate, Price priceConstraint,</TD></TR><TR><TD CLASS="l">594</TD><TD>                                          OrderBook book,</TD></TR><TR><TD CLASS="l">595</TD><TD>                                          boolean responseOnly)   throws SystemException</TD></TR><TR><TD CLASS="l">596</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">597</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">598</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>            Log.debug(  myClassName + &#34;.tradeWithAuctionRemainder responses only =&gt; for auctionId =&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">600</TD><TD>                    + StructToString.toString(auction.getAuctionId())</TD></TR><TR CLASS="z"><TD CLASS="l">601</TD><TD>                    + &#34;, with quantityToAllocate =&#34; +quantityToAllocate</TD></TR><TR CLASS="z"><TD CLASS="l">602</TD><TD>                    + &#34;, with priceConstraint = &#34; +priceConstraint</TD></TR><TR><TD CLASS="l">603</TD><TD>                    );</TD></TR><TR><TD CLASS="l">604</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>        boolean ignoreMatchOrder = true; // always ignore the match order when to trade with remainder</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>        AllocationAuctionTradeContextImpl allocationContext = createAuctionTradeContext(auction, responseOnly,ignoreMatchOrder);</TD></TR><TR CLASS="z"><TD CLASS="l">607</TD><TD>        Tradable incomingOppositeTradable = null;</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>        boolean matchIndicator = false;</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>        Enumeration sameSide = Collections.enumeration(sameSideNonQPriceDetailList);</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>        Tradable sameSideTradable = null; // the internalized order has already been traded at this moment.</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>        return tradeAuction(tradeService, auction, book, priceConstraint, quantityToAllocate, allocationContext,</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>                incomingOppositeTradable, matchIndicator, sameSide, sameSideTradable);</TD></TR><TR><TD CLASS="l">613</TD><TD>    }</TD></TR><TR><TD CLASS="l">614</TD><TD>    /**</TD></TR><TR><TD CLASS="l">615</TD><TD>     * Trade  the same side tradable / same side NonQ markets</TD></TR><TR><TD CLASS="l">616</TD><TD>     * (only one of them can be traded with auction at the same time)</TD></TR><TR><TD CLASS="l">617</TD><TD>     * against the opposite order book and auciton book</TD></TR><TR><TD CLASS="l">618</TD><TD>     * @param auction</TD></TR><TR><TD CLASS="l">619</TD><TD>     * @param book</TD></TR><TR><TD CLASS="l">620</TD><TD>     * @param priceConstraint</TD></TR><TR><TD CLASS="l">621</TD><TD>     * @param quantityToAllocate</TD></TR><TR><TD CLASS="l">622</TD><TD>     * @param allocationContext</TD></TR><TR><TD CLASS="l">623</TD><TD>     * @param incomingOppositeTradable</TD></TR><TR><TD CLASS="l">624</TD><TD>     * @param matchIndicator</TD></TR><TR><TD CLASS="l">625</TD><TD>     * @param sameSideNonQPriceDetails - the same side markets to be traded,</TD></TR><TR><TD CLASS="l">626</TD><TD>     * it has to be null, when sameSideTradable is not null</TD></TR><TR><TD CLASS="l">627</TD><TD>     * @param sameSideTradable - the same side Tradable to be traded,</TD></TR><TR><TD CLASS="l">628</TD><TD>     * it has to be null, when sameSideNonQPriceDetails is not null</TD></TR><TR><TD CLASS="l">629</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">630</TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l">631</TD><TD>     */</TD></TR><TR><TD CLASS="l">632</TD><TD>    private static int tradeAuction(TradeService tradeService, AuctionInternal auction, OrderBook book,</TD></TR><TR><TD CLASS="l">633</TD><TD>                             Price priceConstraint, int quantityToAllocate,</TD></TR><TR><TD CLASS="l">634</TD><TD>                             AllocationAuctionTradeContextImpl allocationContext,</TD></TR><TR><TD CLASS="l">635</TD><TD>                             Tradable incomingOppositeTradable, boolean matchIndicator,</TD></TR><TR><TD CLASS="l"><A NAME="18">636</A></TD><TD>                             Enumeration sameSideNonQPriceDetails,</TD></TR><TR><TD CLASS="l">637</TD><TD>                             Tradable sameSideTradable)</TD></TR><TR><TD CLASS="l">638</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">639</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>        int allocatedQuantity = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>        ArrayList oppositeParticipantLists = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>        ArrayList tradePrices = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>        ArrayList tradeQuantities = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>        boolean tradeHappened = false;</TD></TR><TR><TD CLASS="l">645</TD><TD>        </TD></TR><TR><TD CLASS="l">646</TD><TD>        try</TD></TR><TR><TD CLASS="l">647</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>        int oppositeAllocatedQuantity = createInternalizationAuctionParticipantLists(auction, oppositeParticipantLists, tradePrices, tradeQuantities, book, priceConstraint, quantityToAllocate, allocationContext, incomingOppositeTradable, matchIndicator);</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>        if (oppositeAllocatedQuantity &gt; 0 )</TD></TR><TR><TD CLASS="l">650</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">651</TD><TD>            ArrayList sameSideParticipantLists = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>            int sameSideAllocatedQuantity = tradeService.createParticipantLists(sameSideParticipantLists, tradePrices, tradeQuantities,</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>                    sameSideTradable, sameSideNonQPriceDetails, oppositeAllocatedQuantity, book.getTradingProduct().getTradingClass(),false);</TD></TR><TR><TD CLASS="l">654</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>            if ( sameSideTradable != null) // i.e. only need to set when it trades the internalized order</TD></TR><TR><TD CLASS="l">656</TD><TD>            {</TD></TR><TR><TD CLASS="l">657</TD><TD>                //set the trade context in participant itesm</TD></TR><TR CLASS="z"><TD CLASS="l">658</TD><TD>                prepareParticipantsForTrade(oppositeParticipantLists, TradeContext.AUCTION_TRADE);</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                prepareParticipantsForTrade(sameSideParticipantLists, TradeContext.AUCTION_TRADE);</TD></TR><TR><TD CLASS="l">660</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>            if (sameSideAllocatedQuantity != oppositeAllocatedQuantity)</TD></TR><TR><TD CLASS="l">662</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                allocatedQuantity = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>                Log.alarm( myClassName + &#34;.tradeAuction =&gt; the allocated quantity(&#34; + sameSideAllocatedQuantity +&#34;) is different from the other side ( &#34; +oppositeAllocatedQuantity +&#34;)&#34; );</TD></TR><TR><TD CLASS="l">665</TD><TD>            }</TD></TR><TR><TD CLASS="l">666</TD><TD>            else</TD></TR><TR><TD CLASS="l">667</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>                allocatedQuantity = sameSideAllocatedQuantity;</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                Side sameSide = auction.getSide();</TD></TR><TR><TD CLASS="l">670</TD><TD>                try</TD></TR><TR><TD CLASS="l">671</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>                    if (sameSide.isBuySide())</TD></TR><TR><TD CLASS="l">673</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                        tradeService.completeTrades (null, sameSideParticipantLists, oppositeParticipantLists, tradePrices, tradeQuantities, book, null);</TD></TR><TR><TD CLASS="l">675</TD><TD>                    }</TD></TR><TR><TD CLASS="l">676</TD><TD>                    else</TD></TR><TR><TD CLASS="l">677</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">678</TD><TD>                        tradeService.completeTrades(null, oppositeParticipantLists, sameSideParticipantLists, tradePrices, tradeQuantities, book, null);</TD></TR><TR><TD CLASS="l">679</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>                    tradeHappened = true;</TD></TR><TR><TD CLASS="l">681</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>                catch( SpreadProcessingException spe)</TD></TR><TR><TD CLASS="l">683</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>                    Log.exception(  spe.getMessage(), spe);</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>                    throw ExceptionBuilder.systemException(spe.getMessage(),  0);</TD></TR><TR><TD CLASS="l">686</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>                catch( DataValidationException de)</TD></TR><TR><TD CLASS="l">688</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                    Log.exception(  de + de.details.message, de);</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>                    throw ExceptionBuilder.systemException(de.getMessage(),  0);</TD></TR><TR><TD CLASS="l">691</TD><TD>                }</TD></TR><TR><TD CLASS="l">692</TD><TD>            }</TD></TR><TR><TD CLASS="l">693</TD><TD>        }</TD></TR><TR><TD CLASS="l">694</TD><TD>        }</TD></TR><TR><TD CLASS="l">695</TD><TD>        finally</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>            if (tradeHappened)</TD></TR><TR><TD CLASS="l">698</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                OrderBookPriceDetailUndoLog.clear();</TD></TR><TR><TD CLASS="l">700</TD><TD>            }</TD></TR><TR><TD CLASS="l">701</TD><TD>            else</TD></TR><TR><TD CLASS="l">702</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>                OrderBookPriceDetailUndoLog.undoChange();</TD></TR><TR><TD CLASS="l">704</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>        }</TD></TR><TR><TD CLASS="l">706</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>        return  allocatedQuantity;</TD></TR><TR><TD CLASS="l">708</TD><TD>    }</TD></TR><TR><TD CLASS="l">709</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="a">710</A></TD><TD>    protected static int createInternalizationAuctionTrade(TradeService tradeService, AuctionInternal auction, OrderBook book,</TD></TR><TR><TD CLASS="l">711</TD><TD>                                                  Tradable incomingOppositeTradable, boolean matchIndicator)</TD></TR><TR><TD CLASS="l">712</TD><TD>            throws SystemException</TD></TR><TR><TD CLASS="l">713</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>        int quantityToAllocate = auction.getAuctionedOrder().getQuantityAllowed();</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>        AllocationAuctionTradeContextImpl allocationContext = createAuctionTradeContext(auction, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>        Tradable sameSideTradable = auction.getAuctionedOrder();</TD></TR><TR><TD CLASS="l">717</TD><TD>        // No same markets could be traded before internalized order is fully traded at auction expiration.</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>        Enumeration sameSideNonQPriceDetails = null;</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>        Price priceConstraint =  auction.getStartingPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>        return tradeAuction(tradeService, auction, book, priceConstraint, quantityToAllocate, allocationContext,</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                incomingOppositeTradable, matchIndicator, sameSideNonQPriceDetails, sameSideTradable);</TD></TR><TR><TD CLASS="l">722</TD><TD>    }</TD></TR><TR><TD CLASS="l">723</TD><TD> </TD></TR><TR><TD CLASS="l">724</TD><TD>    /**</TD></TR><TR><TD CLASS="l">725</TD><TD>     * Creates Lists of ParticipantList, trade prices and trade quantity from the opposite book,</TD></TR><TR><TD CLASS="l">726</TD><TD>     * for each price point which is better than/ equal to the ending price</TD></TR><TR><TD CLASS="l">727</TD><TD>     * @param auction                   - the auction to be allcoated</TD></TR><TR><TD CLASS="l">728</TD><TD>     * @param outputParticipantsLists   - list of &lt;code&gt; ParticipantList&lt;/code&gt; to be created</TD></TR><TR><TD CLASS="l">729</TD><TD>     * @param outputTradePrices                - list of trade prices for each ParticipantList to be created</TD></TR><TR><TD CLASS="l">730</TD><TD>     * @param outputTradeQuantityList        - list of trade quantities for each ParticipantList to be created</TD></TR><TR><TD CLASS="l">731</TD><TD>     * @param orderBook                 - the order book</TD></TR><TR><TD CLASS="l">732</TD><TD>     * @param tradePrice                        - crossing end price for each tradable to be able to trade on</TD></TR><TR><TD CLASS="l">733</TD><TD>     * @param quantityToAllocate                - total quantity to allocate</TD></TR><TR><TD CLASS="l">734</TD><TD>     * @param allocationContext         - the auction trade context</TD></TR><TR><TD CLASS="l">735</TD><TD>     * @param incomingOppositeTradable  - the opposite incoming tradable which terminates the auction</TD></TR><TR><TD CLASS="l">736</TD><TD>     *                                  with a price marketable against regular order book</TD></TR><TR><TD CLASS="l">737</TD><TD>     *                                  it will participate the auction trade with best price point (if any)</TD></TR><TR><TD CLASS="l">738</TD><TD>     * @param matchIndicator            - to indicate if the opposite incoming tradable is to be matchable if any</TD></TR><TR><TD CLASS="l">739</TD><TD>     * @return total allocated quantity</TD></TR><TR><TD CLASS="l">740</TD><TD>     */</TD></TR><TR><TD CLASS="l">741</TD><TD>    private static int createInternalizationAuctionParticipantLists(AuctionInternal auction,</TD></TR><TR><TD CLASS="l">742</TD><TD>                                    ArrayList outputParticipantsLists,</TD></TR><TR><TD CLASS="l">743</TD><TD>                                    ArrayList outputTradePrices,</TD></TR><TR><TD CLASS="l">744</TD><TD>                                    ArrayList outputTradeQuantityList,</TD></TR><TR><TD CLASS="l">745</TD><TD>                                    OrderBook orderBook,</TD></TR><TR><TD CLASS="l">746</TD><TD>                                    Price tradePrice,</TD></TR><TR><TD CLASS="l">747</TD><TD>                                    int quantityToAllocate,</TD></TR><TR><TD CLASS="l">748</TD><TD>                                    AllocationAuctionTradeContext allocationContext,</TD></TR><TR><TD CLASS="l"><A NAME="9">749</A></TD><TD>                                    Tradable incomingOppositeTradable,</TD></TR><TR><TD CLASS="l">750</TD><TD>                                    boolean matchIndicator)</TD></TR><TR><TD CLASS="l">751</TD><TD>    {</TD></TR><TR><TD CLASS="l">752</TD><TD>        // pass the original order quantity which could be used as the CAP in CUMA.</TD></TR><TR CLASS="z"><TD CLASS="l">753</TD><TD>        int capConstraint = auction.getAuctionedOrder().getOriginalQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>        if (auction.getAuctionedOrder().getRemainingQuantity() == 0)</TD></TR><TR><TD CLASS="l">755</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">756</TD><TD>            capConstraint = quantityToAllocate; // the same auction side qty to be traded</TD></TR><TR><TD CLASS="l">757</TD><TD>        }</TD></TR><TR><TD CLASS="l">758</TD><TD>        // get the allocation strategy object</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>        AllocationStrategy allocationStrategy =((OrderBookImpl)orderBook).getAllocationStrategy(allocationContext);</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>        AuctionBook auctionBook = auction.getAuctionBook();</TD></TR><TR><TD CLASS="l">761</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">762</TD><TD>        matchIndicator = ( auction.getFirmMatchOrder() != null) &amp;&amp; matchIndicator</TD></TR><TR CLASS="z"><TD CLASS="l">763</TD><TD>                         &amp;&amp;  auction.getFirmMatchOrder().getPrice().isMarketPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>        Tradable originalFirmMatch = null;</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>        if (matchIndicator)</TD></TR><TR><TD CLASS="l">766</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>            originalFirmMatch = auction.getFirmMatchOrder();</TD></TR><TR><TD CLASS="l">768</TD><TD>        }</TD></TR><TR><TD CLASS="l">769</TD><TD>        // get the priority tradable sets from the opposite side of both regular book and auction book, to allocate</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>        Iterator priorityTradableSets = null;</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>        if (auction.getFirmMatchOrder().getContingencyType() == ContingencyTypes.AON)</TD></TR><TR><TD CLASS="l">772</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">773</TD><TD>            priorityTradableSets = allocationStrategy.getAONAuctionPrioritySets(auctionBook, orderBook, tradePrice, quantityToAllocate,allocationContext,capConstraint, incomingOppositeTradable, matchIndicator, originalFirmMatch);</TD></TR><TR><TD CLASS="l">774</TD><TD>        }</TD></TR><TR><TD CLASS="l">775</TD><TD>        else</TD></TR><TR><TD CLASS="l">776</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">777</TD><TD>            priorityTradableSets = allocationStrategy.getPrioritySets(auctionBook, orderBook, tradePrice, quantityToAllocate,allocationContext,capConstraint, incomingOppositeTradable, matchIndicator, originalFirmMatch);</TD></TR><TR><TD CLASS="l">778</TD><TD>        }</TD></TR><TR><TD CLASS="l">779</TD><TD> </TD></TR><TR><TD CLASS="l">780</TD><TD>        // create participant lists based on the priority tradable sets</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>        Side oppositeAuctionSide = auction.getSide().getOtherSide();</TD></TR><TR CLASS="z"><TD CLASS="l">782</TD><TD>        TradingProduct aProduct = orderBook.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">783</TD><TD>        int allocatedQty  =  createParticipantLists(priorityTradableSets,oppositeAuctionSide,aProduct, quantityToAllocate,</TD></TR><TR CLASS="z"><TD CLASS="l">784</TD><TD>                              outputParticipantsLists, outputTradePrices,outputTradeQuantityList);</TD></TR><TR><TD CLASS="l">785</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>        return  allocatedQty;</TD></TR><TR><TD CLASS="l">787</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="7">788</A></TD><TD> </TD></TR><TR><TD CLASS="l">789</TD><TD>    // create and set up allocate context</TD></TR><TR><TD CLASS="l">790</TD><TD>    private static AllocationAuctionTradeContextImpl createAuctionTradeContext(AuctionInternal auction, boolean responsesOnly, boolean ignoreMatch)</TD></TR><TR><TD CLASS="l">791</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>        AllocationAuctionTradeContextImpl allocationContext = new AllocationAuctionTradeContextImpl(AllocationTradeTypes.INTERNALIZATION_AUCTION_TRADE);</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>        allocationContext.setTimeToCompare(auction.getStartTime());</TD></TR><TR CLASS="z"><TD CLASS="l">794</TD><TD>        allocationContext.setIsTimeSortingRequired(true);</TD></TR><TR><TD CLASS="l">795</TD><TD>        // Trade the same side markets from the regular book or incoming order against</TD></TR><TR><TD CLASS="l">796</TD><TD>        // the remainding qty of the participants of auction response only</TD></TR><TR CLASS="z"><TD CLASS="l">797</TD><TD>        if (responsesOnly)</TD></TR><TR><TD CLASS="l">798</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>            allocationContext.setAuctionResponsesOnlyFlag(true);</TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>            allocationContext.setIgnoreMatchOrder(true);</TD></TR><TR CLASS="z"><TD CLASS="l">801</TD><TD>            allocationContext.setIncludeFirmMatchGroup(false);</TD></TR><TR><TD CLASS="l">802</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>        else if (ignoreMatch)</TD></TR><TR><TD CLASS="l">804</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">805</TD><TD>            allocationContext.setIgnoreMatchOrder(true);</TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>            allocationContext.setIncludeFirmMatchGroup(false);</TD></TR><TR><TD CLASS="l">807</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">808</TD><TD>        return allocationContext;</TD></TR><TR><TD CLASS="l">809</TD><TD>    }</TD></TR><TR><TD CLASS="l">810</TD><TD> </TD></TR><TR><TD CLASS="l">811</TD><TD> </TD></TR><TR><TD CLASS="l">812</TD><TD>   /**</TD></TR><TR><TD CLASS="l"><A NAME="2">813</A></TD><TD>     * Add more participants to the existing list</TD></TR><TR><TD CLASS="l">814</TD><TD>     */</TD></TR><TR><TD CLASS="l">815</TD><TD>   private static void addMoreParticipants(ParticipantList currentList, ParticipantList newList)</TD></TR><TR><TD CLASS="l">816</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">817</TD><TD>        Enumeration newElements = newList.elements();</TD></TR><TR CLASS="z"><TD CLASS="l">818</TD><TD>        while (newElements.hasMoreElements())</TD></TR><TR><TD CLASS="l">819</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">820</TD><TD>            ParticipantItem newElement = (ParticipantItem) newElements.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">821</TD><TD>            ParticipantItem existingElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">822</TD><TD>            ParticipantItem foundElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">823</TD><TD>            Enumeration existingElements = currentList.elements();</TD></TR><TR CLASS="z"><TD CLASS="l">824</TD><TD>            while (existingElements.hasMoreElements())</TD></TR><TR><TD CLASS="l">825</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">826</TD><TD>                existingElement = (ParticipantItem) existingElements.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>                if (existingElement.getParticipantTradable() == newElement.getParticipantTradable())</TD></TR><TR><TD CLASS="l">828</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">829</TD><TD>                    foundElement = existingElement;</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">831</TD><TD>                }</TD></TR><TR><TD CLASS="l">832</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">833</TD><TD>            if (foundElement == null)</TD></TR><TR><TD CLASS="l">834</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">835</TD><TD>                ParticipantItemImpl elementToAdd= new ParticipantItemImpl(newElement.getParticipantTradable(),newElement.getParticipantQuantity());</TD></TR><TR CLASS="z"><TD CLASS="l">836</TD><TD>                currentList.addElement(elementToAdd);</TD></TR><TR><TD CLASS="l">837</TD><TD>            }</TD></TR><TR><TD CLASS="l">838</TD><TD>            else</TD></TR><TR><TD CLASS="l">839</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">840</TD><TD>                foundElement.consolidateTradeQuantity(newElement.getParticipantQuantity());</TD></TR><TR><TD CLASS="l">841</TD><TD>            }</TD></TR><TR><TD CLASS="l">842</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">843</TD><TD>    }</TD></TR><TR><TD CLASS="l">844</TD><TD> </TD></TR><TR><TD CLASS="l">845</TD><TD>    /**</TD></TR><TR><TD CLASS="l">846</TD><TD>     * Determine whether use the best Book Price or 1 tick better than best book price</TD></TR><TR><TD CLASS="l">847</TD><TD>     * by checking against the Customer order quantity of the price in the book</TD></TR><TR><TD CLASS="l">848</TD><TD>     *</TD></TR><TR><TD CLASS="l">849</TD><TD>     * @param auctionSide - the side of the auctioned order</TD></TR><TR><TD CLASS="l">850</TD><TD>     * @param orderBook   - the order book</TD></TR><TR><TD CLASS="l">851</TD><TD>     * @param auctionType - auction type</TD></TR><TR><TD CLASS="l">852</TD><TD>     * @param oppositeRemainingQty - the potential remaining quantity of the opposite incoming tradable</TD></TR><TR><TD CLASS="l">853</TD><TD>     * which could trade with the existing customer order in the book after the auction trade</TD></TR><TR><TD CLASS="l"><A NAME="11">854</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">855</TD><TD>     */</TD></TR><TR><TD CLASS="l">856</TD><TD>    public static Price getBestBookPriceOrOneTickBetter(Side auctionSide, OrderBook orderBook, short auctionType, int oppositeRemainingQty)</TD></TR><TR><TD CLASS="l">857</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">858</TD><TD>        Price tradePrice = orderBook.getBestPrice(auctionSide);</TD></TR><TR><TD CLASS="l">859</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">860</TD><TD>        OrderBookPriceItem bestBookPriceItem = null;</TD></TR><TR CLASS="z"><TD CLASS="l">861</TD><TD>        if (auctionSide.isBuySide() || auctionSide.isAsDefinedSide())</TD></TR><TR><TD CLASS="l">862</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>            bestBookPriceItem = ((OrderBookImpl) orderBook).getBuySideItem().getPriceItem(tradePrice);</TD></TR><TR><TD CLASS="l">864</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>        else if (auctionSide.isSellSide() || auctionSide.isOppositeSide())</TD></TR><TR><TD CLASS="l">866</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">867</TD><TD>            bestBookPriceItem = ((OrderBookImpl) orderBook).getSellSideItem().getPriceItem(tradePrice);</TD></TR><TR><TD CLASS="l">868</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">869</TD><TD>        int  aonVolume = bestBookPriceItem.getAonOrderVolume();</TD></TR><TR CLASS="z"><TD CLASS="l">870</TD><TD>        boolean nonContingenCustomerAtTheTop = (aonVolume &lt; bestBookPriceItem.getNonQPriOnlyQuantity());</TD></TR><TR><TD CLASS="l">871</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">872</TD><TD>        if ( bestBookPriceItem != null &amp;&amp; bestBookPriceItem.getNonQPriOnlyQuantity() &gt; 0 &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">873</TD><TD>                  nonContingenCustomerAtTheTop &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">874</TD><TD>              bestBookPriceItem.getNonQPriOnlyQuantity() &gt; oppositeRemainingQty )</TD></TR><TR><TD CLASS="l">875</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">876</TD><TD>            TradingClass tradingClass = orderBook.getTradingProduct().getTradingClass();</TD></TR><TR CLASS="z"><TD CLASS="l">877</TD><TD>            tradePrice = calculateTradePriceOneTickBetter(tradePrice, auctionSide, tradingClass, auctionType);</TD></TR><TR><TD CLASS="l">878</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">879</TD><TD>        return tradePrice;</TD></TR><TR><TD CLASS="l"><A NAME="3">880</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">881</TD><TD>    </TD></TR><TR><TD CLASS="l">882</TD><TD>    public static Price calculateTradePriceNTicksBetter(Price bestPrice, Side auctionSide, TradingClass tradingClass, short auctionType, int numOfTicks)</TD></TR><TR><TD CLASS="l">883</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">884</TD><TD>        if (auctionSide.isBuySide())</TD></TR><TR><TD CLASS="l">885</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>            return tradingClass.addAuctionTicks(bestPrice,numOfTicks, auctionType);</TD></TR><TR><TD CLASS="l">887</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>        else  if (auctionSide.isSellSide()|| auctionSide.isOppositeSide() || auctionSide.isAsDefinedSide() )</TD></TR><TR><TD CLASS="l">889</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">890</TD><TD>            return tradingClass.addAuctionTicks(bestPrice,-1*numOfTicks, auctionType);</TD></TR><TR><TD CLASS="l">891</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">892</TD><TD>        return null; </TD></TR><TR><TD CLASS="l"><A NAME="4">893</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">894</TD><TD> </TD></TR><TR><TD CLASS="l">895</TD><TD>    public static Price calculateTradePriceOneTickBetter(Price bestPrice, Side auctionSide, TradingClass tradingClass, short auctionType)</TD></TR><TR><TD CLASS="l">896</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">897</TD><TD>        return calculateTradePriceNTicksBetter(bestPrice, auctionSide, tradingClass, auctionType, 1);</TD></TR><TR><TD CLASS="l">898</TD><TD>    }</TD></TR><TR><TD CLASS="l">899</TD><TD> </TD></TR><TR><TD CLASS="l">900</TD><TD> </TD></TR><TR><TD CLASS="l">901</TD><TD> </TD></TR><TR><TD CLASS="l">902</TD><TD>    /**</TD></TR><TR><TD CLASS="l">903</TD><TD>     * Creates Lists of ParticipantList, trade prices and trade quantity from the opposite book,</TD></TR><TR><TD CLASS="l">904</TD><TD>     * for each price point which is better than/ equal to the ending price</TD></TR><TR><TD CLASS="l">905</TD><TD>     * @param internalizationPair       the internalization pair of orders to be allcoated</TD></TR><TR><TD CLASS="l">906</TD><TD>     * @param outputParticipantList     list of &lt;code&gt; ParticipantList&lt;/code&gt; to be created</TD></TR><TR><TD CLASS="l">907</TD><TD>     * @param outputTradePrices                list of trade prices for each ParticipantList to be created</TD></TR><TR><TD CLASS="l">908</TD><TD>     * @param outputTradeQuantityList        list of trade quantities for each ParticipantList to be created</TD></TR><TR><TD CLASS="l">909</TD><TD>     * @param orderBook                      the order book</TD></TR><TR><TD CLASS="l">910</TD><TD>     * @param tradePrice                        crossing end price for each tradable to be able to trade on</TD></TR><TR><TD CLASS="l">911</TD><TD>     * @param quantityToAllocate                total quantity to allocate</TD></TR><TR><TD CLASS="l">912</TD><TD>     * @return total allocated quantity</TD></TR><TR><TD CLASS="l">913</TD><TD>     */</TD></TR><TR><TD CLASS="l">914</TD><TD>    protected static int createInternalizationParticipantLists(InternalizationPair internalizationPair,</TD></TR><TR><TD CLASS="l">915</TD><TD>                                    ArrayList outputParticipantList,</TD></TR><TR><TD CLASS="l">916</TD><TD>                                    ArrayList outputTradePrices,</TD></TR><TR><TD CLASS="l">917</TD><TD>                                    ArrayList outputTradeQuantityList,</TD></TR><TR><TD CLASS="l">918</TD><TD>                                    OrderBook orderBook,</TD></TR><TR><TD CLASS="l">919</TD><TD>                                    Price tradePrice,</TD></TR><TR><TD CLASS="l">920</TD><TD>                                    int quantityToAllocate)</TD></TR><TR><TD CLASS="l"><A NAME="b">921</A></TD><TD>    {</TD></TR><TR><TD CLASS="l">922</TD><TD> </TD></TR><TR><TD CLASS="l">923</TD><TD>        // create and set up allocate context</TD></TR><TR><TD CLASS="l">924</TD><TD>        AllocationAuctionTradeContextImpl allocationContext;</TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>        allocationContext = new AllocationAuctionTradeContextImpl(AllocationTradeTypes.INTERNALIZATION_NO_AUCTION_TRADE);</TD></TR><TR><TD CLASS="l">926</TD><TD>        // get the allocation strategy object</TD></TR><TR CLASS="z"><TD CLASS="l">927</TD><TD>        AllocationStrategy allocationStrategy =((OrderBookImpl)orderBook).getAllocationStrategy(allocationContext);</TD></TR><TR><TD CLASS="l">928</TD><TD> </TD></TR><TR><TD CLASS="l">929</TD><TD>        // get the priority tradable sets of the side to allocate</TD></TR><TR CLASS="z"><TD CLASS="l">930</TD><TD>        ArrayList aPriceDetailList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">931</TD><TD>        Tradable matchTradable = internalizationPair.getSecondaryOrder();</TD></TR><TR CLASS="z"><TD CLASS="l">932</TD><TD>        OrderBookPriceDetail matchPriceDetail = new OrderBookPriceDetailTransientImpl(matchTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>        aPriceDetailList.add(matchPriceDetail);</TD></TR><TR CLASS="z"><TD CLASS="l">934</TD><TD>        Iterator priorityTradableSets = allocationStrategy.getPrioritySets(aPriceDetailList, tradePrice, quantityToAllocate,</TD></TR><TR CLASS="z"><TD CLASS="l">935</TD><TD>                orderBook.getTradingProduct().getTradingClass());</TD></TR><TR><TD CLASS="l">936</TD><TD> </TD></TR><TR><TD CLASS="l">937</TD><TD>        // create participant lists based on the priority tradable sets</TD></TR><TR CLASS="z"><TD CLASS="l">938</TD><TD>        Side tradableSide = matchTradable.getSide();</TD></TR><TR CLASS="z"><TD CLASS="l">939</TD><TD>        TradingProduct aProduct = orderBook.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">940</TD><TD>        return createParticipantLists(priorityTradableSets,tradableSide,aProduct, quantityToAllocate,</TD></TR><TR CLASS="z"><TD CLASS="l">941</TD><TD>                                        outputParticipantList, outputTradePrices,outputTradeQuantityList);</TD></TR><TR><TD CLASS="l">942</TD><TD> </TD></TR><TR><TD CLASS="l">943</TD><TD>    }</TD></TR><TR><TD CLASS="l">944</TD><TD>    /**</TD></TR><TR><TD CLASS="l">945</TD><TD>     * Create participants list, trade price list and trade quantity list</TD></TR><TR><TD CLASS="l">946</TD><TD>     * @param priorityTradableSets -the input priority tradableSets</TD></TR><TR><TD CLASS="l">947</TD><TD>     * @param tradableSide -the side of the priority tradable sets</TD></TR><TR><TD CLASS="l">948</TD><TD>     * @param aProduct</TD></TR><TR><TD CLASS="l">949</TD><TD>     * @param quantityToAllocate</TD></TR><TR><TD CLASS="l">950</TD><TD>     * @param outputParticipantsLists</TD></TR><TR><TD CLASS="l">951</TD><TD>     * @param outputTradePrices</TD></TR><TR><TD CLASS="l">952</TD><TD>     * @param outputTradeQuantityList</TD></TR><TR><TD CLASS="l">953</TD><TD>     * @return the total allocated quantity to the input priorityTradableSets</TD></TR><TR><TD CLASS="l">954</TD><TD>     */</TD></TR><TR><TD CLASS="l">955</TD><TD>    private static int createParticipantLists(Iterator priorityTradableSets,</TD></TR><TR><TD CLASS="l">956</TD><TD>                                    Side tradableSide,</TD></TR><TR><TD CLASS="l">957</TD><TD>                                    TradingProduct aProduct,</TD></TR><TR><TD CLASS="l">958</TD><TD>                                    int quantityToAllocate,</TD></TR><TR><TD CLASS="l"><A NAME="c">959</A></TD><TD>                                    ArrayList outputParticipantsLists,</TD></TR><TR><TD CLASS="l">960</TD><TD>                                    ArrayList outputTradePrices,</TD></TR><TR><TD CLASS="l">961</TD><TD>                                    ArrayList outputTradeQuantityList)</TD></TR><TR><TD CLASS="l">962</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>        int allocatedQuantity = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">964</TD><TD>        Price currentPrice = new NoPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">965</TD><TD>        int allocatedAtCurrentPrice = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>        ParticipantList currentOpposite = null;</TD></TR><TR CLASS="z"><TD CLASS="l">967</TD><TD>        while (priorityTradableSets.hasNext()&amp;&amp; allocatedQuantity &lt; quantityToAllocate)</TD></TR><TR><TD CLASS="l">968</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">969</TD><TD>            PriorityTradableSet nextSet = (PriorityTradableSet) priorityTradableSets.next();</TD></TR><TR CLASS="z"><TD CLASS="l">970</TD><TD>            if (nextSet.getPrice() != currentPrice ) {</TD></TR><TR><TD CLASS="l">971</TD><TD>                // The first time through, currentPrice will be a NoPrice.</TD></TR><TR><TD CLASS="l">972</TD><TD>                // If this is not the first time through, we have hit a new price that we</TD></TR><TR><TD CLASS="l">973</TD><TD>                // need to allocate quantity for, so we save the last price information.</TD></TR><TR CLASS="z"><TD CLASS="l">974</TD><TD>                if (!currentPrice.isNoPrice()) {</TD></TR><TR CLASS="z"><TD CLASS="l">975</TD><TD>                    outputTradePrices.add(determineTradePrice(tradableSide, currentPrice, aProduct));</TD></TR><TR CLASS="z"><TD CLASS="l">976</TD><TD>                    outputTradeQuantityList.add(new Integer(allocatedAtCurrentPrice));</TD></TR><TR CLASS="z"><TD CLASS="l">977</TD><TD>                    outputParticipantsLists.add(currentOpposite);</TD></TR><TR><TD CLASS="l">978</TD><TD>                }</TD></TR><TR><TD CLASS="l">979</TD><TD>                // get ready to allocate quantity at a new price.</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>                currentOpposite = new ParticipantListImpl();</TD></TR><TR CLASS="z"><TD CLASS="l">981</TD><TD>                currentPrice = nextSet.getPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>                allocatedAtCurrentPrice = 0;</TD></TR><TR><TD CLASS="l">983</TD><TD>            }</TD></TR><TR><TD CLASS="l">984</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">985</TD><TD>            int nextAllocatedQuantity = nextSet.allocate(currentOpposite, quantityToAllocate - allocatedQuantity);</TD></TR><TR CLASS="z"><TD CLASS="l">986</TD><TD>            allocatedQuantity += nextAllocatedQuantity;</TD></TR><TR CLASS="z"><TD CLASS="l">987</TD><TD>            allocatedAtCurrentPrice += nextAllocatedQuantity;</TD></TR><TR><TD CLASS="l">988</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>        if (allocatedQuantity &gt; 0) {</TD></TR><TR><TD CLASS="l">990</TD><TD>            // If we were able to find opposite side quantity, we now need to create corresponding</TD></TR><TR><TD CLASS="l">991</TD><TD>            // participant lists for the same side tradables (the new one and any we are trading ahead)</TD></TR><TR CLASS="z"><TD CLASS="l">992</TD><TD>            outputTradePrices.add(determineTradePrice(tradableSide, currentPrice, aProduct));</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>            outputTradeQuantityList.add(new Integer(allocatedAtCurrentPrice));</TD></TR><TR CLASS="z"><TD CLASS="l">994</TD><TD>            outputParticipantsLists.add(currentOpposite);</TD></TR><TR><TD CLASS="l">995</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">996</TD><TD>        return allocatedQuantity;</TD></TR><TR><TD CLASS="l">997</TD><TD>    }</TD></TR><TR><TD CLASS="l">998</TD><TD> </TD></TR><TR><TD CLASS="l">999</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1000</TD><TD>      * Set the trade context for each participant in the given list</TD></TR><TR><TD CLASS="l">1001</TD><TD>      *</TD></TR><TR><TD CLASS="l">1002</TD><TD>      */</TD></TR><TR><TD CLASS="l"><A NAME="17">1003</A></TD><TD>    protected static void prepareParticipantsForTrade(ArrayList participantList, short tradeContext)</TD></TR><TR><TD CLASS="l">1004</TD><TD>    {</TD></TR><TR><TD CLASS="l">1005</TD><TD>        ParticipantList pList;</TD></TR><TR><TD CLASS="l">1006</TD><TD>        ParticipantItem  participantItem;</TD></TR><TR CLASS="z"><TD CLASS="l">1007</TD><TD>        for (int i = 0; i &lt; participantList.size(); i++)</TD></TR><TR><TD CLASS="l">1008</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>            pList = (ParticipantList) participantList.get(i);</TD></TR><TR><TD CLASS="l">1010</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>            Enumeration items = pList.elements();</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>            while(items.hasMoreElements())</TD></TR><TR><TD CLASS="l">1013</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>                participantItem = (ParticipantItem) items.nextElement();</TD></TR><TR><TD CLASS="l">1015</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1016</TD><TD>                participantItem.setTradeContext(tradeContext);</TD></TR><TR><TD CLASS="l">1017</TD><TD>            }</TD></TR><TR><TD CLASS="l">1018</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8">1019</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1020</TD><TD>    </TD></TR><TR><TD CLASS="l">1021</TD><TD>        public static boolean createFlexAuctionTrade(OrderBook orderBook, Price tradePrice, int tradeQty, Tradable incomingTradable)</TD></TR><TR><TD CLASS="l">1022</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>                boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                boolean traded = false;</TD></TR><TR><TD CLASS="l">1025</TD><TD>                try</TD></TR><TR><TD CLASS="l">1026</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>                    if(tradeQty == 0)</TD></TR><TR><TD CLASS="l">1028</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1029</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">1030</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1031</TD><TD>                        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1032</TD><TD>                        traded = BusinessServicesHelper.getTradeService(orderBook.getTradingProduct()).createFlexAuctionTrade(orderBook, incomingTradable, tradePrice, tradeQty);</TD></TR><TR CLASS="z"><TD CLASS="l">1033</TD><TD>                        if(!traded)</TD></TR><TR><TD CLASS="l">1034</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1035</TD><TD>                                Transaction.rollback();</TD></TR><TR><TD CLASS="l">1036</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>                        success = Transaction.commit();</TD></TR><TR><TD CLASS="l">1038</TD><TD>                } </TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>                catch (SpreadProcessingException e) </TD></TR><TR><TD CLASS="l">1040</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>                        Log.exception(&#34;AuctionProcessorFlexImpl &gt;&gt;&gt;&gt;&gt;&gt; SpreadProcessingException while processing flex trade&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">1042</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1043</TD><TD>                } </TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>                catch (DataValidationException e) </TD></TR><TR><TD CLASS="l">1045</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1046</TD><TD>                        Log.exception(&#34;AuctionProcessorFlexImpl &gt;&gt;&gt;&gt;&gt;&gt; DataValidationException while processing flex trade&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">1047</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1048</TD><TD>                } </TD></TR><TR CLASS="z"><TD CLASS="l">1049</TD><TD>                catch (SystemException e) </TD></TR><TR><TD CLASS="l">1050</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1051</TD><TD>                        Log.exception(&#34;AuctionProcessorFlexImpl &gt;&gt;&gt;&gt;&gt;&gt; SystemException while processing flex trade&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1053</TD><TD>                }</TD></TR><TR><TD CLASS="l">1054</TD><TD>                finally</TD></TR><TR CLASS="z"><TD CLASS="l">1055</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1056</TD><TD>                        if(!success)</TD></TR><TR><TD CLASS="l">1057</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>                                Transaction.rollback();</TD></TR><TR><TD CLASS="l">1059</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1060</TD><TD>                }</TD></TR><TR><TD CLASS="l">1061</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>                return traded;</TD></TR><TR><TD CLASS="l"><A NAME="20">1063</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1064</TD><TD>        </TD></TR><TR><TD CLASS="l">1065</TD><TD>        public static boolean isMarketCrossedOrLocked(OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1066</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1067</TD><TD>                boolean result = false;</TD></TR><TR><TD CLASS="l">1068</TD><TD>                </TD></TR><TR CLASS="c"><TD CLASS="l">1069</TD><TD>                if(orderBook.getTradingProduct().isStrategy() || orderBook.getTradingProduct().isBuyWrite())</TD></TR><TR><TD CLASS="l">1070</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>                        Price bestDefinedSidePrice = orderBook.getBestLimitPrice(definedSide);</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>                        Price bestOppositeSidePrice = orderBook.getBestLimitPrice(oppositeSide);</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>                        if(definedSide.areTwoPricesTradable(bestDefinedSidePrice, bestOppositeSidePrice))</TD></TR><TR><TD CLASS="l">1074</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1075</TD><TD>                                result = true;</TD></TR><TR><TD CLASS="l">1076</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1077</TD><TD>                }</TD></TR><TR><TD CLASS="l">1078</TD><TD>                else</TD></TR><TR><TD CLASS="l">1079</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">1080</TD><TD>                        Price bestBuySidePrice = orderBook.getBestLimitPrice(buySide);</TD></TR><TR CLASS="c"><TD CLASS="l">1081</TD><TD>                        Price bestSellSidePrice = orderBook.getBestLimitPrice(sellSide);</TD></TR><TR CLASS="c"><TD CLASS="l">1082</TD><TD>                        if(buySide.areTwoPricesTradable(bestBuySidePrice, bestSellSidePrice))</TD></TR><TR><TD CLASS="l">1083</TD><TD>                        {</TD></TR><TR CLASS="c"><TD CLASS="l">1084</TD><TD>                                result = true;</TD></TR><TR><TD CLASS="l">1085</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1086</TD><TD>                }</TD></TR><TR><TD CLASS="l">1087</TD><TD>                </TD></TR><TR CLASS="c"><TD CLASS="l">1088</TD><TD>                return result;</TD></TR><TR><TD CLASS="l">1089</TD><TD>        }</TD></TR><TR><TD CLASS="l">1090</TD><TD>    </TD></TR><TR><TD CLASS="l">1091</TD><TD>    public static int createFlexInternalizedAutionTrade(OrderBook book, AuctionInternal auction,</TD></TR><TR><TD CLASS="l"><A NAME="1f">1092</A></TD><TD>            Tradable incomingTradable, Price tradePrice) throws SpreadProcessingException,</TD></TR><TR><TD CLASS="l">1093</TD><TD>            DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1094</TD><TD>    {</TD></TR><TR><TD CLASS="l">1095</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1096</TD><TD>        if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1097</TD><TD>            Log.debug(&#34;AuctionTradeServiceHelper&gt;&gt;&gt;createFlexSpreadAuctionTrade. Auction/tradePrice=&#34; + auction + &#34;/&#34; + tradePrice);</TD></TR><TR><TD CLASS="l">1098</TD><TD>        }</TD></TR><TR><TD CLASS="l">1099</TD><TD>        </TD></TR><TR CLASS="c"><TD CLASS="l">1100</TD><TD>        int allocatedQty = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1101</TD><TD>        TradeService tradeService = BusinessServicesHelper.getTradeService(book.getTradingProduct());</TD></TR><TR><TD CLASS="l">1102</TD><TD>        // needs to widen the price of the incoming tradable to the better price</TD></TR><TR><TD CLASS="l">1103</TD><TD>        // of the best book Price or 1 tick better than best Customer price on the same side as the auction</TD></TR><TR CLASS="c"><TD CLASS="l">1104</TD><TD>        Price bestBookPrice = book.getBestPrice( auction.getSide());</TD></TR><TR><TD CLASS="l">1105</TD><TD> </TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="76% line coverage (13 out of 17 instructions)">1106</TD><TD TITLE="76% line coverage (13 out of 17 instructions)">        if (incomingTradable != null &amp;&amp; incomingTradable.getContingencyType() == ContingencyTypes.AUCTION_RESPONSE)</TD></TR><TR><TD CLASS="l">1107</TD><TD>        {</TD></TR><TR><TD CLASS="l">1108</TD><TD>            //if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1109</TD><TD>            //{</TD></TR><TR CLASS="z"><TD CLASS="l">1110</TD><TD>                String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">1111</TD><TD>                Log.information(msg);</TD></TR><TR><TD CLASS="l">1112</TD><TD>            //}</TD></TR><TR CLASS="z"><TD CLASS="l">1113</TD><TD>            if ( incomingTradable.getSide().areTwoPricesTradable(incomingTradable.getPrice(), bestBookPrice) )</TD></TR><TR><TD CLASS="l">1114</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1115</TD><TD>                int remainingOppositeQty = getRemainingQuantity (book.getTradingProduct().getTradingClass(),</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                                            auction, incomingTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>                Price bookTradePrice = getBestBookPriceOrOneTickBetter(auction.getSide(), book, AuctionTypes.AUCTION_INTERNALIZATION, remainingOppositeQty);</TD></TR><TR CLASS="z"><TD CLASS="l">1118</TD><TD>                if  (incomingTradable.getSide().isFirstBetter(incomingTradable.getPrice(), PriceFactory.flipSignOnPrice(bookTradePrice)))</TD></TR><TR><TD CLASS="l">1119</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>                    incomingTradable.setWidenPrice(PriceFactory.flipSignOnPrice(bookTradePrice));</TD></TR><TR><TD CLASS="l">1121</TD><TD>                }</TD></TR><TR><TD CLASS="l">1122</TD><TD>                //if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1123</TD><TD>                //{</TD></TR><TR CLASS="z"><TD CLASS="l">1124</TD><TD>                    Log.information( &#34;The opposite incoming auction response ends auction, will trade at the best book price (/ 1 tick better) =&#34; + incomingTradable.getPrice());</TD></TR><TR><TD CLASS="l">1125</TD><TD>                //}</TD></TR><TR><TD CLASS="l">1126</TD><TD>            }</TD></TR><TR><TD CLASS="l">1127</TD><TD>            else</TD></TR><TR><TD CLASS="l">1128</TD><TD>            {   // the opposite incoming tradable price doesn't cross the regular book for some reason</TD></TR><TR CLASS="z"><TD CLASS="l">1129</TD><TD>                Log.alarm( &#34;The current auction should n't be terminated by this opposite incoming response, its price is not marketable against the book, though we have to continue to allocate the auction trade&#34; );</TD></TR><TR><TD CLASS="l">1130</TD><TD>                //String msg = getAuctionInfoForOppositeSideIncomingTradable(incomingTradable, auction, bestBookPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">1131</TD><TD>                Log.alarm( msg);</TD></TR><TR><TD CLASS="l">1132</TD><TD>            }</TD></TR><TR><TD CLASS="l">1133</TD><TD>            try</TD></TR><TR><TD CLASS="l">1134</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1135</TD><TD>                auction.getAuctionBook().bookTradable(incomingTradable); // book it into the auctionbook</TD></TR><TR><TD CLASS="l">1136</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>            catch (AlreadyExistsException e)</TD></TR><TR><TD CLASS="l">1138</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>                Log.exception(e.toString(), e);</TD></TR><TR><TD CLASS="l">1140</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1141</TD><TD>            catch (NotAcceptedException ex)</TD></TR><TR><TD CLASS="l">1142</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>                Log.exception(ex.toString(), ex);</TD></TR><TR><TD CLASS="l">1144</TD><TD>            }</TD></TR><TR><TD CLASS="l">1145</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">1146</TD><TD>            allocatedQty =  tradeService.createFlexInternalizationAuctionTrade(auction, incomingTradable, tradePrice);</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>            Log.information(&#34;AuctionTradeHelper &gt;&gt;&gt;&gt; allocatedQty&#34;  + allocatedQty);</TD></TR><TR CLASS="z"><TD CLASS="l">1148</TD><TD>            if (incomingTradable.isWidened())</TD></TR><TR><TD CLASS="l">1149</TD><TD>            {</TD></TR><TR><TD CLASS="l">1150</TD><TD>                try</TD></TR><TR><TD CLASS="l">1151</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1152</TD><TD>                    auction.getAuctionBook().cancelTradable(incomingTradable, incomingTradable.getQuantityAllowed());</TD></TR><TR CLASS="z"><TD CLASS="l">1153</TD><TD>                    incomingTradable.setWidenPrice( null);</TD></TR><TR CLASS="z"><TD CLASS="l">1154</TD><TD>                    auction.getAuctionBook().bookTradable(incomingTradable);</TD></TR><TR><TD CLASS="l">1155</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1156</TD><TD>                catch (AuctionBookTradableNotFoundException nfe)</TD></TR><TR><TD CLASS="l">1157</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>                    Log.exception(&#34;Couldn't trade the remainder of the incoming response with the book, since it couldnot cancel the widened the auction response from the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">1159</TD><TD>                            + StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34; &#34; + &#34;, current price = &#34; + incomingTradable.getPrice() + nfe, nfe);</TD></TR><TR CLASS="z"><TD CLASS="l">1160</TD><TD>                    return allocatedQty;</TD></TR><TR><TD CLASS="l">1161</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1162</TD><TD>                catch (AlreadyExistsException aee)</TD></TR><TR><TD CLASS="l">1163</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>                    Log.exception(&#34;Couldn't re-book the narrowed the auction response into the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">1165</TD><TD>                            +  StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34; &#34; + aee , aee);</TD></TR><TR><TD CLASS="l">1166</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                catch (NotAcceptedException nae)</TD></TR><TR><TD CLASS="l">1168</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1169</TD><TD>                    Log.exception(&#34;Couldn't re-book the narrowed the auction response into the auctionBook &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">1170</TD><TD>                            +  StructToString.toString(((Order)incomingTradable).getOrderId()) + &#34;, current price = &#34; + incomingTradable.getPrice() + nae , nae);</TD></TR><TR CLASS="z"><TD CLASS="l">1171</TD><TD>                    return allocatedQty;</TD></TR><TR><TD CLASS="l">1172</TD><TD>                }</TD></TR><TR><TD CLASS="l">1173</TD><TD>            }</TD></TR><TR><TD CLASS="l">1174</TD><TD>    </TD></TR><TR CLASS="z"><TD CLASS="l">1175</TD><TD>            int allocatedQty2 = AuctionTradeHelper.tradeWithRemainderOfIncomingAuctionResponse(tradeService,incomingTradable, book, auction);</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>            Log.information(&#34;AuctionTradeHelper &gt;&gt;&gt;&gt; allocatedQty2&#34;  + allocatedQty2);</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>            allocatedQty = allocatedQty + allocatedQty2;</TD></TR><TR><TD CLASS="l">1178</TD><TD>        }</TD></TR><TR><TD CLASS="l">1179</TD><TD>        else</TD></TR><TR><TD CLASS="l">1180</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>            allocatedQty = tradeService.createFlexInternalizationAuctionTrade(auction, incomingTradable, tradePrice);</TD></TR><TR><TD CLASS="l">1182</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1183</TD><TD>        Log.information(&#34;AuctionTradeHelper &gt;&gt;&gt;&gt; total allocatedQty&#34;  + allocatedQty);</TD></TR><TR CLASS="z"><TD CLASS="l">1184</TD><TD>        return allocatedQty;    </TD></TR><TR><TD CLASS="l">1185</TD><TD>    }</TD></TR><TR><TD CLASS="l">1186</TD><TD>        </TD></TR><TR><TD CLASS="l">1187</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../Coverage.html">all classes</A>][<A HREF="69.html">com.cboe.businessServices.tradeService</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 2</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>