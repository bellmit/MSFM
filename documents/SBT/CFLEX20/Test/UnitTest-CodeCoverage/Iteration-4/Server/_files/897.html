<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Mon Aug 01 06:28:17 CDT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../Coverage.html">all classes</A>][<A HREF="71.html">com.cboe.businessServices.brokerService</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">BrokerProcessorSpreadHybridImpl.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>BrokerProcessorSpreadHybridImpl.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/4603)</TD><TD CLASS="h">0%   (0/1087)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">BrokerProcessorSpreadHybridImpl</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/4603)</TD><TD CLASS="h">0%   (0/1087)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">BrokerProcessorSpreadHybridImpl (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#3">canDoTrade (Tradable, OrderBook, Price, Price): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">canProcessMktPricedTradableWithLegs (Tradable, StrategyLegTradeContainer, Tra...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#5">cancelIOCOrder (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">cancelIOrderForBoB (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#7">cleanupLegTimerBasedHoldups (TradingProduct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">convertPmmStructToMap (HashMap, PMMDetailsStruct []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#9">createPMMCapDetailsForAuctionResponses (HashMap): HashMap</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/103)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">determineLimitOrderReturnCode (Order, HandlingInstruction): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/92)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR><TD CLASS="f"><A HREF="#b">determineMarketOrderReturnCode (Order, HandlingInstruction): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/81)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">determinePARTAOrderReturnCode (Order, HandlingInstruction): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#d">determinePAuctionReturnCode (Order, HandlingInstruction): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">doHALTriggerExpiredPostProcessing (AuctionInternal, OrderBook, Tradable, HALS...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#f">doNormalOrderProcessing (Order, OrderBook, Price): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">doSpreadOrderLegTrades (Order, DerivedQuote, TradingProduct, AuctionInternal)...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/57)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#11">expireAllLegTimerBasedHoldupForAIMComplexOrder (TradingProduct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/61)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">expireAllTimerBasedHoldUps (TradingProduct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/61)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#13">findAndReturnBookedOrdersForIndexHybrid (OrderBook, StrategyLegTradeContainer...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/131)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">flipSignOnPrice (Price): Price</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#15">forceExpireQuoteTrigger (Side, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getAuctionProcessor (int): AuctionProcessor</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">getHybridProcessor (Integer): BrokerProcessorHybridImpl</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">getHybridProcessor (TradingProduct): BrokerProcessorHybridImpl</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#19">getHybridProcessor (int): BrokerProcessorHybridImpl</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">getOrderRoutingDestinationService (): OrderRoutingDestination</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">getReCOAManagerHome (): ReCOAManagerHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">getReturnCodeForOrder (Order): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/75)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">getSpreadAuctionProcessor (int): AuctionProcessorSpreadHybridImpl</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/38)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">getTradingProductForHybridProcessor (TradingProduct): TradingProduct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">getUserMaintenanceService (): UserMaintenanceService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">getUsersForAffiliatedFirm (String): UserFirmAffiliationStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#21">handleFailedReturning (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">handleHALTrigger (QuoteTriggerTradable, Tradable, OrderBook, Price): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#23">handleNormalStrategyOrder (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">handleOrderForSpreadProtection (Integer, Side, OrderBook, Tradable): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/94)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#25">handleQuoteLikeOrderForReCOA (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">handleReturningOrder (Order, OrderBook, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#27">isOrderSizeBetweenAuctionMinMax (Order): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/49)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">isPreferred (List, Tradable): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#29">isPreferred (String [], Tradable): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">isRolledoutSpreadClass (TradingProduct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">isTSBRequest (Order): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">isThisAcrPreferred (String, String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">performPostAuctionProcessing (AuctionInternal): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">populatePMMCapDetailsForTradingProduct (OrderBook, Side, Price, HashMap, List...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">postProcess (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/73)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">postProcessAuctionedOrder (AuctionInternal, Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/127)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR><TD CLASS="f"><A HREF="#31">preAuctionCleanup (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">processAuctionExpire (Auction, short, Tradable): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#33">processCancel (Order, int, String, boolean): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">processCancelReplace (Order, int, Order, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#35">processIOCCancel (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/46)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">processInternalizationOrders (InternalizationPair): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/126)</TD><TD CLASS="h">0%   (0/28)</TD></TR><TR><TD CLASS="f"><A HREF="#37">processLegBestBookChange (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">processLegBestBookChange (int, Boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/120)</TD><TD CLASS="h">0%   (0/27)</TD></TR><TR><TD CLASS="f"><A HREF="#39">processLegBestBookChange (int, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/143)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">processOrder (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/118)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">processOrderWithActiveAuction (Order, AuctionInternal, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">processOrderWithoutActiveAuction (List, OrderBook): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/233)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">processOrderWithoutActiveAuction (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/71)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">processPendingCancelRequest (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/100)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">processQuoteSide (OrderBook, QuoteSide): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">processReCOA (Integer, TradingClass, Side): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/208)</TD><TD CLASS="h">0%   (0/50)</TD></TR><TR><TD CLASS="f"><A HREF="#41">processReCOAOrders (List, OrderBook): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/145)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">processSpreadOrderForLegTrade (Order, AuctionInternal): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/300)</TD><TD CLASS="h">0%   (0/94)</TD></TR><TR><TD CLASS="f"><A HREF="#43">processSpreadOrderForLegTrade_old (Order, AuctionInternal): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/141)</TD><TD CLASS="h">0%   (0/40)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">processTSBRequest (OrderHandlingStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#45">processUnauctionedFirmMatchOrder (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">processUnauctionedInternalizedOrder (Order, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#47">processedWithActiveHALTrigger (Tradable, OrderBook, Price): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">requestedToAuction (Order): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#49">returnCancelReplaceRequest (Order, int, Order, String, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">returnCancelRequest (Order, int, String, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">returnOrderWithBookDepth (Order, BookDepthStruct, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">setAllocationContext (AuctionInternal, Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/263)</TD><TD CLASS="h">0%   (0/58)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">setAuctionState (int, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">setBroker (Broker): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">setCOAStartedTime (Order): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">setPMMDetails (int, char, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/142)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR><TD CLASS="f"><A HREF="#51">shouldExpireDueToDerivedQuoteMove (AuctionInternal): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">shouldExpireDueToIncomingTradable (AuctionInternal, Tradable): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#53">shouldJoin (AuctionInternal, Tradable): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">unbookReCOAOrder (Order, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#55">unbookReCOAOrders (List, OrderBook): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/6)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>package com.cboe.businessServices.brokerService;</TD></TR><TR><TD CLASS="l">2</TD><TD> </TD></TR><TR><TD CLASS="l">3</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">4</TD><TD>import java.util.Enumeration;</TD></TR><TR><TD CLASS="l">5</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">6</TD><TD>import java.util.LinkedList;</TD></TR><TR><TD CLASS="l">7</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>import com.cboe.businessServices.orderBookService.OrderBookImpl;</TD></TR><TR><TD CLASS="l">10</TD><TD>import com.cboe.businessServices.orderRoutingDestination.OrderImpl;</TD></TR><TR><TD CLASS="l">11</TD><TD>import com.cboe.businessServices.recoaService.ReCOAManagerHomeImpl;</TD></TR><TR><TD CLASS="l">12</TD><TD>import com.cboe.businessServices.tradeService.StrategyTradeServiceHelper;</TD></TR><TR><TD CLASS="l">13</TD><TD>import com.cboe.domain.order.OrderHandlingInstructionNoReflectionImpl;</TD></TR><TR><TD CLASS="l">14</TD><TD>import com.cboe.domain.util.AuctionTerminateReasons;</TD></TR><TR><TD CLASS="l">15</TD><TD>import com.cboe.domain.util.ExtensionsFieldParser;</TD></TR><TR><TD CLASS="l">16</TD><TD>import com.cboe.domain.util.InternalOrderStates;</TD></TR><TR><TD CLASS="l">17</TD><TD>import com.cboe.domain.util.NoPrice;</TD></TR><TR><TD CLASS="l">18</TD><TD>import com.cboe.domain.util.PDPMExtensionsCompatibleHelper;</TD></TR><TR><TD CLASS="l">19</TD><TD>import com.cboe.domain.util.PriceFactory;</TD></TR><TR><TD CLASS="l">20</TD><TD>import com.cboe.domain.util.ReflectiveStructBuilder;</TD></TR><TR><TD CLASS="l">21</TD><TD>import com.cboe.domain.util.StrategyLegTradeContainer;</TD></TR><TR><TD CLASS="l">22</TD><TD>import com.cboe.exceptions.AuthorizationException;</TD></TR><TR><TD CLASS="l">23</TD><TD>import com.cboe.exceptions.CommunicationException;</TD></TR><TR><TD CLASS="l">24</TD><TD>import com.cboe.exceptions.DataValidationException;</TD></TR><TR><TD CLASS="l">25</TD><TD>import com.cboe.exceptions.NotAcceptedException;</TD></TR><TR><TD CLASS="l">26</TD><TD>import com.cboe.exceptions.NotFoundException;</TD></TR><TR><TD CLASS="l">27</TD><TD>import com.cboe.exceptions.OrderBookTradableNotFoundException;</TD></TR><TR><TD CLASS="l">28</TD><TD>import com.cboe.exceptions.SpreadProcessingException;</TD></TR><TR><TD CLASS="l">29</TD><TD>import com.cboe.exceptions.SystemException;</TD></TR><TR><TD CLASS="l">30</TD><TD>import com.cboe.exceptions.TransactionFailedException;</TD></TR><TR><TD CLASS="l">31</TD><TD>import com.cboe.idl.cmiConstants.ActivityReasons;</TD></TR><TR><TD CLASS="l">32</TD><TD>import com.cboe.idl.cmiConstants.AuctionTypes;</TD></TR><TR><TD CLASS="l">33</TD><TD>import com.cboe.idl.cmiConstants.ContingencyTypes;</TD></TR><TR><TD CLASS="l">34</TD><TD>import com.cboe.idl.cmiConstants.OrderStates;</TD></TR><TR><TD CLASS="l">35</TD><TD>import com.cboe.idl.cmiConstants.ProductStates;</TD></TR><TR><TD CLASS="l">36</TD><TD>import com.cboe.idl.cmiConstants.ProductTypes;</TD></TR><TR><TD CLASS="l">37</TD><TD>import com.cboe.idl.cmiConstants.Sides;</TD></TR><TR><TD CLASS="l">38</TD><TD>import com.cboe.idl.cmiErrorCodes.DataValidationCodes;</TD></TR><TR><TD CLASS="l">39</TD><TD>import com.cboe.idl.cmiErrorCodes.NotAcceptedCodes;</TD></TR><TR><TD CLASS="l">40</TD><TD>import com.cboe.idl.cmiMarketData.BookDepthStruct;</TD></TR><TR><TD CLASS="l">41</TD><TD>import com.cboe.idl.constants.OrderRoutingReasons;</TD></TR><TR><TD CLASS="l">42</TD><TD>import com.cboe.idl.constants.TradableTypes;</TD></TR><TR><TD CLASS="l">43</TD><TD>import com.cboe.idl.constants.TradingRestrictions;</TD></TR><TR><TD CLASS="l">44</TD><TD>import com.cboe.idl.order.OrderBookSummaryStruct;</TD></TR><TR><TD CLASS="l">45</TD><TD>import com.cboe.idl.order.OrderHandlingStruct;</TD></TR><TR><TD CLASS="l">46</TD><TD>import com.cboe.idl.order.OrderRoutingParameterStruct;</TD></TR><TR><TD CLASS="l">47</TD><TD>import com.cboe.idl.order.PMMDetailsStruct;</TD></TR><TR><TD CLASS="l">48</TD><TD>import com.cboe.idl.user.UserFirmAffiliationStruct;</TD></TR><TR><TD CLASS="l">49</TD><TD>import com.cboe.infrastructureServices.foundationFramework.HomeFactory;</TD></TR><TR><TD CLASS="l">50</TD><TD>import com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException;</TD></TR><TR><TD CLASS="l">51</TD><TD>import com.cboe.infrastructureServices.foundationFramework.exceptionHandling.FatalFoundationFrameworkException;</TD></TR><TR><TD CLASS="l">52</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Log;</TD></TR><TR><TD CLASS="l">53</TD><TD>import com.cboe.interfaces.businessServices.AuctionProcessor;</TD></TR><TR><TD CLASS="l">54</TD><TD>import com.cboe.interfaces.businessServices.OrderRoutingDestination;</TD></TR><TR><TD CLASS="l">55</TD><TD>import com.cboe.interfaces.businessServices.OrderRoutingDestinationHome;</TD></TR><TR><TD CLASS="l">56</TD><TD>import com.cboe.interfaces.businessServices.ReCOAManagerHome;</TD></TR><TR><TD CLASS="l">57</TD><TD>import com.cboe.interfaces.domain.Auction;</TD></TR><TR><TD CLASS="l">58</TD><TD>import com.cboe.interfaces.domain.AuctionInternal;</TD></TR><TR><TD CLASS="l">59</TD><TD>import com.cboe.interfaces.domain.BestBook;</TD></TR><TR><TD CLASS="l">60</TD><TD>import com.cboe.interfaces.domain.Broker;</TD></TR><TR><TD CLASS="l">61</TD><TD>import com.cboe.interfaces.domain.DerivedQuote;</TD></TR><TR><TD CLASS="l">62</TD><TD>import com.cboe.interfaces.domain.HALStruct;</TD></TR><TR><TD CLASS="l">63</TD><TD>import com.cboe.interfaces.domain.HandlingInstruction;</TD></TR><TR><TD CLASS="l">64</TD><TD>import com.cboe.interfaces.domain.InternalizationPair;</TD></TR><TR><TD CLASS="l">65</TD><TD>import com.cboe.interfaces.domain.Order;</TD></TR><TR><TD CLASS="l">66</TD><TD>import com.cboe.interfaces.domain.OrderBook;</TD></TR><TR><TD CLASS="l">67</TD><TD>import com.cboe.interfaces.domain.Price;</TD></TR><TR><TD CLASS="l">68</TD><TD>import com.cboe.interfaces.domain.Quote;</TD></TR><TR><TD CLASS="l">69</TD><TD>import com.cboe.interfaces.domain.QuoteSide;</TD></TR><TR><TD CLASS="l">70</TD><TD>import com.cboe.interfaces.domain.QuoteTriggerTradable;</TD></TR><TR><TD CLASS="l">71</TD><TD>import com.cboe.interfaces.domain.Side;</TD></TR><TR><TD CLASS="l">72</TD><TD>import com.cboe.interfaces.domain.Tradable;</TD></TR><TR><TD CLASS="l">73</TD><TD>import com.cboe.interfaces.domain.TradableList;</TD></TR><TR><TD CLASS="l">74</TD><TD>import com.cboe.interfaces.domain.TradingClass;</TD></TR><TR><TD CLASS="l">75</TD><TD>import com.cboe.interfaces.domain.TradingProduct;</TD></TR><TR><TD CLASS="l">76</TD><TD>import com.cboe.interfaces.domain.TradingProductHome;</TD></TR><TR><TD CLASS="l">77</TD><TD>import com.cboe.interfaces.domain.TradingStrategyLeg;</TD></TR><TR><TD CLASS="l">78</TD><TD>import com.cboe.interfaces.domain.tradingProperty.AuctionMinMaxOrderSize;</TD></TR><TR><TD CLASS="l">79</TD><TD>import com.cboe.interfaces.internalBusinessServices.UserMaintenanceService;</TD></TR><TR><TD CLASS="l">80</TD><TD>import com.cboe.interfaces.internalBusinessServices.UserMaintenanceServiceHome;</TD></TR><TR><TD CLASS="l">81</TD><TD>import com.cboe.interfaces.productData.ProductDataCacheHome;</TD></TR><TR><TD CLASS="l">82</TD><TD>import com.cboe.internalBusinessServices.productStateService.TradingProductImpl;</TD></TR><TR><TD CLASS="l">83</TD><TD>import com.cboe.server.util.StrategyHelper;</TD></TR><TR><TD CLASS="l">84</TD><TD>import com.cboe.server.util.StructToString;</TD></TR><TR><TD CLASS="l">85</TD><TD>import com.cboe.util.ExceptionBuilder;</TD></TR><TR><TD CLASS="l">86</TD><TD> </TD></TR><TR><TD CLASS="l">87</TD><TD>/**</TD></TR><TR><TD CLASS="l">88</TD><TD> * This class is designed to process hybrid spread order. Hybrid spread order will be processed</TD></TR><TR><TD CLASS="l">89</TD><TD> * by following rules</TD></TR><TR><TD CLASS="l">90</TD><TD> *</TD></TR><TR><TD CLASS="l">91</TD><TD> * 1. for trading, it should be the same as regular spread order, which will be handled by</TD></TR><TR><TD CLASS="l">92</TD><TD> *    inherited methods from BrokerProcessorSpreadImpl</TD></TR><TR><TD CLASS="l">93</TD><TD> * 2. for cancel, and cancel/replace will be same as simple hybrid order, which will be</TD></TR><TR><TD CLASS="l">94</TD><TD> *    delegated to BrokerProcessHybridImpl</TD></TR><TR><TD CLASS="l">95</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="0">96</A></TD><TD> */</TD></TR><TR><TD CLASS="l">97</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">98</TD><TD>public class BrokerProcessorSpreadHybridImpl extends BrokerProcessorSpreadImpl implements BrokerProcessorSpreadHybridInterface {</TD></TR><TR><TD CLASS="l">99</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">100</TD><TD>    private static Price NO_PRICE = new NoPrice();</TD></TR><TR><TD CLASS="l">101</TD><TD>    private BrokerProcessorHybridImpl hybridProcessor;</TD></TR><TR><TD CLASS="l">102</TD><TD>    AuctionProcessorFactory auctionProcessorFactory;</TD></TR><TR><TD CLASS="l">103</TD><TD>    private static UserMaintenanceService userMaintenanceService;</TD></TR><TR><TD CLASS="l">104</TD><TD>    /**</TD></TR><TR><TD CLASS="l">105</TD><TD>     * Reference to ReCOAManagerHomeImpl</TD></TR><TR><TD CLASS="l">106</TD><TD>     * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">107</TD><TD>     */</TD></TR><TR><TD CLASS="l">108</TD><TD>    private ReCOAManagerHome reCOAManagerHome;</TD></TR><TR><TD CLASS="l">109</TD><TD>    </TD></TR><TR><TD CLASS="l">110</TD><TD>    private TradingProductHome cachedTradingProductHome;</TD></TR><TR><TD CLASS="l">111</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="2">112</A></TD><TD>    private ProductDataCacheHome productDataCacheHome;</TD></TR><TR><TD CLASS="l">113</TD><TD>    </TD></TR><TR><TD CLASS="l">114</TD><TD>    private OrderRoutingDestination orderRoutingDestinationService;</TD></TR><TR><TD CLASS="l">115</TD><TD>    </TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>    public BrokerProcessorSpreadHybridImpl() {</TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>        auctionProcessorFactory = new AuctionProcessorFactory();</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>    }</TD></TR><TR><TD CLASS="l">119</TD><TD> </TD></TR><TR><TD CLASS="l">120</TD><TD>    /** =======================================================================</TD></TR><TR><TD CLASS="l">121</TD><TD>     *  The following methods are defined in super class, but overriden here</TD></TR><TR><TD CLASS="l"><A NAME="3a">122</A></TD><TD>     *  =======================================================================</TD></TR><TR><TD CLASS="l">123</TD><TD>     */</TD></TR><TR><TD CLASS="l">124</TD><TD>    public void processOrder(Order order) throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">125</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">127</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::processOrder&#34;);</TD></TR><TR><TD CLASS="l">129</TD><TD>        }</TD></TR><TR><TD CLASS="l">130</TD><TD> </TD></TR><TR><TD CLASS="l">131</TD><TD> </TD></TR><TR><TD CLASS="l">132</TD><TD> </TD></TR><TR><TD CLASS="l">133</TD><TD> </TD></TR><TR><TD CLASS="l">134</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">135</TD><TD>        if (order.isAuctionResponse()) {</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>            getSpreadAuctionProcessor(order.getProductKey()).handleAuctionResponse(order);</TD></TR><TR CLASS="z"><TD CLASS="l">137</TD><TD>            return;</TD></TR><TR><TD CLASS="l">138</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>        int prodKey = order.getProductKey().intValue();</TD></TR><TR CLASS="z"><TD CLASS="l">140</TD><TD>        OrderBook orderBook = getOrderBook(prodKey);</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>        if (orderBook.isEmpty() == true)//book is empty hence the productstate may not be up-to-date</TD></TR><TR><TD CLASS="l">142</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>            TradingProductImpl product = (TradingProductImpl)orderBook.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">144</TD><TD>            boolean allLegsValid = product.areAllLegsValid();</TD></TR><TR><TD CLASS="l">145</TD><TD>            </TD></TR><TR><TD CLASS="l">146</TD><TD>            // SEDL SYS7446:</TD></TR><TR CLASS="z"><TD CLASS="l">147</TD><TD>            if (!allLegsValid)</TD></TR><TR><TD CLASS="l">148</TD><TD>            {</TD></TR><TR><TD CLASS="l">149</TD><TD>                // update marketStatus for each leg.</TD></TR><TR CLASS="z"><TD CLASS="l">150</TD><TD>                TradingStrategyLeg [] legs = product.getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">151</TD><TD>                for (int i = 0; i &lt; legs.length; i++)</TD></TR><TR><TD CLASS="l">152</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                    TradingProduct legProduct = legs[i].getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>                    if (legProduct != null)</TD></TR><TR><TD CLASS="l">155</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                        legProduct.getOrderBook().evalMarketStatus();</TD></TR><TR><TD CLASS="l">157</TD><TD>                    }</TD></TR><TR><TD CLASS="l">158</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>                allLegsValid = product.areAllLegsValid();</TD></TR><TR><TD CLASS="l">160</TD><TD>            }</TD></TR><TR><TD CLASS="l">161</TD><TD>            // end SEDL ////////</TD></TR><TR><TD CLASS="l">162</TD><TD>            </TD></TR><TR><TD CLASS="l">163</TD><TD>                /* Directed AIM change START: This change for the specific case when an incoming DAIM Spread</TD></TR><TR><TD CLASS="l">164</TD><TD>                 * order changes the state of the spread product from ON_HOLD to OPEN. In this case, the daim participants</TD></TR><TR><TD CLASS="l">165</TD><TD>                 * should be penalized. But in the scenario where there is a resting DAIM spread order and a leg market</TD></TR><TR><TD CLASS="l">166</TD><TD>                 * change is triggering the state change from ON_HOLD to OPEN, there should be no penalization since the DAIM</TD></TR><TR><TD CLASS="l">167</TD><TD>                 * order has already booked. </TD></TR><TR><TD CLASS="l">168</TD><TD>                 */</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>                if(ExtensionsFieldParser.isOrderMarkedForDAIM(order.getExtensions()))</TD></TR><TR><TD CLASS="l">170</TD><TD>                {</TD></TR><TR><TD CLASS="l">171</TD><TD>                                // removing DAIM list if the order does not change product state from ON HOLD to END HOLD</TD></TR><TR CLASS="z"><TD CLASS="l">172</TD><TD>                    short productState = orderBook.getTradingProduct().getCurrentStateCode();</TD></TR><TR CLASS="z"><TD CLASS="l">173</TD><TD>                                if(allLegsValid &amp;&amp; productState == ProductStates.ON_HOLD)</TD></TR><TR><TD CLASS="l">174</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                                        order.setDirectedAIMOrderAndNotMatched(true);</TD></TR><TR><TD CLASS="l">176</TD><TD>                                }</TD></TR><TR><TD CLASS="l">177</TD><TD>                                else</TD></TR><TR><TD CLASS="l">178</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">179</TD><TD>                                        order.setDirectedAIMOrderAndNotMatched(false);</TD></TR><TR><TD CLASS="l">180</TD><TD>                                }</TD></TR><TR><TD CLASS="l">181</TD><TD>                }</TD></TR><TR><TD CLASS="l">182</TD><TD>                // Directed AIM change END.</TD></TR><TR CLASS="z"><TD CLASS="l">183</TD><TD>            processLegBestBookChange(prodKey,false);</TD></TR><TR><TD CLASS="l">184</TD><TD>        }</TD></TR><TR><TD CLASS="l">185</TD><TD>        else </TD></TR><TR><TD CLASS="l">186</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">187</TD><TD>            if(ExtensionsFieldParser.isOrderMarkedForDAIM(order.getExtensions()))</TD></TR><TR><TD CLASS="l">188</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                order.setDirectedAIMOrderAndNotMatched(false);</TD></TR><TR><TD CLASS="l">190</TD><TD>            }</TD></TR><TR><TD CLASS="l">191</TD><TD>        }</TD></TR><TR><TD CLASS="l">192</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">193</TD><TD>        if ( isTSBRequest(order)){</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>            handleReturningOrder(order, orderBook, OrderRoutingReasons.TSB_RETURNED);</TD></TR><TR><TD CLASS="l">195</TD><TD>        }</TD></TR><TR><TD CLASS="l">196</TD><TD>        else {</TD></TR><TR><TD CLASS="l">197</TD><TD>                    // If it is complex OPG order received at non Trading State, book it.</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                if(order.getContingencyType() == ContingencyTypes.OPG)</TD></TR><TR><TD CLASS="l">199</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                    processOrderWithoutRefreshBook(order, orderBook);</TD></TR><TR><TD CLASS="l">201</TD><TD>            }</TD></TR><TR><TD CLASS="l">202</TD><TD>                else</TD></TR><TR><TD CLASS="l">203</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                        handleNormalStrategyOrder(order, orderBook);</TD></TR><TR><TD CLASS="l">205</TD><TD>                }</TD></TR><TR><TD CLASS="l">206</TD><TD> </TD></TR><TR><TD CLASS="l">207</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>        processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">209</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="44">210</A></TD><TD>    </TD></TR><TR><TD CLASS="l">211</TD><TD>    public void processTSBRequest(OrderHandlingStruct p_orderStruct)</TD></TR><TR><TD CLASS="l">212</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">213</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">215</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::processTSBRequest&#34;);</TD></TR><TR><TD CLASS="l">217</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>        int prodKey = p_orderStruct.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>        OrderBook orderBook = getOrderBook(prodKey);</TD></TR><TR><TD CLASS="l">220</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>        short currentProdState = orderBook.getTradingProduct().getCurrentStateCode();</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>        if(currentProdState == ProductStates.OPEN)</TD></TR><TR><TD CLASS="l">223</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>            return;</TD></TR><TR><TD CLASS="l">225</TD><TD>        }</TD></TR><TR><TD CLASS="l">226</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>        if (orderBook.isEmpty())//book is empty hence the productstate may not be up-to-date</TD></TR><TR><TD CLASS="l">228</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>            processLegBestBookChange(prodKey,false);</TD></TR><TR><TD CLASS="l">230</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">231</TD><TD>        processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">232</TD><TD>    }</TD></TR><TR><TD CLASS="l">233</TD><TD> </TD></TR><TR><TD CLASS="l">234</TD><TD>    /**</TD></TR><TR><TD CLASS="l">235</TD><TD>     * Override the super class method to process auction related task.</TD></TR><TR><TD CLASS="l">236</TD><TD>     * 1. check if there is any active auction, if not, use super class</TD></TR><TR><TD CLASS="l">237</TD><TD>     *    logic to process the quoteSide</TD></TR><TR><TD CLASS="l">238</TD><TD>     * 2. if there is active auction, process the quote accordingly. After that</TD></TR><TR><TD CLASS="l">239</TD><TD>     *    if the quote still has remaining quantity, use super class logic</TD></TR><TR><TD CLASS="l">240</TD><TD>     *    to process.</TD></TR><TR><TD CLASS="l"><A NAME="3f">241</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">242</TD><TD>    protected void processQuoteSide(OrderBook orderBook, QuoteSide quoteSide)</TD></TR><TR><TD CLASS="l">243</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">244</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>        int prodKey = quoteSide.getProductKey().intValue();</TD></TR><TR><TD CLASS="l">246</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>        AuctionInternal activeAuction = orderBook.getTradingProduct().getActiveAuction();</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>        if ( activeAuction == null ){</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>            if (orderBook.isEmpty() == true)//book is empty hence the productstate may not be up-to-date</TD></TR><TR><TD CLASS="l">250</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                processLegBestBookChange(prodKey);</TD></TR><TR><TD CLASS="l">252</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>            super.processQuoteSide(orderBook, quoteSide);</TD></TR><TR><TD CLASS="l">254</TD><TD>        }</TD></TR><TR><TD CLASS="l">255</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>            if (shouldExpireDueToIncomingTradable(activeAuction, quoteSide)) {</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                getSpreadAuctionProcessor(prodKey).endAuctionByIncomingTradable(activeAuction, quoteSide, AuctionTerminateReasons.QUOTE_MARKETABLE_AGAINST_AUCTION);</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                performPostAuctionProcessing(activeAuction);</TD></TR><TR><TD CLASS="l">260</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>            if(quoteSide.getQuantityAllowed() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                super.processQuoteSide(orderBook, quoteSide);</TD></TR><TR><TD CLASS="l">263</TD><TD>            }</TD></TR><TR><TD CLASS="l">264</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>    }</TD></TR><TR><TD CLASS="l">266</TD><TD> </TD></TR><TR><TD CLASS="l">267</TD><TD>    /**</TD></TR><TR><TD CLASS="l">268</TD><TD>     * process the auction expiration</TD></TR><TR><TD CLASS="l">269</TD><TD>     * overwrite the method of the super class to implement it for hybrid tradeServer</TD></TR><TR><TD CLASS="l">270</TD><TD>     * @param theAuction</TD></TR><TR><TD CLASS="l"><A NAME="32">271</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">272</TD><TD>    public void processAuctionExpire(Auction theAuction, short terminateReason, Tradable terminatingTradable)</TD></TR><TR><TD CLASS="l">273</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">274</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>        if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>            Log.debug(this, &#34;The current auction ( &#34;+ StructToString.toString(theAuction.getAuctionId())</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                            +&#34; ), for procuctKey = &#34; + theAuction.getProductKey()</TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                            + &#34;, is being ended ... &#34;);</TD></TR><TR><TD CLASS="l">279</TD><TD>        }</TD></TR><TR><TD CLASS="l">280</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>        AuctionInternal auction = (AuctionInternal) theAuction;</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>        cleanupLegTimerBasedHoldups(auction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>        getSpreadAuctionProcessor(theAuction.getProductKey()).processAuctionExpire(auction, terminateReason, terminatingTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>        performPostAuctionProcessing(auction);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="16">285</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">286</TD><TD> </TD></TR><TR><TD CLASS="l">287</TD><TD>    protected AuctionProcessor getAuctionProcessor(int productKey)</TD></TR><TR><TD CLASS="l">288</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>            return getHybridProcessor(productKey).getAuctionProcessor(productKey);</TD></TR><TR><TD CLASS="l">290</TD><TD>    }</TD></TR><TR><TD CLASS="l">291</TD><TD>    </TD></TR><TR><TD CLASS="l">292</TD><TD>    /**</TD></TR><TR><TD CLASS="l">293</TD><TD>     * Perform any task after auction expires. Tasks may include:</TD></TR><TR><TD CLASS="l">294</TD><TD>     * 1. handling any remaining quantity for the auctioned order</TD></TR><TR><TD CLASS="l">295</TD><TD>     * 2. refresh the order book</TD></TR><TR><TD CLASS="l"><A NAME="2d">296</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">297</TD><TD>    protected void performPostAuctionProcessing(AuctionInternal auction)</TD></TR><TR><TD CLASS="l">298</TD><TD>    throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">299</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>        Order order = auction.getAuctionedOrder();</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>        if (auction.getAuctionType() == AuctionTypes.AUCTION_INTERNALIZATION &amp;&amp; order.getRemainingQuantity() &gt; 0)</TD></TR><TR><TD CLASS="l">302</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>            getHybridProcessor(order.getProductKey()).performPostAuctionProcessing(auction);</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>            return;</TD></TR><TR><TD CLASS="l">305</TD><TD>        }</TD></TR><TR><TD CLASS="l">306</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>        OrderBook orderBook = auction.getAuctionBook().getOrderBook();</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>        TradableList auctionedOrders = auction.getAuctionedOrderList();</TD></TR><TR><TD CLASS="l">309</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>        for (int i = 0, n = auctionedOrders.size(); i &lt; n ; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">311</TD><TD>            order = (Order) auctionedOrders.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>            postProcessAuctionedOrder(auction, order, orderBook);</TD></TR><TR><TD CLASS="l">313</TD><TD>        }</TD></TR><TR><TD CLASS="l">314</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>        super.performPostAuctionProcessing(auction);</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>    }</TD></TR><TR><TD CLASS="l">317</TD><TD> </TD></TR><TR><TD CLASS="l">318</TD><TD>  </TD></TR><TR><TD CLASS="l">319</TD><TD> </TD></TR><TR><TD CLASS="l">320</TD><TD>    /**</TD></TR><TR><TD CLASS="l">321</TD><TD>     * Process the best book change of a leg of spread</TD></TR><TR><TD CLASS="l">322</TD><TD>     * Modified by Cognizant Technology Solutions to start booked CO.</TD></TR><TR><TD CLASS="l">323</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="39">324</A></TD><TD>    </TD></TR><TR><TD CLASS="l">325</TD><TD>    </TD></TR><TR><TD CLASS="l">326</TD><TD>    public void processLegBestBookChange(int productKey, boolean allowReCOA)</TD></TR><TR><TD CLASS="l">327</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">329</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>            Log.debug(this, &#34;BrokerProcessorSpreadHybridImpl.processLegBestBookChange() on &#34;+productKey);</TD></TR><TR><TD CLASS="l">331</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>        OrderBook orderBook = null;</TD></TR><TR><TD CLASS="l">333</TD><TD>        try</TD></TR><TR><TD CLASS="l">334</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>            orderBook = getOrderBook(productKey);</TD></TR><TR><TD CLASS="l">336</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>        catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">338</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>            Log.exception(this, &#34;Product Order Book not found for: &#34; + productKey +&#34;; won't proceed with processLegBestBookChange()&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>            return;</TD></TR><TR><TD CLASS="l">341</TD><TD>        }</TD></TR><TR><TD CLASS="l">342</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>        short preState = orderBook.getTradingProduct().getCurrentStateCode();</TD></TR><TR><TD CLASS="l">344</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>            if(!orderBook.getTradingProduct().isTradableCrossProduct())</TD></TR><TR><TD CLASS="l">346</TD><TD>            {</TD></TR><TR><TD CLASS="l">347</TD><TD>                // changes per CrossProduct team requirement change, not going to check aution derived quote</TD></TR><TR><TD CLASS="l">348</TD><TD>                // when leg book changes </TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                AuctionInternal activeAuction = orderBook.getTradingProduct().getActiveAuction();</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                if (activeAuction != null &amp;&amp; shouldExpireDueToDerivedQuoteMove(activeAuction)) {</TD></TR><TR><TD CLASS="l">351</TD><TD>                    try {</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                        cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>                        processAuctionExpire(activeAuction, AuctionTerminateReasons.QUOTE_MARKETABLE_AGAINST_AUCTION, null);</TD></TR><TR><TD CLASS="l">354</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>                    catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                        Log.exception(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;processLegBestBookChange. Unable to expire active auction&#34;, e);</TD></TR><TR><TD CLASS="l">357</TD><TD>                    }</TD></TR><TR><TD CLASS="l">358</TD><TD>                }</TD></TR><TR><TD CLASS="l">359</TD><TD>            }</TD></TR><TR><TD CLASS="l">360</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>        super.processLegBestBookChange(productKey);</TD></TR><TR><TD CLASS="l">362</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>        short postState = orderBook.getTradingProduct().getCurrentStateCode();</TD></TR><TR><TD CLASS="l">364</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>        if (postState == ProductStates.ON_HOLD &amp;&amp; postState != preState)</TD></TR><TR><TD CLASS="l">366</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>            AuctionInternal activeAuction = getSpreadAuctionProcessor(productKey).findActiveAuction(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>            if (activeAuction != null)</TD></TR><TR><TD CLASS="l">369</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">371</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                    Log.debug(&#34;Expiring active auction due to product state changed to ON_HOLD: &#34;+productKey);</TD></TR><TR><TD CLASS="l">373</TD><TD>                }</TD></TR><TR><TD CLASS="l">374</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                    cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                    processAuctionExpire(activeAuction, AuctionTerminateReasons.PRODUCT_STATE_CHANGE, null);</TD></TR><TR><TD CLASS="l">377</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                    Log.exception(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;processLegBestBookChange. Unable to expire active auction due to product state became ON_HOLD&#34;, e);</TD></TR><TR><TD CLASS="l">380</TD><TD>                }</TD></TR><TR><TD CLASS="l">381</TD><TD>            }</TD></TR><TR><TD CLASS="l">382</TD><TD>        }</TD></TR><TR><TD CLASS="l">383</TD><TD>        try{</TD></TR><TR><TD CLASS="l">384</TD><TD>           // boolean needsToReCOA = !orderBook.getTradingProduct().getTradingClass().getAllowComplexTradesWithQuotes();</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>            if(!orderBook.isEmpty()&amp;&amp; orderBook.getTradingProduct().getCurrentStateCode() == ProductStates.OPEN &amp;&amp; allowReCOA) </TD></TR><TR><TD CLASS="l">386</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>                            TradingProduct tradingProduct = orderBook.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                            Integer classKey = tradingProduct.getTradingClass().getProductClassKey();</TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>                            getReCOAManagerHome().findByClass(classKey).validateAndStartReCOA(tradingProduct);</TD></TR><TR><TD CLASS="l">390</TD><TD>                        }</TD></TR><TR><TD CLASS="l">391</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                catch(Exception de)</TD></TR><TR><TD CLASS="l">393</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                        Log.exception(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;validateAndStartReCOA method.&#34;, de);</TD></TR><TR><TD CLASS="l">395</TD><TD>        }                </TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>    }</TD></TR><TR><TD CLASS="l">397</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="37">398</A></TD><TD> </TD></TR><TR><TD CLASS="l">399</TD><TD>    </TD></TR><TR><TD CLASS="l">400</TD><TD>    public void processLegBestBookChange(int productKey)</TD></TR><TR><TD CLASS="l">401</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>        processLegBestBookChange(productKey,true);</TD></TR><TR CLASS="z"><TD CLASS="l">403</TD><TD>    }</TD></TR><TR><TD CLASS="l">404</TD><TD>    </TD></TR><TR><TD CLASS="l">405</TD><TD>    /**</TD></TR><TR><TD CLASS="l">406</TD><TD>     * Re-auctions the resting complex order </TD></TR><TR><TD CLASS="l">407</TD><TD>     *  </TD></TR><TR><TD CLASS="l">408</TD><TD>     * @param orderBook</TD></TR><TR><TD CLASS="l">409</TD><TD>     * @param productKey</TD></TR><TR><TD CLASS="l">410</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">411</TD><TD>     * @throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">412</TD><TD>     * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">413</TD><TD>     */</TD></TR><TR><TD CLASS="l">414</TD><TD>    public void processReCOA(Integer productKey, TradingClass tradingClass, Side side)</TD></TR><TR><TD CLASS="l">415</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l"><A NAME="40">416</A></TD><TD>        {</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR><TD CLASS="l">418</TD><TD>        ///////////////////</TD></TR><TR><TD CLASS="l">419</TD><TD>        try{</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>            TradingProduct product=getOrderBook(productKey).getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>            boolean allLegsValid = product.areAllLegsValid();</TD></TR><TR><TD CLASS="l">422</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>            if (!allLegsValid)</TD></TR><TR><TD CLASS="l">424</TD><TD>            {</TD></TR><TR><TD CLASS="l">425</TD><TD>                // update marketStatus for each leg.</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                TradingStrategyLeg [] legs = product.getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>                for (int i = 0; i &lt; legs.length; i++)</TD></TR><TR><TD CLASS="l">428</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>                    TradingProduct legProduct = legs[i].getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>                    if (legProduct != null)</TD></TR><TR><TD CLASS="l">431</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                        legProduct.getOrderBook().evalMarketStatus();</TD></TR><TR><TD CLASS="l">433</TD><TD>                    }</TD></TR><TR><TD CLASS="l">434</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>                allLegsValid = product.areAllLegsValid();</TD></TR><TR><TD CLASS="l">436</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>            if(!allLegsValid)</TD></TR><TR><TD CLASS="l">438</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                Log.information(&#34;public void processLegBestBookChange(int productKey) if(!allLegsValid) &#34;+productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                return;</TD></TR><TR><TD CLASS="l">441</TD><TD>            }</TD></TR><TR><TD CLASS="l">442</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>        catch (Exception e){</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>            Log.exception(e);</TD></TR><TR><TD CLASS="l">445</TD><TD>        }</TD></TR><TR><TD CLASS="l">446</TD><TD>        ///////////////////</TD></TR><TR><TD CLASS="l">447</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>        LinkedList&lt;Order&gt; list= new LinkedList&lt;Order&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                OrderBook orderBook = null;</TD></TR><TR><TD CLASS="l">450</TD><TD>        try</TD></TR><TR><TD CLASS="l">451</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>            orderBook = getOrderBook(productKey.intValue());</TD></TR><TR><TD CLASS="l">453</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">454</TD><TD>        catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">455</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>            Log.exception(this, &#34;Product Order Book not found for: &#34; + productKey +&#34;; won't proceed with processLegBestBookChange()&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>            return;</TD></TR><TR><TD CLASS="l">458</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>        Price price = orderBook.getBestPrice(side);</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                Enumeration e = orderBook.getTradablesAtPrice(side, price);</TD></TR><TR CLASS="z"><TD CLASS="l">461</TD><TD>                if(!orderBook.getTradingProduct().getTradingClass().getAllowComplexTradesWithQuotes())</TD></TR><TR><TD CLASS="l">462</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>            e = orderBook.getTradables(side);  </TD></TR><TR><TD CLASS="l">464</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">465</TD><TD>                while (e.hasMoreElements())</TD></TR><TR><TD CLASS="l">466</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>                    Tradable tradable =  (Tradable)e.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                        if (tradable.getPrice().equals(price))</TD></TR><TR><TD CLASS="l">469</TD><TD>                {</TD></TR><TR><TD CLASS="l">470</TD><TD>                            //Ignorer quotes and quote like orders</TD></TR><TR CLASS="z"><TD CLASS="l">471</TD><TD>                            if(!tradable.isTradable(TradableTypes.QUOTE_SIDE)&amp;&amp; ! tradable.treatedLikeQuote()){</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>                                    Order order =(Order)tradable;</TD></TR><TR><TD CLASS="l">473</TD><TD>                                    </TD></TR><TR><TD CLASS="l">474</TD><TD>                        /*Order in the book has null handeling instructions and COA requires handeling instructions</TD></TR><TR><TD CLASS="l">475</TD><TD>                         * so faking the handeling instructions here</TD></TR><TR><TD CLASS="l">476</TD><TD>                         */</TD></TR><TR CLASS="z"><TD CLASS="l">477</TD><TD>                                    HandlingInstruction instruction = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>                        if (null == instruction)</TD></TR><TR><TD CLASS="l">479</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">480</TD><TD>                            instruction = new OrderHandlingInstructionNoReflectionImpl();</TD></TR><TR><TD CLASS="l">481</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>                        instruction.setTradingRestriction(TradingRestrictions.AUCTION);</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                        instruction.setExecutionPrice(NO_PRICE);</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>                        instruction.setMaximumExecutionVolume(order.getRemainingQuantity());</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                        instruction.setTradedVolume(0);</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>                        order.setHandlingInstruction(instruction);</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                        list.add(order);</TD></TR><TR><TD CLASS="l">488</TD><TD>                            }</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>                            if(tradable.isTradable(TradableTypes.ORDER))</TD></TR><TR><TD CLASS="l">490</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                    TradingProduct product = getOrderBook(productKey).getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                    DerivedQuote derivedQ = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                    StrategyLegTradeContainer legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(side, price, ((Order)tradable).getRemainingQuantity(), 1, product, derivedQ);</TD></TR><TR><TD CLASS="l">494</TD><TD>                    //Spread Protection Enabled I complex order, cannot start reCOA when locking quote legs. Hence cancel the remainder</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                    if (tradable.treatedLikeQuote() &amp;&amp; legTradeContainer.getCanTradeWithLegs())</TD></TR><TR><TD CLASS="l">496</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                        this.handleQuoteLikeOrderForReCOA((Order)tradable, orderBook);</TD></TR><TR><TD CLASS="l">498</TD><TD>                    }</TD></TR><TR><TD CLASS="l">499</TD><TD>                            }</TD></TR><TR><TD CLASS="l">500</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>                        else if (tradable.isTradable(TradableTypes.ORDER)) // handle situations where we have multiple price points, and not only the best price locks AQ</TD></TR><TR><TD CLASS="l">502</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                            handleOrderForSpreadProtection(productKey, side, orderBook, tradable);</TD></TR><TR><TD CLASS="l">504</TD><TD>                        }</TD></TR><TR><TD CLASS="l">505</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>                if(list.size()&gt;0)</TD></TR><TR><TD CLASS="l">507</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>                        processReCOAOrders(list, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>                        getReCOAManagerHome().findByClass(tradingClass.getProductClassKey()).reCOAStarted(orderBook.getTradingProduct());</TD></TR><TR><TD CLASS="l">510</TD><TD>                }        </TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>        }</TD></TR><TR><TD CLASS="l">512</TD><TD> </TD></TR><TR><TD CLASS="l">513</TD><TD>    /**</TD></TR><TR><TD CLASS="l">514</TD><TD>     * @param productKey</TD></TR><TR><TD CLASS="l">515</TD><TD>     * @param side</TD></TR><TR><TD CLASS="l">516</TD><TD>     * @param orderBook</TD></TR><TR><TD CLASS="l">517</TD><TD>     * @param tradable</TD></TR><TR><TD CLASS="l">518</TD><TD>     * @throws DataValidationException</TD></TR><TR><TD CLASS="l">519</TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l"><A NAME="24">520</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">521</TD><TD>    private void handleOrderForSpreadProtection(Integer productKey, Side side, OrderBook orderBook,</TD></TR><TR><TD CLASS="l">522</TD><TD>            Tradable tradable) throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">523</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>        if (!tradable.isTradable(TradableTypes.ORDER)) return;</TD></TR><TR CLASS="z"><TD CLASS="l">525</TD><TD>        TradingProduct product = getOrderBook(productKey).getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>        DerivedQuote derivedQ = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR CLASS="z"><TD CLASS="l">527</TD><TD>        StrategyLegTradeContainer legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(side, tradable.getPrice(), ((Order)tradable).getRemainingQuantity(), 1, product, derivedQ);</TD></TR><TR CLASS="z"><TD CLASS="l">528</TD><TD>        if (StrategyTradeServiceHelper.checkLegsHaveAutoQuotes((Order)tradable, product) &amp;&amp; legTradeContainer.getCanTradeWithLegs())</TD></TR><TR><TD CLASS="l">529</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>            if (tradable.treatedLikeQuote())</TD></TR><TR><TD CLASS="l">531</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                this.handleQuoteLikeOrderForReCOA((Order)tradable, orderBook);</TD></TR><TR><TD CLASS="l">533</TD><TD>            }</TD></TR><TR><TD CLASS="l">534</TD><TD>            else</TD></TR><TR><TD CLASS="l">535</TD><TD>            {</TD></TR><TR><TD CLASS="l">536</TD><TD>                try</TD></TR><TR><TD CLASS="l">537</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>                    if(tradable.isBooked())</TD></TR><TR><TD CLASS="l">539</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                        orderBook.unbook(tradable, tradable.getQuantityAllowed(), tradable.getSide(), tradable.getPrice());</TD></TR><TR><TD CLASS="l">541</TD><TD>                    }</TD></TR><TR><TD CLASS="l">542</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>                catch (OrderBookTradableNotFoundException e1)</TD></TR><TR><TD CLASS="l">544</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>                    Log.exception(this, &#34;failed to unbook order: &#34; + (Order)tradable, e1);</TD></TR><TR><TD CLASS="l">546</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>                Order anOrder = (Order)tradable;</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                if(anOrder.getHandlingInstruction() == null)</TD></TR><TR><TD CLASS="l">549</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>                    anOrder.setHandlingInstruction(new OrderHandlingInstructionNoReflectionImpl());</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>                    anOrder.getHandlingInstruction().setExecutionPrice(NO_PRICE);</TD></TR><TR><TD CLASS="l">552</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                anOrder.getHandlingInstruction().setReturnedCode(OrderRoutingReasons.ORDER_TOUCHES_LEG_QUOTES);</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                postProcess(anOrder, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                processRefreshBestBook(orderBook);</TD></TR><TR><TD CLASS="l">556</TD><TD>            }</TD></TR><TR><TD CLASS="l">557</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>    }</TD></TR><TR><TD CLASS="l">559</TD><TD> </TD></TR><TR><TD CLASS="l">560</TD><TD>    /**</TD></TR><TR><TD CLASS="l">561</TD><TD>     * This method will just cancel quote like orders that lock AQ, setting the correct cancel reason</TD></TR><TR><TD CLASS="l">562</TD><TD>     * and refreshing the book</TD></TR><TR><TD CLASS="l">563</TD><TD>     * @throws SystemException </TD></TR><TR><TD CLASS="l"><A NAME="25">564</A></TD><TD>     * @throws DataValidationException </TD></TR><TR><TD CLASS="l">565</TD><TD>     */</TD></TR><TR><TD CLASS="l">566</TD><TD>    protected void handleQuoteLikeOrderForReCOA(Order quoteLikeOrder, OrderBook orderBook) throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">567</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>        if (orderBook.getTradingProduct().getTradingClass().getAllowComplexTradesWithQuotes())</TD></TR><TR CLASS="z"><TD CLASS="l">569</TD><TD>            return;</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>        quoteLikeOrder.markCancelReason(ActivityReasons.ORDER_TOUCHES_LEG_QUOTES);</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>        processCancel(quoteLikeOrder, quoteLikeOrder.getRemainingQuantity(), quoteLikeOrder.getUserAssignedId(), true);</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>        processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>        Log.information(this, &#34;Quote like Order: &#34; + quoteLikeOrder + &#34; could not start reCOA and locks AQ: since AllowComplexTradeWithQuotes is false will cancel I order. Cancel Reason: &#34;+ActivityReasons.ORDER_TOUCHES_LEG_QUOTES);</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>    }</TD></TR><TR><TD CLASS="l">575</TD><TD>        </TD></TR><TR><TD CLASS="l">576</TD><TD>        /**</TD></TR><TR><TD CLASS="l">577</TD><TD>     * Gets reference to ReCOA Manager home.</TD></TR><TR><TD CLASS="l">578</TD><TD>     * </TD></TR><TR><TD CLASS="l">579</TD><TD>     * @return reference of ReCOA Manager.</TD></TR><TR><TD CLASS="l"><A NAME="1b">580</A></TD><TD>     * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">581</TD><TD>     */</TD></TR><TR><TD CLASS="l">582</TD><TD>    private ReCOAManagerHome getReCOAManagerHome()</TD></TR><TR><TD CLASS="l">583</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>        if (reCOAManagerHome == null)</TD></TR><TR><TD CLASS="l">585</TD><TD>        {</TD></TR><TR><TD CLASS="l">586</TD><TD>            try</TD></TR><TR><TD CLASS="l">587</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>                    reCOAManagerHome = (ReCOAManagerHomeImpl) HomeFactory.getInstance().findHome(ReCOAManagerHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">589</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>            catch (CBOELoggableException ex)</TD></TR><TR><TD CLASS="l">591</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">592</TD><TD>                throw new FatalFoundationFrameworkException(ex, &#34;Unable to find recoa manager home.&#34;);</TD></TR><TR><TD CLASS="l">593</TD><TD>            }</TD></TR><TR><TD CLASS="l">594</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">595</TD><TD>        return reCOAManagerHome;</TD></TR><TR><TD CLASS="l">596</TD><TD>    }</TD></TR><TR><TD CLASS="l">597</TD><TD>        </TD></TR><TR><TD CLASS="l">598</TD><TD>    /**</TD></TR><TR><TD CLASS="l">599</TD><TD>     * Based on the order handling instruction, processing the order accordingly</TD></TR><TR><TD CLASS="l">600</TD><TD>     *</TD></TR><TR><TD CLASS="l">601</TD><TD>     * Note: 1. tradeEndingPrice can only be specified as value price, or no price</TD></TR><TR><TD CLASS="l">602</TD><TD>     *       2. executing price can not be better than the order's price.</TD></TR><TR><TD CLASS="l">603</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="f">604</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">605</TD><TD>    public void doNormalOrderProcessing(Order anOrder, OrderBook book, Price botr)</TD></TR><TR><TD CLASS="l">606</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">607</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>        HandlingInstruction instruction = anOrder.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>        if ( instruction != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>            Price execPrice = instruction.getExecutionPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>            if (execPrice == null || ! execPrice.isValuedPrice() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>                processTradable(anOrder, book, NO_PRICE);</TD></TR><TR><TD CLASS="l">613</TD><TD>            }</TD></TR><TR><TD CLASS="l">614</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>                if (anOrder.getSide().isFirstBetter(execPrice, anOrder.getPrice())){</TD></TR><TR CLASS="z"><TD CLASS="l">616</TD><TD>                    execPrice = anOrder.getPrice();</TD></TR><TR><TD CLASS="l">617</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>                processTradable(anOrder, book, flipSignOnPrice(execPrice));</TD></TR><TR><TD CLASS="l">619</TD><TD>            }</TD></TR><TR><TD CLASS="l">620</TD><TD>        }</TD></TR><TR><TD CLASS="l">621</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>            super.doNormalOrderProcessing(anOrder, book, botr);</TD></TR><TR><TD CLASS="l">623</TD><TD>        }</TD></TR><TR><TD CLASS="l">624</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>    }</TD></TR><TR><TD CLASS="l">626</TD><TD> </TD></TR><TR><TD CLASS="l">627</TD><TD>   /** =======================================================================</TD></TR><TR><TD CLASS="l">628</TD><TD>     *  The above methods are defined in super class, but overriden here</TD></TR><TR><TD CLASS="l">629</TD><TD>     *  =======================================================================</TD></TR><TR><TD CLASS="l">630</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="7">631</A></TD><TD> </TD></TR><TR><TD CLASS="l">632</TD><TD>   private boolean cleanupLegTimerBasedHoldups(TradingProduct tradingProduct)</TD></TR><TR><TD CLASS="l">633</TD><TD>   throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">634</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">635</TD><TD>       boolean isAnyauctionExpired = false;</TD></TR><TR CLASS="z"><TD CLASS="l">636</TD><TD>       if ((tradingProduct.isStrategy()) &amp;&amp; (isRolledoutSpreadClass(tradingProduct)) &amp;&amp; (!tradingProduct.isProxy()))</TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>           return isAnyauctionExpired;</TD></TR><TR><TD CLASS="l">638</TD><TD>       </TD></TR><TR><TD CLASS="l">639</TD><TD>       // if it's cross product and product level lock is enabled, we won't</TD></TR><TR><TD CLASS="l">640</TD><TD>       // expire leg timer based holdups, delegate the responsibility to leg trading</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>       if (tradingProduct.isBuyWrite() &amp;&amp; tradingProduct.hasProductLock()) {</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>           return isAnyauctionExpired;</TD></TR><TR><TD CLASS="l">643</TD><TD>       }</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>       TradingStrategyLeg[] legs = tradingProduct.getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>       for (int i = 0; i &lt; legs.length; i++)</TD></TR><TR><TD CLASS="l">646</TD><TD>       {</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>           isAnyauctionExpired = expireAllTimerBasedHoldUps(legs[i].getTradingProduct());</TD></TR><TR><TD CLASS="l">648</TD><TD>       }</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>       return isAnyauctionExpired;</TD></TR><TR><TD CLASS="l">650</TD><TD>   }</TD></TR><TR><TD CLASS="l">651</TD><TD> </TD></TR><TR><TD CLASS="l">652</TD><TD>    /**</TD></TR><TR><TD CLASS="l">653</TD><TD>     * Force to expire all the following timer based &#34;HoldUp&#34;s</TD></TR><TR><TD CLASS="l">654</TD><TD>     * 1. quote trigger</TD></TR><TR><TD CLASS="l">655</TD><TD>     * 2. auction</TD></TR><TR><TD CLASS="l"><A NAME="12">656</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">657</TD><TD>    protected boolean expireAllTimerBasedHoldUps(TradingProduct tradingProduct)</TD></TR><TR><TD CLASS="l">658</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">659</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">660</TD><TD>        boolean isActiveAuction = false;</TD></TR><TR><TD CLASS="l">661</TD><TD>        // equity leg of cross product could have null tradingProduct</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>        if (tradingProduct == null || </TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>           ((tradingProduct.isStrategy()) &amp;&amp; (isRolledoutSpreadClass(tradingProduct)) &amp;&amp; (!tradingProduct.isProxy())))</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>            return isActiveAuction;</TD></TR><TR><TD CLASS="l">665</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>        OrderBook orderBook = tradingProduct.getOrderBook();</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>        getHybridProcessor(tradingProduct).forceExpireQuoteTrigger(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>        AuctionInternal auction = getAuctionService().findAuction(tradingProduct.getProductKey());</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>        if (auction != null)</TD></TR><TR><TD CLASS="l">670</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>            isActiveAuction = true;</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>            if (auction.isActive())</TD></TR><TR><TD CLASS="l">673</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                getHybridProcessor(tradingProduct).setAuctionState(auction.getProductKey(), auction.getAuctionType());</TD></TR><TR><TD CLASS="l">675</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>            getHybridProcessor(tradingProduct).processAuctionExpire(auction, AuctionTerminateReasons.QUOTE_QUANTITY_DECREASE, null);</TD></TR><TR CLASS="z"><TD CLASS="l">677</TD><TD>            getHybridProcessor(tradingProduct).setAuctionState(auction.getProductKey(), AuctionTypes.AUCTION_UNSPECIFIED);</TD></TR><TR><TD CLASS="l">678</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>        return isActiveAuction;</TD></TR><TR><TD CLASS="l"><A NAME="51">680</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">681</TD><TD> </TD></TR><TR><TD CLASS="l">682</TD><TD>    private boolean shouldExpireDueToDerivedQuoteMove(AuctionInternal activeAuction)</TD></TR><TR><TD CLASS="l">683</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>        return getSpreadAuctionProcessor(activeAuction.getProductKey()).shouldExpireDueToDerivedQuoteMove(activeAuction);</TD></TR><TR><TD CLASS="l"><A NAME="52">685</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">686</TD><TD> </TD></TR><TR><TD CLASS="l">687</TD><TD>    private boolean shouldExpireDueToIncomingTradable(AuctionInternal activeAuction, Tradable tradable)</TD></TR><TR><TD CLASS="l">688</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="53">689</A></TD><TD>        return getSpreadAuctionProcessor(activeAuction.getProductKey()).shouldExpireDueToIncomingTradable(activeAuction, tradable);</TD></TR><TR><TD CLASS="l">690</TD><TD>    }</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR><TD CLASS="l">692</TD><TD>    private boolean shouldJoin(AuctionInternal activeAuction, Tradable tradable) {</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>        return getSpreadAuctionProcessor(activeAuction.getProductKey()).shouldJoin(activeAuction, tradable);</TD></TR><TR><TD CLASS="l">694</TD><TD>    }</TD></TR><TR><TD CLASS="l">695</TD><TD> </TD></TR><TR><TD CLASS="l">696</TD><TD>    // please note we do have two get methods to get the processor, one is this and another one</TD></TR><TR><TD CLASS="l">697</TD><TD>    // is from COA since it was starting auction using processor on its own without setting the auction type</TD></TR><TR><TD CLASS="l">698</TD><TD>    // otherwise will not get the correct auction processor to start the coa auction.  These 2 have</TD></TR><TR><TD CLASS="l">699</TD><TD>    // to be called explicitly when in use. If have auction started and not sure what to use, use this method.</TD></TR><TR><TD CLASS="l">700</TD><TD>    </TD></TR><TR><TD CLASS="l">701</TD><TD>    // One way to avoid this is to refactor COA code to not using auction processor to start auction and </TD></TR><TR><TD CLASS="l">702</TD><TD>    // add code to setAuctionState to UNSPECIFIED when auction ends.</TD></TR><TR><TD CLASS="l"><A NAME="1d">703</A></TD><TD>    protected AuctionProcessorSpreadHybridImpl getSpreadAuctionProcessor(int productKey)</TD></TR><TR><TD CLASS="l">704</TD><TD>    {</TD></TR><TR><TD CLASS="l">705</TD><TD>        try</TD></TR><TR><TD CLASS="l">706</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>            OrderBook book = this.getOrderBook(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>            TradingProduct prod = book.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>            AuctionInternal auction = prod.getActiveAuction();</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>            if(auction != null)</TD></TR><TR><TD CLASS="l">711</TD><TD>            {    </TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                return (AuctionProcessorSpreadHybridImpl)auctionProcessorFactory.getAuctionProcessor(auction.getAuctionType(), prod);</TD></TR><TR><TD CLASS="l">713</TD><TD>            }</TD></TR><TR><TD CLASS="l">714</TD><TD>            else</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                return (AuctionProcessorSpreadHybridImpl)auctionProcessorFactory.getCOAAuctionProcessor();</TD></TR><TR><TD CLASS="l">716</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>        catch(Exception e)</TD></TR><TR><TD CLASS="l">718</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>            Log.exception(this, &#34;error processing getSpreadAuctionProcessor for product: &#34; + productKey, e );</TD></TR><TR><TD CLASS="l">720</TD><TD>        }   </TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">722</TD><TD>    }</TD></TR><TR><TD CLASS="l">723</TD><TD> </TD></TR><TR><TD CLASS="l">724</TD><TD>    /**</TD></TR><TR><TD CLASS="l">725</TD><TD>     * When a spread order comes from TPF, it may only want to query the TSB</TD></TR><TR><TD CLASS="l"><A NAME="2b">726</A></TD><TD>     * (Top of Spread Book). And it is indicated by handling instruction type</TD></TR><TR><TD CLASS="l">727</TD><TD>     * = TradingRestrictions.TOP_SPREAD_BOOK</TD></TR><TR><TD CLASS="l">728</TD><TD>     */</TD></TR><TR><TD CLASS="l">729</TD><TD>    private boolean isTSBRequest(Order order){</TD></TR><TR CLASS="z"><TD CLASS="l">730</TD><TD>        HandlingInstruction instruction = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">731</TD><TD>        return instruction != null &amp;&amp; instruction.getTradingRestriction() == TradingRestrictions.TOP_SPREAD_BOOK;</TD></TR><TR><TD CLASS="l">732</TD><TD>    }</TD></TR><TR><TD CLASS="l">733</TD><TD> </TD></TR><TR><TD CLASS="l">734</TD><TD>    /**</TD></TR><TR><TD CLASS="l">735</TD><TD>     * 1. get the TSB information from the spread order book</TD></TR><TR><TD CLASS="l">736</TD><TD>     * 2. return the order and the TSB to TPF</TD></TR><TR><TD CLASS="l">737</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="26">738</A></TD><TD>    private void handleReturningOrder(Order order, OrderBook orderBook, short returnReason)</TD></TR><TR><TD CLASS="l">739</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">740</TD><TD>    {</TD></TR><TR><TD CLASS="l">741</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">742</TD><TD>            BookDepthStruct bookDepth = orderBook.getBookDepth(true); //only the top</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>            returnOrderWithBookDepth(order, bookDepth, returnReason);</TD></TR><TR><TD CLASS="l">744</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>            Log.exception(&#34;BrokerProcessorSpreadHybridImpl &gt;&gt; returning order and TSB failed for order: &#34; + order.toString() + &#34; It will be booked instead &#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>            handleFailedReturning(order, orderBook);</TD></TR><TR><TD CLASS="l">748</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="4b">750</A></TD><TD> </TD></TR><TR><TD CLASS="l">751</TD><TD>    private void returnOrderWithBookDepth(Order anOrder, BookDepthStruct bookDepth, short reason)</TD></TR><TR><TD CLASS="l">752</TD><TD>    throws NotAcceptedException</TD></TR><TR><TD CLASS="l">753</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">755</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">756</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::returnOrderWithBookDepth&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>            ReflectiveStructBuilder.printStruct(anOrder.getStruct(), &#34;returnOrderWithBookDepth - anOrder.getStruct()&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>            ReflectiveStructBuilder.printStruct(bookDepth, &#34;returnOrderWithBookDepth - BookDepthStruct&#34;);</TD></TR><TR><TD CLASS="l">759</TD><TD>        }</TD></TR><TR><TD CLASS="l">760</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>            if (reason != OrderRoutingReasons.TSB_RETURNED)  {</TD></TR><TR CLASS="z"><TD CLASS="l">762</TD><TD>            anOrder.changeToState(InternalOrderStates.ROUTED_AWAY);</TD></TR><TR><TD CLASS="l">763</TD><TD>            }</TD></TR><TR><TD CLASS="l">764</TD><TD>            // Return Order with reason and book depth to OHS over IOSC 07/20/06</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>            anOrder.returnOrderWithReasonAndBookDepth(bookDepth, reason);</TD></TR><TR><TD CLASS="l">766</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>        catch (Exception e){</TD></TR><TR CLASS="z"><TD CLASS="l">768</TD><TD>            Log.exception(this, &#34;Unable to route [OrderID] &#34; + anOrder.toString(),e);</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>            throw ExceptionBuilder.notAcceptedException(&#34;RoutingSession exception&#34;, NotAcceptedCodes.UNKNOWN_TYPE);</TD></TR><TR><TD CLASS="l">770</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>    }</TD></TR><TR><TD CLASS="l">772</TD><TD> </TD></TR><TR><TD CLASS="l">773</TD><TD> </TD></TR><TR><TD CLASS="l">774</TD><TD>    /**</TD></TR><TR><TD CLASS="l">775</TD><TD>     * When returning order and TSB fails, the order handling instrucion is modified so</TD></TR><TR><TD CLASS="l">776</TD><TD>     * that the order will be booked.</TD></TR><TR><TD CLASS="l"><A NAME="21">777</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">778</TD><TD>    private void handleFailedReturning(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">779</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">780</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>        HandlingInstruction instruction = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">782</TD><TD>        if(instruction == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">783</TD><TD>            instruction = new OrderHandlingInstructionNoReflectionImpl();</TD></TR><TR><TD CLASS="l">784</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>        instruction.setTradingRestriction(TradingRestrictions.BOOK);</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>        instruction.setExecutionPrice(NO_PRICE);</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>        instruction.setMaximumExecutionVolume(0);</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>        handleNormalStrategyOrder(order, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>    }</TD></TR><TR><TD CLASS="l">790</TD><TD> </TD></TR><TR><TD CLASS="l">791</TD><TD>    /**</TD></TR><TR><TD CLASS="l">792</TD><TD>     * Note: &#34;NormalStrategyOrder&#34; means that the order is not an auction response,</TD></TR><TR><TD CLASS="l">793</TD><TD>     * and not a TSB request.</TD></TR><TR><TD CLASS="l"><A NAME="23">794</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">795</TD><TD>    private void handleNormalStrategyOrder(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">796</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">797</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">799</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::handleNormalStrategyOrder&#34;);</TD></TR><TR><TD CLASS="l">801</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>        AuctionInternal activeAuction = orderBook.getTradingProduct().getActiveAuction();</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>        if ( activeAuction != null ){</TD></TR><TR CLASS="z"><TD CLASS="l">804</TD><TD>            processOrderWithActiveAuction(order, activeAuction, orderBook);</TD></TR><TR><TD CLASS="l">805</TD><TD>        }</TD></TR><TR><TD CLASS="l">806</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">807</TD><TD>            processOrderWithoutActiveAuction(order, orderBook);</TD></TR><TR><TD CLASS="l">808</TD><TD>        }</TD></TR><TR><TD CLASS="l">809</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">810</TD><TD>        postProcess(order, orderBook);</TD></TR><TR><TD CLASS="l">811</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">812</TD><TD>        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">813</TD><TD>            resetIndexHybridProperties(order);</TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">815</TD><TD>    }</TD></TR><TR><TD CLASS="l">816</TD><TD> </TD></TR><TR><TD CLASS="l">817</TD><TD>    /**</TD></TR><TR><TD CLASS="l">818</TD><TD>     * PostProcessing is responsible to postprocess the incoming order after execution</TD></TR><TR><TD CLASS="l">819</TD><TD>     * if it still has any remaining quantity.</TD></TR><TR><TD CLASS="l">820</TD><TD>     *</TD></TR><TR><TD CLASS="l">821</TD><TD>     * Note: Functionally, this is different than the &#34;protected&#34; method performPostAuctionProcessing.</TD></TR><TR><TD CLASS="l">822</TD><TD>     * Differences are:</TD></TR><TR><TD CLASS="l">823</TD><TD>     * 1. performPostAuctionProcessing, which is defined in the super class, does any neccesary tasks</TD></TR><TR><TD CLASS="l">824</TD><TD>     * for the order(s) auctioned after the auction expires.</TD></TR><TR><TD CLASS="l">825</TD><TD>     * 2. postProcess handles the incoming order after execution.</TD></TR><TR><TD CLASS="l">826</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="2f">827</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">828</TD><TD>    private void postProcess(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">829</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">830</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">832</TD><TD>        {</TD></TR><TR><TD CLASS="l">833</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::postProcess&#34;);</TD></TR><TR><TD CLASS="l">835</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">836</TD><TD>        if (order.getRemainingQuantity() &lt;= 0 || order.isBookedByAuction() || order.isInvolvedInQuoteTrigger()) {</TD></TR><TR CLASS="z"><TD CLASS="l">837</TD><TD>            return;</TD></TR><TR><TD CLASS="l">838</TD><TD>        }</TD></TR><TR><TD CLASS="l">839</TD><TD>        //  cancel IOC order before further processing for regular and index hybrid</TD></TR><TR CLASS="z"><TD CLASS="l">840</TD><TD>        cancelIOCOrder(order); </TD></TR><TR CLASS="z"><TD CLASS="l">841</TD><TD>        cancelIOrderForBoB(order);</TD></TR><TR><TD CLASS="l">842</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">843</TD><TD>        short reason = getReturnCodeForOrder(order);</TD></TR><TR><TD CLASS="l">844</TD><TD>        </TD></TR><TR><TD CLASS="l">845</TD><TD>        try{</TD></TR><TR CLASS="z"><TD CLASS="l">846</TD><TD>            TradingProduct product = getOrderBook(order.getProductKey().intValue()).getTradingProduct(); </TD></TR><TR CLASS="z"><TD CLASS="l">847</TD><TD>            if (product.isBuyWrite() &amp;&amp; !product.getTradingClass().getEnableCPSBooking() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">848</TD><TD>            reason &lt; 0 &amp;&amp; order.getRemainingQuantity() &gt; 0)</TD></TR><TR><TD CLASS="l">849</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">850</TD><TD>                reason = (order.getTradedQuantity()==0) </TD></TR><TR CLASS="z"><TD CLASS="l">851</TD><TD>                        ? OrderRoutingReasons.NOT_TRADED_NOT_AUCTIONED</TD></TR><TR CLASS="z"><TD CLASS="l">852</TD><TD>                        : OrderRoutingReasons.PARTIALLY_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">853</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">854</TD><TD>        }catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">855</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">856</TD><TD>                Log.alarm(&#34;Can't find OrderBook for order: &#34; + order);</TD></TR><TR><TD CLASS="l">857</TD><TD>        }</TD></TR><TR><TD CLASS="l">858</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">859</TD><TD>        if (reason &lt; 0) { //not returning.</TD></TR><TR CLASS="z"><TD CLASS="l">860</TD><TD>            handleTradablePostprocess(order, orderBook);</TD></TR><TR><TD CLASS="l">861</TD><TD>        }</TD></TR><TR><TD CLASS="l">862</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>            handleReturningOrder(order, orderBook, reason);</TD></TR><TR><TD CLASS="l">864</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>    }</TD></TR><TR><TD CLASS="l">866</TD><TD> </TD></TR><TR><TD CLASS="l">867</TD><TD>    /*</TD></TR><TR><TD CLASS="l">868</TD><TD>     * Cancel IOC order before processing the IOC Order if there is remaining quantity on the order, </TD></TR><TR><TD CLASS="l">869</TD><TD>     * For Index Hybrid, if not marketable with manual Quote or we have remainder due to AUTO_EX </TD></TR><TR><TD CLASS="l"><A NAME="5">870</A></TD><TD>     * then donot cancel the order, it needs to be returned back ...         </TD></TR><TR><TD CLASS="l">871</TD><TD>     */</TD></TR><TR><TD CLASS="l">872</TD><TD>    private void cancelIOCOrder(Order order) throws DataValidationException</TD></TR><TR><TD CLASS="l">873</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">874</TD><TD>         if  (  order.getRemainingQuantity() &gt; 0</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>                &amp;&amp; !( order.getHandlingInstruction()!= null</TD></TR><TR CLASS="z"><TD CLASS="l">876</TD><TD>                      &amp;&amp; order.getHandlingInstruction().ignoreContingency())</TD></TR><TR CLASS="z"><TD CLASS="l">877</TD><TD>                &amp;&amp; order.getContingencyType() == ContingencyTypes.IOC)</TD></TR><TR><TD CLASS="l">878</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">879</TD><TD>            if( !order.getHandlingInstruction().isOrderReturnReasonSetForIndexHybrid()  ||</TD></TR><TR CLASS="z"><TD CLASS="l">880</TD><TD>                 order.getHandlingInstruction().getOverRideReasonForIndexHybrid() == OrderRoutingReasons.STRATEGY_MARKETABLE_WITH_MANUAL_QUOTE   )</TD></TR><TR><TD CLASS="l">881</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">882</TD><TD>               order.cancel(ActivityReasons.USER);</TD></TR><TR CLASS="z"><TD CLASS="l">883</TD><TD>               if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">884</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">885</TD><TD>                    Log.debug(&#34;Cancelled IOC complex order's remaning qty : &#34; + order.getRemainingQuantity() + &#34;, OrderId = &#34; + order.getOrderIdString());</TD></TR><TR><TD CLASS="l">886</TD><TD>               }</TD></TR><TR><TD CLASS="l">887</TD><TD>            }            </TD></TR><TR><TD CLASS="l">888</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>    }</TD></TR><TR><TD CLASS="l">890</TD><TD> </TD></TR><TR><TD CLASS="l">891</TD><TD>    /**</TD></TR><TR><TD CLASS="l">892</TD><TD>     * 1. Because the auction trade ending price may be worse than the execution price (worse from the market point</TD></TR><TR><TD CLASS="l">893</TD><TD>     * of view. 9 is worse than 8 because 9 asks for more money than 8. Similarly, -8 is worse than -9 because</TD></TR><TR><TD CLASS="l">894</TD><TD>     * -8 is willing to pay less money). After an order is auctioned, and if it still has remaining quantity, and</TD></TR><TR><TD CLASS="l">895</TD><TD>     * the execution price is better than auction starting price, we will try to trade the order again upto the</TD></TR><TR><TD CLASS="l">896</TD><TD>     * execution price.</TD></TR><TR><TD CLASS="l">897</TD><TD>     *</TD></TR><TR><TD CLASS="l">898</TD><TD>     * 2. Then if the order has to be returned. If not returned, the auctioned order has to go through</TD></TR><TR><TD CLASS="l">899</TD><TD>     * the normal order processing, it can not be just booked directly.</TD></TR><TR><TD CLASS="l"><A NAME="30">900</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">901</TD><TD>    private void postProcessAuctionedOrder(AuctionInternal auction, Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">902</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">903</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">904</TD><TD>        if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">905</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImp&gt;&gt;postProcessAuctionedOrder:&#34; + order);</TD></TR><TR><TD CLASS="l">906</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">907</TD><TD>        if (order.getRemainingQuantity() &lt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">908</TD><TD>            processPendingCancelRequest(order);//process any pending cxl, cxl/Re</TD></TR><TR CLASS="z"><TD CLASS="l">909</TD><TD>            return;</TD></TR><TR><TD CLASS="l">910</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">911</TD><TD>            Side side = auction.getSide();</TD></TR><TR CLASS="z"><TD CLASS="l">912</TD><TD>            HandlingInstruction handlinInstr = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">913</TD><TD>            if (null != handlinInstr)</TD></TR><TR><TD CLASS="l">914</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">915</TD><TD>                Price execPrice = handlinInstr.getExecutionPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">916</TD><TD>                Price originalExecPrice = handlinInstr.getOriginalExecutionPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">917</TD><TD>                if(originalExecPrice == null)</TD></TR><TR><TD CLASS="l">918</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">919</TD><TD>                    originalExecPrice = execPrice;</TD></TR><TR><TD CLASS="l">920</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">921</TD><TD>                if (orderBook.getTradingProduct().isBuyWrite() || side.isFirstBetter(execPrice, auction.getStartingPrice())) {</TD></TR><TR CLASS="z"><TD CLASS="l">922</TD><TD>                    processTradable(order, orderBook, flipSignOnPrice(orderBook.getTradingProduct().isBuyWrite() ? originalExecPrice : execPrice));</TD></TR><TR><TD CLASS="l">923</TD><TD>                }</TD></TR><TR><TD CLASS="l">924</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>        processIOCCancel(order);//if the order was IOC, cxl the remaining.</TD></TR><TR CLASS="z"><TD CLASS="l">926</TD><TD>        processPendingCancelRequest(order);//process any pending cxl, cxl/Re</TD></TR><TR><TD CLASS="l">927</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">928</TD><TD>        short reason = getReturnCodeForOrder(order);</TD></TR><TR CLASS="z"><TD CLASS="l">929</TD><TD>        int remQty = order.getRemainingQuantity();</TD></TR><TR><TD CLASS="l">930</TD><TD>        try{</TD></TR><TR CLASS="z"><TD CLASS="l">931</TD><TD>            TradingProduct product = getOrderBook(order.getProductKey().intValue()).getTradingProduct(); </TD></TR><TR CLASS="z"><TD CLASS="l">932</TD><TD>            if (product.isBuyWrite() &amp;&amp; !product.getTradingClass().getEnableCPSBooking() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>            reason &lt; 0 &amp;&amp; remQty &gt; 0)</TD></TR><TR><TD CLASS="l">934</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">935</TD><TD>                reason = (order.getTradedQuantity()==0) </TD></TR><TR CLASS="z"><TD CLASS="l">936</TD><TD>                        ? OrderRoutingReasons.NOT_TRADED_AUCTIONED</TD></TR><TR CLASS="z"><TD CLASS="l">937</TD><TD>                        : OrderRoutingReasons.PARTIALLY_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">938</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">939</TD><TD>        }catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">940</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">941</TD><TD>                Log.alarm(&#34;Can't find OrderBook for order: &#34; + order);</TD></TR><TR><TD CLASS="l">942</TD><TD>        }</TD></TR><TR><TD CLASS="l">943</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">944</TD><TD>        if (reason &lt; 0) { //not returning.</TD></TR><TR CLASS="z"><TD CLASS="l">945</TD><TD>            if (remQty &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>                handleTradablePostprocess(order, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>                if (!order.isInvolvedInQuoteTrigger()) {</TD></TR><TR CLASS="z"><TD CLASS="l">948</TD><TD>                    setCOAStartedTime(order);</TD></TR><TR><TD CLASS="l">949</TD><TD>                }</TD></TR><TR><TD CLASS="l">950</TD><TD>            }</TD></TR><TR><TD CLASS="l">951</TD><TD>        }</TD></TR><TR><TD CLASS="l">952</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">953</TD><TD>            handleReturningOrder(order, orderBook, reason);</TD></TR><TR><TD CLASS="l">954</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">955</TD><TD>    }</TD></TR><TR><TD CLASS="l">956</TD><TD> </TD></TR><TR><TD CLASS="l">957</TD><TD>    /**</TD></TR><TR><TD CLASS="l">958</TD><TD>     * return a new price object with opposite sign than the price passed in. If it is not a valued price</TD></TR><TR><TD CLASS="l"><A NAME="14">959</A></TD><TD>     * return itself</TD></TR><TR><TD CLASS="l">960</TD><TD>     */</TD></TR><TR><TD CLASS="l">961</TD><TD>    private Price flipSignOnPrice(Price price)</TD></TR><TR><TD CLASS="l">962</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>        if ( ! price.isValuedPrice()) {</TD></TR><TR CLASS="z"><TD CLASS="l">964</TD><TD>            return price;</TD></TR><TR><TD CLASS="l">965</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>        double value = 0.0D - price.toDouble();</TD></TR><TR CLASS="z"><TD CLASS="l">967</TD><TD>        return PriceFactory.create(value);</TD></TR><TR><TD CLASS="l">968</TD><TD>    }</TD></TR><TR><TD CLASS="l">969</TD><TD> </TD></TR><TR><TD CLASS="l">970</TD><TD>    /**</TD></TR><TR><TD CLASS="l">971</TD><TD>     * Order is requested to be auctioned if handling instruction specifies the tradingRestriction as</TD></TR><TR><TD CLASS="l">972</TD><TD>     * 1. TradingRestrictions.AUCTION</TD></TR><TR><TD CLASS="l">973</TD><TD>     * 2. TradingRestrictions.PAR_AUCTION</TD></TR><TR><TD CLASS="l"><A NAME="48">974</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">975</TD><TD>     * Note: &#34;I&#34; order can not start an auction.</TD></TR><TR><TD CLASS="l">976</TD><TD>     */</TD></TR><TR><TD CLASS="l">977</TD><TD>    private boolean requestedToAuction(Order order) {</TD></TR><TR CLASS="z"><TD CLASS="l">978</TD><TD>        HandlingInstruction instruction = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>        if (order.treatedLikeQuote() || instruction == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">981</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>        return instruction.getTradingRestriction() == TradingRestrictions.AUCTION ||</TD></TR><TR CLASS="z"><TD CLASS="l">983</TD><TD>               instruction.getTradingRestriction() == TradingRestrictions.PAR_AUCTION;</TD></TR><TR><TD CLASS="l">984</TD><TD>    }</TD></TR><TR><TD CLASS="l">985</TD><TD> </TD></TR><TR><TD CLASS="l">986</TD><TD>    /**</TD></TR><TR><TD CLASS="l">987</TD><TD>     * When there is no active auction on the product,</TD></TR><TR><TD CLASS="l">988</TD><TD>     * 1. check the incoming order to see if it is requested to be auction. If yes, try to start auction.</TD></TR><TR><TD CLASS="l">989</TD><TD>     * 2. if it is not requested to be auctioned, or for some reason auction cannot be started. The order</TD></TR><TR><TD CLASS="l">990</TD><TD>     *    will go through the normal processing.</TD></TR><TR><TD CLASS="l"><A NAME="3d">991</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">992</TD><TD>    private void processOrderWithoutActiveAuction(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">993</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">994</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">995</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">996</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">997</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::processOrderWithoutActiveAuction&#34;);</TD></TR><TR><TD CLASS="l">998</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>        if (order.getHandlingInstruction()!=null &amp;&amp;  order.getHandlingInstruction().getReturnedCode() &gt; 0)</TD></TR><TR><TD CLASS="l">1000</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>            return;</TD></TR><TR><TD CLASS="l">1002</TD><TD>        }</TD></TR><TR><TD CLASS="l">1003</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1004</TD><TD>        AuctionInternal auction = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1005</TD><TD>        if ( requestedToAuction(order) &amp;&amp; !isManualQuotePresent (orderBook) &amp;&amp; isOrderSizeBetweenAuctionMinMax(order))  {</TD></TR><TR CLASS="z"><TD CLASS="l">1006</TD><TD>            preAuctionCleanup(order, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">1007</TD><TD>            List&lt;Order&gt; orders = new ArrayList&lt;Order&gt;(1);</TD></TR><TR CLASS="z"><TD CLASS="l">1008</TD><TD>            orders.add(order);</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>            Price auctionStartingPrice = getSpreadAuctionProcessor(order.getProductKey()).canStartAuction(orders, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">1010</TD><TD>            auction = getSpreadAuctionProcessor(order.getProductKey()).startAuction(orders, auctionStartingPrice, orderBook);</TD></TR><TR><TD CLASS="l">1011</TD><TD>           /* if(auction != null) {</TD></TR><TR><TD CLASS="l">1012</TD><TD>                getAuctionProcessor(auction.getProductKey()).publishAuctionEvent(auction, ActivityTypes.AUCTION_START);</TD></TR><TR><TD CLASS="l">1013</TD><TD>            }*/</TD></TR><TR><TD CLASS="l">1014</TD><TD>            // This will set the cap details used for PMM entitlement.</TD></TR><TR CLASS="z"><TD CLASS="l">1015</TD><TD>            setAllocationContext(auction,order,orderBook);</TD></TR><TR><TD CLASS="l">1016</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1017</TD><TD>        if ( auction == null ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1018</TD><TD>            doNormalOrderProcessing(order, orderBook, null);</TD></TR><TR><TD CLASS="l">1019</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="27">1020</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1021</TD><TD> </TD></TR><TR><TD CLASS="l">1022</TD><TD>    private boolean isOrderSizeBetweenAuctionMinMax(Order order) throws DataValidationException</TD></TR><TR><TD CLASS="l">1023</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                AuctionMinMaxOrderSize auctionMinMaxOrdSize = null;</TD></TR><TR><TD CLASS="l">1025</TD><TD>                try{</TD></TR><TR CLASS="z"><TD CLASS="l">1026</TD><TD>                        auctionMinMaxOrdSize = getTradingProductHome().findByKey(order.getProductKey()).getTradingClass().getAuctionMinMaxOrderSize(AuctionTypes.AUCTION_STRATEGY);</TD></TR><TR><TD CLASS="l">1027</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1028</TD><TD>                catch(NotFoundException e)</TD></TR><TR><TD CLASS="l">1029</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1030</TD><TD>                        throw ExceptionBuilder.dataValidationException((&#34;Invalid product key:&#34; + order.getProductKey() + &#34;.&#34;),</TD></TR><TR CLASS="z"><TD CLASS="l">1031</TD><TD>                                        DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">1032</TD><TD>                }</TD></TR><TR><TD CLASS="l">1033</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1034</TD><TD>                if (auctionMinMaxOrdSize != null)</TD></TR><TR><TD CLASS="l">1035</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1036</TD><TD>                        int qty = order.getOriginalQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>                        if ((qty &lt; auctionMinMaxOrdSize.getMinOrderSize()) || (qty &gt; auctionMinMaxOrdSize.getMaxOrderSize()))</TD></TR><TR><TD CLASS="l">1038</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>                                String msg = &#34;Auctioned order quantity does not meet the min/max order size for Auction&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1040</TD><TD>                                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1041</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1042</TD><TD>                                        Log.debug(msg);</TD></TR><TR><TD CLASS="l">1043</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>                                return false;</TD></TR><TR><TD CLASS="l">1045</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1046</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1047</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">1048</TD><TD>        }</TD></TR><TR><TD CLASS="l">1049</TD><TD> </TD></TR><TR><TD CLASS="l">1050</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1051</TD><TD>     * This method sets the capdetails for PMM allocation when the spread order auctions.</TD></TR><TR><TD CLASS="l">1052</TD><TD>     *         1.  If at the conclusion of a COA, the incoming trades against the legs, the PMM gets an entitlement on any leg(s) </TD></TR><TR><TD CLASS="l">1053</TD><TD>     *                 where the PMM was part of the BBO at the start of the auction. </TD></TR><TR><TD CLASS="l">1054</TD><TD>         *        2. If at the conclusion of a COA, the incoming trades against the COB, the PMM gets an entitlement</TD></TR><TR><TD CLASS="l">1055</TD><TD>         *           if on top of the COB at the start of the auction, regardless of whether the COB was better than,</TD></TR><TR><TD CLASS="l">1056</TD><TD>         *            equal to, or worse than the legs.</TD></TR><TR><TD CLASS="l">1057</TD><TD>         *  3. If at the conclusion of a COA, the incoming trades against responses, the PMM gets an entitlement</TD></TR><TR><TD CLASS="l">1058</TD><TD>         *   if either:  (A) the PMM was on the BBO in ANY leg at the start of the auction, regardless of whether the legs were better than, equal to, or worse than the COB; or, </TD></TR><TR><TD CLASS="l">1059</TD><TD>         *                            (B) at the start of the auction, the COB improved the legs, and the PMM was on top of the COB.</TD></TR><TR><TD CLASS="l">1060</TD><TD>         *</TD></TR><TR><TD CLASS="l">1061</TD><TD>         * The map has the BBO details for the legs, spread and for auction responses.</TD></TR><TR><TD CLASS="l"><A NAME="4c">1062</A></TD><TD>     * </TD></TR><TR><TD CLASS="l">1063</TD><TD>     */</TD></TR><TR><TD CLASS="l">1064</TD><TD>    private void setAllocationContext(AuctionInternal auction, Order order,OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1065</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>        if(auction !=null)</TD></TR><TR><TD CLASS="l">1067</TD><TD>        {</TD></TR><TR><TD CLASS="l">1068</TD><TD>                // Map with product key as the key and value as another map(AcronymCapQtyMap)</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt; capDetails = new HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                List preferredFirm = PDPMExtensionsCompatibleHelper.deCodePDPMListFromExtensions(order.getExtensions());</TD></TR><TR><TD CLASS="l">1071</TD><TD>                </TD></TR><TR><TD CLASS="l">1072</TD><TD>                //If there is no preferred acronym, PDPM allocation will never happen.So, capdetails is not required.</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>                if(preferredFirm == null || preferredFirm.size()==0)</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1075</TD><TD>        </TD></TR><TR><TD CLASS="l">1076</TD><TD>            // 1. CapDetails for legs .</TD></TR><TR><TD CLASS="l">1077</TD><TD>             Side legSideToTrade;</TD></TR><TR><TD CLASS="l">1078</TD><TD>             Price legSideBestPrice;</TD></TR><TR><TD CLASS="l">1079</TD><TD>             </TD></TR><TR><TD CLASS="l">1080</TD><TD>             //This map is for deciding the COA auction resonses will get PDPM allocation. COA RFPs will get PDPM</TD></TR><TR><TD CLASS="l">1081</TD><TD>             // allocation if the PMM was on TOB for atleast one of the legs or PMM was on TOB of COB and COB is better</TD></TR><TR><TD CLASS="l">1082</TD><TD>             //than DSM</TD></TR><TR CLASS="z"><TD CLASS="l">1083</TD><TD>             HashMap&lt;String, Integer&gt; acronymCapQtyMapForCOAResponses = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>             TradingStrategyLeg[] tLegs = orderBook.getTradingProduct().getStrategyLegs();</TD></TR><TR><TD CLASS="l">1085</TD><TD>             // if the trading product is STS enabled, the information has be to acquired from HTS</TD></TR><TR><TD CLASS="l">1086</TD><TD>             // get the information for all legs to reduce the number of remote calls</TD></TR><TR CLASS="z"><TD CLASS="l">1087</TD><TD>             boolean isRolledoutSpreadClass = false;</TD></TR><TR><TD CLASS="l">1088</TD><TD>             try</TD></TR><TR><TD CLASS="l">1089</TD><TD>             {</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>                isRolledoutSpreadClass = orderBook.getTradingProduct().isRolledoutSpreadClass();</TD></TR><TR><TD CLASS="l">1091</TD><TD>             }</TD></TR><TR CLASS="z"><TD CLASS="l">1092</TD><TD>             catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">1093</TD><TD>             {</TD></TR><TR CLASS="z"><TD CLASS="l">1094</TD><TD>                Log.exception(&#34;Failed to get RolledoutSpreadClass flag for class: &#34; + orderBook.getTradingProduct().getTradingClass().getClassSymbol(), e);</TD></TR><TR><TD CLASS="l">1095</TD><TD>             }</TD></TR><TR CLASS="z"><TD CLASS="l">1096</TD><TD>             if (isRolledoutSpreadClass) {</TD></TR><TR CLASS="z"><TD CLASS="l">1097</TD><TD>                 String[] pmmFirms = new String[preferredFirm.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>                 for (int i=0; i&lt;preferredFirm.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>                     pmmFirms[i] = preferredFirm.get(i).toString();</TD></TR><TR><TD CLASS="l">1100</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">1101</TD><TD>                 PMMDetailsStruct[] pmmDetails = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1102</TD><TD>                 OrderRoutingParameterStruct ors = StrategyTradeServiceHelper.getOrderRoutingParameterStructForSpreadEnalbed(orderBook.getTradingProduct());</TD></TR><TR><TD CLASS="l">1103</TD><TD>                 try {</TD></TR><TR CLASS="z"><TD CLASS="l">1104</TD><TD>                                 pmmDetails = getOrderRoutingDestinationService().setAndGetPMMDetails(ors, order.getStruct(), pmmFirms);</TD></TR><TR><TD CLASS="l">1105</TD><TD>                 } </TD></TR><TR CLASS="z"><TD CLASS="l">1106</TD><TD>                 catch(DataValidationException dve)</TD></TR><TR><TD CLASS="l">1107</TD><TD>                 {</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>                         Log.information(&#34;setAndGetPMMDetails - Retrying once&#34;);</TD></TR><TR><TD CLASS="l">1109</TD><TD>                         // Sleep for 5 milli-secs and try twice max to get PMM details.</TD></TR><TR CLASS="z"><TD CLASS="l">1110</TD><TD>                         boolean retry = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1111</TD><TD>                         int i = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1112</TD><TD>                         while(retry &amp;&amp; i &lt; 3)</TD></TR><TR><TD CLASS="l">1113</TD><TD>                         { </TD></TR><TR CLASS="z"><TD CLASS="l">1114</TD><TD>                                 retry = false;</TD></TR><TR><TD CLASS="l">1115</TD><TD>                                 try {</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                                         Thread.sleep(5); </TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>                                         pmmDetails = getOrderRoutingDestinationService().setAndGetPMMDetails(ors, order.getStruct(), pmmFirms);</TD></TR><TR><TD CLASS="l">1118</TD><TD>                                     } </TD></TR><TR CLASS="z"><TD CLASS="l">1119</TD><TD>                                 catch(DataValidationException de) {</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>                                         i++; retry = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>                                         if(i &lt;= 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1122</TD><TD>                                                 Log.information(&#34;setAndGetPMMDetails - Retrying :&#34; + i);</TD></TR><TR><TD CLASS="l">1123</TD><TD>                                         }</TD></TR><TR><TD CLASS="l">1124</TD><TD>                                         else {</TD></TR><TR CLASS="z"><TD CLASS="l">1125</TD><TD>                                                 Log.exception(&#34;Retried Thrice - Call to HTS to get PMMDetails failed for spread product: &#34; + orderBook.getProductKey(), de);</TD></TR><TR><TD CLASS="l">1126</TD><TD>                                         }</TD></TR><TR><TD CLASS="l">1127</TD><TD>                                     }</TD></TR><TR CLASS="z"><TD CLASS="l">1128</TD><TD>                                 catch (Exception ex) {</TD></TR><TR CLASS="z"><TD CLASS="l">1129</TD><TD>                                         Log.exception(&#34;Call to HTS to get PMMDetails failed for spread product: &#34; + orderBook.getProductKey(), ex);</TD></TR><TR><TD CLASS="l">1130</TD><TD>                                 }</TD></TR><TR><TD CLASS="l">1131</TD><TD>                         }</TD></TR><TR><TD CLASS="l">1132</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">1133</TD><TD>                 catch (Exception e)</TD></TR><TR><TD CLASS="l">1134</TD><TD>                 {</TD></TR><TR CLASS="z"><TD CLASS="l">1135</TD><TD>                    Log.exception(&#34;Call to HTS to get PMMDetails failed for spread product: &#34; + orderBook.getProductKey(), e);</TD></TR><TR><TD CLASS="l">1136</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>                 if(pmmDetails != null )</TD></TR><TR><TD CLASS="l">1138</TD><TD>                                 {</TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>                                        convertPmmStructToMap( capDetails, pmmDetails);</TD></TR><TR><TD CLASS="l">1140</TD><TD>                                 }</TD></TR><TR><TD CLASS="l">1141</TD><TD>                  }  </TD></TR><TR><TD CLASS="l">1142</TD><TD>             else {</TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>                 for(TradingStrategyLeg tLeg : tLegs)</TD></TR><TR><TD CLASS="l">1144</TD><TD>                 {</TD></TR><TR CLASS="z"><TD CLASS="l">1145</TD><TD>                         if(tLeg.getTradingProduct() != null &amp;&amp; !tLeg.getTradingProduct().isProxy()&amp;&amp; </TD></TR><TR CLASS="z"><TD CLASS="l">1146</TD><TD>                            tLeg.getTradingProduct().getTradingClass().getProductType() == ProductTypes.OPTION)</TD></TR><TR><TD CLASS="l">1147</TD><TD>                         {</TD></TR><TR><TD CLASS="l">1148</TD><TD>                                                //Find the side of the leg that will trade with the spread if spread to leg trade happens.</TD></TR><TR CLASS="z"><TD CLASS="l">1149</TD><TD>                                                if(order.getSide().isAsDefinedSide())</TD></TR><TR><TD CLASS="l">1150</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1151</TD><TD>                                                        legSideToTrade = tLeg.getSide().getOtherSide();</TD></TR><TR><TD CLASS="l">1152</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1153</TD><TD>                                                else</TD></TR><TR><TD CLASS="l">1154</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1155</TD><TD>                                                        legSideToTrade = tLeg.getSide();</TD></TR><TR><TD CLASS="l">1156</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1157</TD><TD>                                                BestBook bestBook = tLeg.getTradingProduct().getOrderBook().getBestBook();</TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>                                                if(legSideToTrade.isBuySide())</TD></TR><TR><TD CLASS="l">1159</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1160</TD><TD>                                                        legSideBestPrice = bestBook.getContingentBidPrice();</TD></TR><TR><TD CLASS="l">1161</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1162</TD><TD>                                                else</TD></TR><TR><TD CLASS="l">1163</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>                                                        legSideBestPrice = bestBook.getContingentAskPrice();</TD></TR><TR><TD CLASS="l">1165</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1166</TD><TD>                                                //populate the cap details for this leg.</TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                        populatePMMCapDetailsForTradingProduct(tLeg.getTradingProduct().getOrderBook(), legSideToTrade, legSideBestPrice, capDetails, preferredFirm);</TD></TR><TR><TD CLASS="l">1168</TD><TD>                    }  </TD></TR><TR><TD CLASS="l">1169</TD><TD>                 }                </TD></TR><TR><TD CLASS="l">1170</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1171</TD><TD>             </TD></TR><TR><TD CLASS="l">1172</TD><TD>           // 2.  cap details for the spread.</TD></TR><TR CLASS="z"><TD CLASS="l">1173</TD><TD>                 BestBook bestSpreadBook = orderBook.getBestBook();</TD></TR><TR CLASS="z"><TD CLASS="l">1174</TD><TD>                 Side orderSide = order.getSide();</TD></TR><TR><TD CLASS="l">1175</TD><TD>            Price otherSideBestPrice;</TD></TR><TR><TD CLASS="l">1176</TD><TD>             //Find the best price on the opposide side of the order.</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>                 if (orderSide.isAsDefinedSide()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1178</TD><TD>                          otherSideBestPrice = bestSpreadBook.getContingentAskPrice();</TD></TR><TR><TD CLASS="l">1179</TD><TD>             }</TD></TR><TR><TD CLASS="l">1180</TD><TD>             else {</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>                      otherSideBestPrice = bestSpreadBook.getContingentBidPrice();</TD></TR><TR><TD CLASS="l">1182</TD><TD>             }</TD></TR><TR><TD CLASS="l">1183</TD><TD>                 </TD></TR><TR><TD CLASS="l">1184</TD><TD>                 //populate cap details for the strategy product.</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                 populatePMMCapDetailsForTradingProduct(orderBook,auction.getSide().getOtherSide(),otherSideBestPrice,capDetails,preferredFirm);</TD></TR><TR><TD CLASS="l">1186</TD><TD>                 </TD></TR><TR><TD CLASS="l">1187</TD><TD>                 //create the map that will hold the firm-quantity details for rpt trade</TD></TR><TR CLASS="z"><TD CLASS="l">1188</TD><TD>                 acronymCapQtyMapForCOAResponses = createPMMCapDetailsForAuctionResponses(capDetails);</TD></TR><TR><TD CLASS="l">1189</TD><TD>                 </TD></TR><TR><TD CLASS="l">1190</TD><TD>                 // 3. cap details for PMM entitlement for RFP .</TD></TR><TR CLASS="z"><TD CLASS="l">1191</TD><TD>                 auction.setPMMCapDetailsForRfpCOATrade(acronymCapQtyMapForCOAResponses);</TD></TR><TR><TD CLASS="l">1192</TD><TD> </TD></TR><TR><TD CLASS="l">1193</TD><TD>                 // set the cap details in the auction for the legs and the Spread products.</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>                 auction.setPMMCapDetailsForCOATrade(capDetails);</TD></TR><TR><TD CLASS="l">1195</TD><TD> </TD></TR><TR><TD CLASS="l">1196</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1197</TD><TD>    }</TD></TR><TR><TD CLASS="l">1198</TD><TD>    </TD></TR><TR><TD CLASS="l">1199</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="2e">1200</A></TD><TD>     * Gets the top of book tradable from orderbook and populates the &#34;Acronym:CapQty&#34; Map.</TD></TR><TR><TD CLASS="l">1201</TD><TD>     */</TD></TR><TR><TD CLASS="l">1202</TD><TD>    private void populatePMMCapDetailsForTradingProduct(OrderBook orderBook,Side side,Price price, HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt; capDetails, List preferredFirm)</TD></TR><TR><TD CLASS="l">1203</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>            Enumeration topOfBookTradables = orderBook.getTradables(side, price);</TD></TR><TR><TD CLASS="l">1205</TD><TD>            //Map of userid and cap qty.</TD></TR><TR CLASS="z"><TD CLASS="l">1206</TD><TD>            HashMap&lt;String,Integer&gt; acronymCapQtyMap = new HashMap&lt;String, Integer&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1207</TD><TD>            while (topOfBookTradables.hasMoreElements())</TD></TR><TR><TD CLASS="l">1208</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1209</TD><TD>             Tradable tradable = (Tradable) topOfBookTradables.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">1210</TD><TD>             String pFirm = isPreferred(preferredFirm, tradable);</TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>             if ( pFirm!=null &amp;&amp; (tradable.treatedLikeQuote()))</TD></TR><TR><TD CLASS="l">1212</TD><TD>             {</TD></TR><TR CLASS="z"><TD CLASS="l">1213</TD><TD>                 Integer value = (Integer)acronymCapQtyMap.get(pFirm);</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>                 int qty = value != null ? value.intValue():0;</TD></TR><TR CLASS="z"><TD CLASS="l">1215</TD><TD>                 acronymCapQtyMap.put(pFirm, new Integer(tradable.getQuantityAllowed() + qty));</TD></TR><TR><TD CLASS="l">1216</TD><TD>             }</TD></TR><TR><TD CLASS="l">1217</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>         capDetails.put(orderBook.getProductKey(), acronymCapQtyMap);</TD></TR><TR CLASS="z"><TD CLASS="l">1219</TD><TD>    }</TD></TR><TR><TD CLASS="l">1220</TD><TD>    </TD></TR><TR><TD CLASS="l">1221</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1222</TD><TD>     * Use the PmmsDetailsStruct to populate the cap details into the hashmap.</TD></TR><TR><TD CLASS="l">1223</TD><TD>     * @param capDetails</TD></TR><TR><TD CLASS="l"><A NAME="8">1224</A></TD><TD>     * @param pmmDetails</TD></TR><TR><TD CLASS="l">1225</TD><TD>     */</TD></TR><TR><TD CLASS="l">1226</TD><TD>    private void convertPmmStructToMap(HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt; capDetails,  PMMDetailsStruct[] pmmDetails)</TD></TR><TR><TD CLASS="l">1227</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1228</TD><TD>        if (pmmDetails.length == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1229</TD><TD>            return;</TD></TR><TR CLASS="z"><TD CLASS="l">1230</TD><TD>            for(int productCount =0;productCount&lt;pmmDetails.length;productCount++)</TD></TR><TR><TD CLASS="l">1231</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1232</TD><TD>                    HashMap&lt;String,Integer&gt; FirmQtyMap = new HashMap&lt;String, Integer&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1233</TD><TD>                    String[] preferredFirms = pmmDetails[productCount].preferredFirms;</TD></TR><TR CLASS="z"><TD CLASS="l">1234</TD><TD>                    int[] quantities = pmmDetails[productCount].quantities;</TD></TR><TR CLASS="z"><TD CLASS="l">1235</TD><TD>                    for(int firmCount =0; firmCount&lt;preferredFirms.length;firmCount++)</TD></TR><TR><TD CLASS="l">1236</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1237</TD><TD>                            FirmQtyMap.put(preferredFirms[firmCount], quantities[firmCount]);</TD></TR><TR><TD CLASS="l">1238</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>                    capDetails.put(pmmDetails[productCount].productKey, FirmQtyMap);</TD></TR><TR><TD CLASS="l">1240</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1241</TD><TD>    }</TD></TR><TR><TD CLASS="l">1242</TD><TD>    </TD></TR><TR><TD CLASS="l">1243</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1244</TD><TD>     * Use the capDetailsMap to populate the PMM cap details for RFP trades.</TD></TR><TR><TD CLASS="l">1245</TD><TD>     * @param capDetailsMap</TD></TR><TR><TD CLASS="l"><A NAME="9">1246</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1247</TD><TD>     */</TD></TR><TR><TD CLASS="l">1248</TD><TD>    private HashMap&lt;String, Integer&gt; createPMMCapDetailsForAuctionResponses(HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt; capDetailsMap)</TD></TR><TR><TD CLASS="l">1249</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>            HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1251</TD><TD>            if (capDetailsMap == null || capDetailsMap.size() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>                    return map;</TD></TR><TR><TD CLASS="l">1253</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">1254</TD><TD>            for (Integer key : capDetailsMap.keySet()) </TD></TR><TR><TD CLASS="l">1255</TD><TD>            { </TD></TR><TR CLASS="z"><TD CLASS="l">1256</TD><TD>            HashMap&lt;String, Integer&gt; valueDetails = capDetailsMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>            Object[] firmsObjectArray = valueDetails.keySet().toArray();</TD></TR><TR CLASS="z"><TD CLASS="l">1258</TD><TD>            String[] firmsArray = new String[firmsObjectArray.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1259</TD><TD>            for (int i=0; i&lt;firmsObjectArray.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1260</TD><TD>                firmsArray[i] = firmsObjectArray[i].toString();</TD></TR><TR><TD CLASS="l">1261</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>            for (int i=0; i&lt;firmsArray.length; i++) </TD></TR><TR><TD CLASS="l">1263</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1264</TD><TD>                    Integer value = map.get(firmsArray[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1265</TD><TD>                    if(value == null || value.intValue()==0)</TD></TR><TR><TD CLASS="l">1266</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1267</TD><TD>                            map.put(firmsArray[i], valueDetails.get(firmsArray[i]));</TD></TR><TR><TD CLASS="l">1268</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1269</TD><TD>                    else</TD></TR><TR><TD CLASS="l">1270</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1271</TD><TD>                            map.put(firmsArray[i], Math.max(value, valueDetails.get(firmsArray[i])));</TD></TR><TR><TD CLASS="l">1272</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1273</TD><TD>            }</TD></TR><TR><TD CLASS="l">1274</TD><TD>        }</TD></TR><TR><TD CLASS="l">1275</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">1276</TD><TD>            return map;</TD></TR><TR><TD CLASS="l">1277</TD><TD>    }</TD></TR><TR><TD CLASS="l">1278</TD><TD>     </TD></TR><TR><TD CLASS="l">1279</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1280</TD><TD>     * Checks if the given tradable is from a PMM</TD></TR><TR><TD CLASS="l">1281</TD><TD>     * @param tieredPdmp</TD></TR><TR><TD CLASS="l">1282</TD><TD>     * @param tradable</TD></TR><TR><TD CLASS="l"><A NAME="28">1283</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1284</TD><TD>     */</TD></TR><TR><TD CLASS="l">1285</TD><TD>    protected String isPreferred(List tieredPdmp, Tradable tradable)</TD></TR><TR><TD CLASS="l">1286</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1287</TD><TD>        for (int i=0; i&lt; tieredPdmp.size(); i++)</TD></TR><TR><TD CLASS="l">1288</TD><TD>        {</TD></TR><TR><TD CLASS="l">1289</TD><TD>                try</TD></TR><TR><TD CLASS="l">1290</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1291</TD><TD>            String userAcr = tradable.getOriginatorAcronym().acronym;</TD></TR><TR CLASS="z"><TD CLASS="l">1292</TD><TD>            if ( isThisAcrPreferred( userAcr, (String) tieredPdmp.get(i)) )</TD></TR><TR><TD CLASS="l">1293</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1294</TD><TD>                return (String)tieredPdmp.get(i);</TD></TR><TR><TD CLASS="l">1295</TD><TD>            }</TD></TR><TR><TD CLASS="l">1296</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1297</TD><TD>                catch(UnsupportedOperationException uoe)</TD></TR><TR><TD CLASS="l">1298</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1299</TD><TD>                  Log.information(&#34;BrokerProcessorSpreadHybridImpl - Unsupported exception - &#34; + uoe.getMessage());</TD></TR><TR><TD CLASS="l">1300</TD><TD>            }</TD></TR><TR><TD CLASS="l">1301</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1302</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">1303</TD><TD>    }</TD></TR><TR><TD CLASS="l">1304</TD><TD>    </TD></TR><TR><TD CLASS="l">1305</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1306</TD><TD>     * Checks if the given tradable is from a PMM</TD></TR><TR><TD CLASS="l">1307</TD><TD>     * @param userAcronym</TD></TR><TR><TD CLASS="l">1308</TD><TD>     * @param firm</TD></TR><TR><TD CLASS="l"><A NAME="2c">1309</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1310</TD><TD>     */</TD></TR><TR><TD CLASS="l">1311</TD><TD>    protected boolean isThisAcrPreferred( String userAcronym, String firm )</TD></TR><TR><TD CLASS="l">1312</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1313</TD><TD>        UserFirmAffiliationStruct[] pDpms = getUsersForAffiliatedFirm(firm.trim());</TD></TR><TR><TD CLASS="l">1314</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1315</TD><TD>        boolean result = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1316</TD><TD>        for (int i = 0; i &lt; pDpms.length; i++)</TD></TR><TR><TD CLASS="l">1317</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>            if (userAcronym.equals(pDpms[i].userAcronym.acronym))</TD></TR><TR><TD CLASS="l">1319</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1320</TD><TD>                result = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>                break;</TD></TR><TR><TD CLASS="l">1322</TD><TD>            }</TD></TR><TR><TD CLASS="l">1323</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1325</TD><TD>    }</TD></TR><TR><TD CLASS="l">1326</TD><TD> </TD></TR><TR><TD CLASS="l">1327</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1328</TD><TD>     * Get users affiliated to a firm</TD></TR><TR><TD CLASS="l">1329</TD><TD>     * @param firm</TD></TR><TR><TD CLASS="l"><A NAME="20">1330</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1331</TD><TD>     */</TD></TR><TR><TD CLASS="l">1332</TD><TD>    protected UserFirmAffiliationStruct[] getUsersForAffiliatedFirm(String firm)</TD></TR><TR><TD CLASS="l">1333</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1334</TD><TD>        UserFirmAffiliationStruct[] userFirmAffiliations = null;</TD></TR><TR><TD CLASS="l">1335</TD><TD>        try</TD></TR><TR><TD CLASS="l">1336</TD><TD>        {</TD></TR><TR><TD CLASS="l">1337</TD><TD>            //This call should not be too expensive since it should be cached in this process.</TD></TR><TR CLASS="z"><TD CLASS="l">1338</TD><TD>            userFirmAffiliations = getUserMaintenanceService().getUsersForAffiliatedFirm(firm);</TD></TR><TR><TD CLASS="l">1339</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">1341</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1342</TD><TD>            Log.alarm(&#34;Unable to get firm affiliations - assuming that there aren't any&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>            userFirmAffiliations = new UserFirmAffiliationStruct[0];</TD></TR><TR><TD CLASS="l">1344</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1345</TD><TD>        return userFirmAffiliations;</TD></TR><TR><TD CLASS="l">1346</TD><TD>    }</TD></TR><TR><TD CLASS="l">1347</TD><TD> </TD></TR><TR><TD CLASS="l">1348</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1349</TD><TD>     * Get the UserMaintenanceService</TD></TR><TR><TD CLASS="l"><A NAME="1f">1350</A></TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1351</TD><TD>     */</TD></TR><TR><TD CLASS="l">1352</TD><TD>    protected static UserMaintenanceService getUserMaintenanceService()</TD></TR><TR><TD CLASS="l">1353</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1354</TD><TD>        if (userMaintenanceService != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1355</TD><TD>          return userMaintenanceService;</TD></TR><TR><TD CLASS="l">1356</TD><TD> </TD></TR><TR><TD CLASS="l">1357</TD><TD>        try</TD></TR><TR><TD CLASS="l">1358</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1359</TD><TD>            UserMaintenanceServiceHome serviceHome = (UserMaintenanceServiceHome)HomeFactory.getInstance().findHome(UserMaintenanceServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>            userMaintenanceService = serviceHome.find();</TD></TR><TR><TD CLASS="l">1361</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>        catch( CBOELoggableException e )</TD></TR><TR><TD CLASS="l">1363</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1364</TD><TD>            Log.exception(&#34;Failed to find UserMaintenanceService&#34;, e);</TD></TR><TR><TD CLASS="l">1365</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1366</TD><TD>        return userMaintenanceService;</TD></TR><TR><TD CLASS="l">1367</TD><TD>    }</TD></TR><TR><TD CLASS="l">1368</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1369</TD><TD>     * When there is an active auction on the product, the handling of incoming order will be</TD></TR><TR><TD CLASS="l">1370</TD><TD>     * different depending on the side of the order.</TD></TR><TR><TD CLASS="l">1371</TD><TD>     */</TD></TR><TR><TD CLASS="l">1372</TD><TD>    private void processOrderWithActiveAuction(Order order, AuctionInternal activeAuction, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1373</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1374</TD><TD>    {</TD></TR><TR><TD CLASS="l">1375</TD><TD>        /*</TD></TR><TR><TD CLASS="l">1376</TD><TD>        // if buy_write product, invoke a different method</TD></TR><TR><TD CLASS="l">1377</TD><TD>        if (activeAuction.getAuctionBook().getTradingProduct().isBuyWrite()) {</TD></TR><TR><TD CLASS="l"><A NAME="3b">1378</A></TD><TD>            processOrderWithCrossProductActiveAuction(order, activeAuction, orderBook);</TD></TR><TR><TD CLASS="l">1379</TD><TD>            return;</TD></TR><TR><TD CLASS="l">1380</TD><TD>        }</TD></TR><TR><TD CLASS="l">1381</TD><TD>        */</TD></TR><TR CLASS="z"><TD CLASS="l">1382</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1383</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1384</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::processOrderWithActiveAuction&#34;);</TD></TR><TR><TD CLASS="l">1385</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1386</TD><TD>        if (shouldExpireDueToIncomingTradable(activeAuction,order)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1387</TD><TD>            cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">1388</TD><TD>            getSpreadAuctionProcessor(order.getProductKey()).endAuctionByIncomingTradable(activeAuction, order, AuctionTerminateReasons.ORDER_MARKETABLE_AGAINST_AUCTION);</TD></TR><TR CLASS="z"><TD CLASS="l">1389</TD><TD>            performPostAuctionProcessing(activeAuction);</TD></TR><TR CLASS="z"><TD CLASS="l">1390</TD><TD>            if (order.getQuantityAllowed() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1391</TD><TD>                processOrderWithoutActiveAuction(order, orderBook);</TD></TR><TR><TD CLASS="l">1392</TD><TD>            }</TD></TR><TR><TD CLASS="l">1393</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>        else if (shouldJoin(activeAuction, order)){</TD></TR><TR CLASS="z"><TD CLASS="l">1395</TD><TD>            getSpreadAuctionProcessor(activeAuction.getProductKey()).joinActiveAuction(activeAuction, order);</TD></TR><TR><TD CLASS="l">1396</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1397</TD><TD>    }</TD></TR><TR><TD CLASS="l">1398</TD><TD> </TD></TR><TR><TD CLASS="l">1399</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1400</TD><TD>     * When there is an active auction on the product, the handling of incoming order will be</TD></TR><TR><TD CLASS="l">1401</TD><TD>     * different depending on the side of the order.</TD></TR><TR><TD CLASS="l">1402</TD><TD>     */</TD></TR><TR><TD CLASS="l">1403</TD><TD>    /*</TD></TR><TR><TD CLASS="l">1404</TD><TD>    private void processOrderWithCrossProductActiveAuction(Order order, AuctionInternal activeAuction, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1405</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1406</TD><TD>    {</TD></TR><TR><TD CLASS="l">1407</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1408</TD><TD>        {</TD></TR><TR><TD CLASS="l">1409</TD><TD>            Log.debug(&#34;Inside the method BrokerProcessorSpreadHybridImpl::processOrderWithCrossProductActiveAuction&#34;);</TD></TR><TR><TD CLASS="l">1410</TD><TD>        }</TD></TR><TR><TD CLASS="l">1411</TD><TD>        if (shouldExpireDueToIncomingTradable(activeAuction,order) ||</TD></TR><TR><TD CLASS="l">1412</TD><TD>                shouldJoin(activeAuction, order)) {</TD></TR><TR><TD CLASS="l">1413</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1414</TD><TD>            {</TD></TR><TR><TD CLASS="l">1415</TD><TD>                Log.debug(&#34;Auction to be expired.&#34;);</TD></TR><TR><TD CLASS="l">1416</TD><TD>            }</TD></TR><TR><TD CLASS="l">1417</TD><TD>            // if auction needs to be expired, the same side incoming order won't participate</TD></TR><TR><TD CLASS="l">1418</TD><TD>            // the trade, but the opposite side incoming tradable will participate the trade</TD></TR><TR><TD CLASS="l">1419</TD><TD>            // this is done due to the limitation on equity remote leg trade </TD></TR><TR><TD CLASS="l">1420</TD><TD>            if (order.getSide().isSameSide(activeAuction.getSide())) {</TD></TR><TR><TD CLASS="l">1421</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1422</TD><TD>                {</TD></TR><TR><TD CLASS="l">1423</TD><TD>                    Log.debug(&#34;Auction expired by the same side order.&#34;);</TD></TR><TR><TD CLASS="l">1424</TD><TD>                }</TD></TR><TR><TD CLASS="l">1425</TD><TD>                processAuctionExpire(activeAuction, AuctionTerminateReasons.QUOTE_MARKETABLE_AGAINST_AUCTION, order);</TD></TR><TR><TD CLASS="l">1426</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">1427</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1428</TD><TD>                {</TD></TR><TR><TD CLASS="l">1429</TD><TD>                    Log.debug(&#34;Auction expired by the opposite side order.&#34;);</TD></TR><TR><TD CLASS="l">1430</TD><TD>                }</TD></TR><TR><TD CLASS="l">1431</TD><TD>                cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR><TD CLASS="l">1432</TD><TD>                getSpreadAuctionProcessor().endAuctionByIncomingTradable(activeAuction, order, AuctionTerminateReasons.QUOTE_MARKETABLE_AGAINST_AUCTION);</TD></TR><TR><TD CLASS="l">1433</TD><TD>                performPostAuctionProcessing(activeAuction);</TD></TR><TR><TD CLASS="l">1434</TD><TD>            }</TD></TR><TR><TD CLASS="l">1435</TD><TD>            if (order.getQuantityAllowed() &gt; 0) {</TD></TR><TR><TD CLASS="l">1436</TD><TD>                processOrderWithoutActiveAuction(order, orderBook);</TD></TR><TR><TD CLASS="l">1437</TD><TD>            }</TD></TR><TR><TD CLASS="l">1438</TD><TD>        }</TD></TR><TR><TD CLASS="l">1439</TD><TD>    }</TD></TR><TR><TD CLASS="l">1440</TD><TD>    */</TD></TR><TR><TD CLASS="l"><A NAME="31">1441</A></TD><TD>    </TD></TR><TR><TD CLASS="l">1442</TD><TD>    private void preAuctionCleanup(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1443</TD><TD>    throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">1444</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1445</TD><TD>        forceExpireQuoteTrigger(order.getSide(), orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">1446</TD><TD>    }</TD></TR><TR><TD CLASS="l">1447</TD><TD> </TD></TR><TR><TD CLASS="l">1448</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1449</TD><TD>     * force a quote trigger on a leg to expire.</TD></TR><TR><TD CLASS="l">1450</TD><TD>     *</TD></TR><TR><TD CLASS="l">1451</TD><TD>     * Note: after a quote trigger expires, a new quote trigger may start.</TD></TR><TR><TD CLASS="l"><A NAME="15">1452</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1453</TD><TD>     private void forceExpireQuoteTrigger(Side sameSide, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">1454</TD><TD>     throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1455</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">1456</TD><TD>        QuoteTriggerTradable quoteTrigger = orderBook.getQuoteTrigger(sameSide);</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>        Side triggerSide = sameSide;</TD></TR><TR CLASS="z"><TD CLASS="l">1458</TD><TD>        if (quoteTrigger == null ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1459</TD><TD>            quoteTrigger = orderBook.getQuoteTrigger(sameSide.getOtherSide());</TD></TR><TR CLASS="z"><TD CLASS="l">1460</TD><TD>            triggerSide = sameSide.getOtherSide();</TD></TR><TR><TD CLASS="l">1461</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1462</TD><TD>         while (quoteTrigger != null)</TD></TR><TR><TD CLASS="l">1463</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">1464</TD><TD>             processQuoteTriggerExpire(quoteTrigger);</TD></TR><TR CLASS="z"><TD CLASS="l">1465</TD><TD>             quoteTrigger = orderBook.getQuoteTrigger(triggerSide);</TD></TR><TR><TD CLASS="l">1466</TD><TD>         }</TD></TR><TR CLASS="z"><TD CLASS="l">1467</TD><TD>     }</TD></TR><TR><TD CLASS="l">1468</TD><TD> </TD></TR><TR><TD CLASS="l">1469</TD><TD>     /* TODO, remove</TD></TR><TR><TD CLASS="l">1470</TD><TD>    private BrokerProcessorHybridImpl getHybridProcessor(){</TD></TR><TR><TD CLASS="l">1471</TD><TD>        if (hybridProcessor == null) {</TD></TR><TR><TD CLASS="l">1472</TD><TD>            hybridProcessor = new BrokerProcessorHybridImpl();</TD></TR><TR><TD CLASS="l">1473</TD><TD>        }</TD></TR><TR><TD CLASS="l">1474</TD><TD>        return hybridProcessor;</TD></TR><TR><TD CLASS="l">1475</TD><TD>    }</TD></TR><TR><TD CLASS="l">1476</TD><TD>        */</TD></TR><TR><TD CLASS="l">1477</TD><TD> </TD></TR><TR><TD CLASS="l">1478</TD><TD>     /**</TD></TR><TR><TD CLASS="l">1479</TD><TD>      * This is created to replace the one with creating new BrokerProcessorHybridImpl</TD></TR><TR><TD CLASS="l"><A NAME="17">1480</A></TD><TD>      * because new instance of BrokerProcessorNewHALHybridImpl is needed for new HAL</TD></TR><TR><TD CLASS="l">1481</TD><TD>      */</TD></TR><TR><TD CLASS="l">1482</TD><TD>     private BrokerProcessorHybridImpl getHybridProcessor(Integer productKey)</TD></TR><TR><TD CLASS="l">1483</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">1484</TD><TD>         return getHybridProcessor(productKey.intValue());</TD></TR><TR><TD CLASS="l"><A NAME="19">1485</A></TD><TD>     }</TD></TR><TR><TD CLASS="l">1486</TD><TD>     </TD></TR><TR><TD CLASS="l">1487</TD><TD>     private BrokerProcessorHybridImpl getHybridProcessor(int productKey)</TD></TR><TR><TD CLASS="l">1488</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">1489</TD><TD>             BrokerProcessorHybridImpl brokerProcessor = null;</TD></TR><TR><TD CLASS="l">1490</TD><TD>             try {</TD></TR><TR CLASS="z"><TD CLASS="l">1491</TD><TD>                     brokerProcessor = getHybridProcessor(getOrderBook(productKey).getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">1492</TD><TD>                } catch (DataValidationException e) {</TD></TR><TR><TD CLASS="l">1493</TD><TD>                        // TODO Auto-generated catch block</TD></TR><TR CLASS="z"><TD CLASS="l">1494</TD><TD>                        Log.alarm(&#34;Can't find OrderBook for product: &#34; + productKey);</TD></TR><TR><TD CLASS="l">1495</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1496</TD><TD>                return brokerProcessor;</TD></TR><TR><TD CLASS="l"><A NAME="18">1497</A></TD><TD>     }</TD></TR><TR><TD CLASS="l">1498</TD><TD>     </TD></TR><TR><TD CLASS="l">1499</TD><TD>     private BrokerProcessorHybridImpl getHybridProcessor(TradingProduct product)</TD></TR><TR><TD CLASS="l">1500</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">1501</TD><TD>             return (BrokerProcessorHybridImpl)getTradingProductForHybridProcessor(product).getBroker().getProcessor();</TD></TR><TR><TD CLASS="l">1502</TD><TD>     }</TD></TR><TR><TD CLASS="l">1503</TD><TD>     </TD></TR><TR><TD CLASS="l">1504</TD><TD>     /**</TD></TR><TR><TD CLASS="l">1505</TD><TD>      * get proper trading product for BrokerProcessorHybridImpl instance lookup</TD></TR><TR><TD CLASS="l">1506</TD><TD>      * need to avoid getting back BrokerProcessorSpreadHybridImpl when a product</TD></TR><TR><TD CLASS="l">1507</TD><TD>      * is spread</TD></TR><TR><TD CLASS="l"><A NAME="1e">1508</A></TD><TD>      * @param product</TD></TR><TR><TD CLASS="l">1509</TD><TD>      * @return</TD></TR><TR><TD CLASS="l">1510</TD><TD>      */</TD></TR><TR><TD CLASS="l">1511</TD><TD>     private TradingProduct getTradingProductForHybridProcessor(TradingProduct product){</TD></TR><TR CLASS="z"><TD CLASS="l">1512</TD><TD>             TradingProduct theProduct = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1513</TD><TD>         if (product.getTradingClass().getProductType() == ProductTypes.STRATEGY) {</TD></TR><TR><TD CLASS="l">1514</TD><TD>                 // need to get BPHI for strategy's leg</TD></TR><TR CLASS="z"><TD CLASS="l">1515</TD><TD>                 TradingStrategyLeg[] legs = product.getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">1516</TD><TD>                 for (TradingStrategyLeg leg : legs) {</TD></TR><TR CLASS="z"><TD CLASS="l">1517</TD><TD>                         if (leg.getTradingProduct() != null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">1518</TD><TD>                                         leg.getTradingProduct().getTradingClass().getProductType() == ProductTypes.OPTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">1519</TD><TD>                                 theProduct = leg.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">1520</TD><TD>                                 break;</TD></TR><TR><TD CLASS="l">1521</TD><TD>                         }</TD></TR><TR><TD CLASS="l">1522</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">1523</TD><TD>                 if (theProduct == null) {</TD></TR><TR><TD CLASS="l">1524</TD><TD>                     // this should not happen</TD></TR><TR CLASS="z"><TD CLASS="l">1525</TD><TD>                     Log.alarm(&#34;Can't find option leg product for strategy product: &#34; + product.getProductKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1526</TD><TD>                     throw new IllegalArgumentException(&#34;Can't find option leg product for strategy product: &#34; + product.getProductKey());</TD></TR><TR><TD CLASS="l">1527</TD><TD>             }</TD></TR><TR><TD CLASS="l">1528</TD><TD>         } else {</TD></TR><TR><TD CLASS="l">1529</TD><TD>                 // for option product</TD></TR><TR CLASS="z"><TD CLASS="l">1530</TD><TD>                 theProduct = product;</TD></TR><TR><TD CLASS="l">1531</TD><TD>         }</TD></TR><TR><TD CLASS="l">1532</TD><TD>         </TD></TR><TR CLASS="z"><TD CLASS="l">1533</TD><TD>         return theProduct;</TD></TR><TR><TD CLASS="l">1534</TD><TD>     }</TD></TR><TR><TD CLASS="l">1535</TD><TD>     </TD></TR><TR><TD CLASS="l">1536</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="1c">1537</A></TD><TD>     * Determine if an order should be returned. Appropriate return code is returnd. If an order should</TD></TR><TR><TD CLASS="l">1538</TD><TD>     * not be returned, a return code = -1 is returned</TD></TR><TR><TD CLASS="l">1539</TD><TD>     */</TD></TR><TR><TD CLASS="l">1540</TD><TD>    private short getReturnCodeForOrder(Order order) {</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>        short returnCode = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1542</TD><TD>        HandlingInstruction instruction = order.getHandlingInstruction();</TD></TR><TR CLASS="z"><TD CLASS="l">1543</TD><TD>        if (order.getRemainingQuantity() &lt;= 0 || instruction == null || order.treatedLikeQuote())</TD></TR><TR><TD CLASS="l">1544</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1545</TD><TD>            return returnCode;</TD></TR><TR><TD CLASS="l">1546</TD><TD>        }</TD></TR><TR><TD CLASS="l">1547</TD><TD> </TD></TR><TR><TD CLASS="l">1548</TD><TD>        // If reason code for Index Hybrid has been set, return this reason code.</TD></TR><TR CLASS="z"><TD CLASS="l">1549</TD><TD>        if(instruction.isOrderReturnReasonSetForIndexHybrid()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1550</TD><TD>            return instruction.getOverRideReasonForIndexHybrid();</TD></TR><TR><TD CLASS="l">1551</TD><TD>        }</TD></TR><TR><TD CLASS="l">1552</TD><TD>        </TD></TR><TR><TD CLASS="l">1553</TD><TD>        // always return the order if is PAR T/A</TD></TR><TR CLASS="z"><TD CLASS="l">1554</TD><TD>        if ( instruction.getTradingRestriction() == TradingRestrictions.PAR_TRADE_ALL || </TD></TR><TR CLASS="z"><TD CLASS="l">1555</TD><TD>             instruction.getTradingRestriction() == TradingRestrictions.NON_Q_ONLY )</TD></TR><TR><TD CLASS="l">1556</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1557</TD><TD>            return determinePARTAOrderReturnCode(order, instruction);</TD></TR><TR><TD CLASS="l">1558</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1559</TD><TD>        else if (order.getPrice().isMarketPrice()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1560</TD><TD>            returnCode = determineMarketOrderReturnCode(order, instruction);</TD></TR><TR><TD CLASS="l">1561</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1562</TD><TD>        else if (instruction.getTradingRestriction() == TradingRestrictions.PAR_AUCTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">1563</TD><TD>            returnCode = determinePAuctionReturnCode(order, instruction);</TD></TR><TR><TD CLASS="l">1564</TD><TD>        }</TD></TR><TR><TD CLASS="l">1565</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1566</TD><TD>            returnCode = determineLimitOrderReturnCode(order, instruction);</TD></TR><TR><TD CLASS="l">1567</TD><TD>        }</TD></TR><TR><TD CLASS="l">1568</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1569</TD><TD>        if(Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1570</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;getReturnCodeForOrder. order/returnCode=&#34; + order + &#34;/&#34; + returnCode);</TD></TR><TR><TD CLASS="l">1571</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1572</TD><TD>        return returnCode;</TD></TR><TR><TD CLASS="l">1573</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="c">1574</A></TD><TD>    </TD></TR><TR><TD CLASS="l">1575</TD><TD>    private short determinePARTAOrderReturnCode(Order order, HandlingInstruction instruction)</TD></TR><TR><TD CLASS="l">1576</TD><TD>    {</TD></TR><TR><TD CLASS="l">1577</TD><TD>        short returnCode;</TD></TR><TR CLASS="z"><TD CLASS="l">1578</TD><TD>        int tradedQuantity = instruction.getOrderQuantityReceived() - order.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1579</TD><TD>        int maxVolume = instruction.getMaximumExecutionVolume();</TD></TR><TR CLASS="z"><TD CLASS="l">1580</TD><TD>        if ( tradedQuantity != 0 &amp;&amp; tradedQuantity == maxVolume)</TD></TR><TR><TD CLASS="l">1581</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1582</TD><TD>            returnCode = OrderRoutingReasons.COMPLETED_INSTRUCTIONS;</TD></TR><TR><TD CLASS="l">1583</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1584</TD><TD>        else if( tradedQuantity != 0 &amp;&amp; tradedQuantity &lt; maxVolume)</TD></TR><TR><TD CLASS="l">1585</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1586</TD><TD>            returnCode = OrderRoutingReasons.PARTIALLY_TRADED;</TD></TR><TR><TD CLASS="l">1587</TD><TD>        }</TD></TR><TR><TD CLASS="l">1588</TD><TD>        else</TD></TR><TR><TD CLASS="l">1589</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1590</TD><TD>            returnCode = OrderRoutingReasons.NOT_TRADED_EXEC_PRICE;</TD></TR><TR><TD CLASS="l">1591</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1592</TD><TD>        return returnCode;</TD></TR><TR><TD CLASS="l"><A NAME="b">1593</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1594</TD><TD>    </TD></TR><TR><TD CLASS="l">1595</TD><TD>    private short determineMarketOrderReturnCode(Order order, HandlingInstruction instruction)</TD></TR><TR><TD CLASS="l">1596</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>        if (instruction.getReturnedCode() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1598</TD><TD>            return instruction.getReturnedCode();</TD></TR><TR><TD CLASS="l">1599</TD><TD>        }</TD></TR><TR><TD CLASS="l">1600</TD><TD> </TD></TR><TR><TD CLASS="l">1601</TD><TD>        short returnCode;</TD></TR><TR CLASS="z"><TD CLASS="l">1602</TD><TD>        int tradedQuantity = instruction.getOrderQuantityReceived() - order.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1603</TD><TD>        if(instruction.getTradingRestriction() == TradingRestrictions.AUCTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">1604</TD><TD>            if (tradedQuantity != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1605</TD><TD>                returnCode = OrderRoutingReasons.PARTIALLY_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1606</TD><TD>            }</TD></TR><TR><TD CLASS="l">1607</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">1608</TD><TD>                returnCode = OrderRoutingReasons.NOT_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1609</TD><TD>            }</TD></TR><TR><TD CLASS="l">1610</TD><TD>        }</TD></TR><TR><TD CLASS="l">1611</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1612</TD><TD>            if (tradedQuantity != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1613</TD><TD>                returnCode = OrderRoutingReasons.PARTIALLY_TRADED;</TD></TR><TR><TD CLASS="l">1614</TD><TD>            }</TD></TR><TR><TD CLASS="l">1615</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">1616</TD><TD>                returnCode = OrderRoutingReasons.NOT_TRADED_EXEC_PRICE;</TD></TR><TR><TD CLASS="l">1617</TD><TD>            }</TD></TR><TR><TD CLASS="l">1618</TD><TD>        }</TD></TR><TR><TD CLASS="l">1619</TD><TD>        //Validate CPS order for splitting   </TD></TR><TR CLASS="z"><TD CLASS="l">1620</TD><TD>        int prodKey = order.getProductKey().intValue();</TD></TR><TR><TD CLASS="l">1621</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1622</TD><TD>            OrderBook orderBook = getOrderBook(prodKey);</TD></TR><TR CLASS="z"><TD CLASS="l">1623</TD><TD>            TradingProductImpl product = (TradingProductImpl)orderBook.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">1624</TD><TD>            if(orderBook.getTradingProduct().isBuyWrite() &amp;&amp; </TD></TR><TR CLASS="z"><TD CLASS="l">1625</TD><TD>                            !(orderBook.getTradingProduct().getShortSellTriggerMode()) &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">1626</TD><TD>                            SpreadOrderSplittingHelper.validateOrderForSplitting(order, product))</TD></TR><TR><TD CLASS="l">1627</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1628</TD><TD>                Log.information(&#34;CPS Market Order is validated sucessfully for splitting. ReturnCode : &#34; + </TD></TR><TR><TD CLASS="l">1629</TD><TD>                                        OrderRoutingReasons.CROSS_PRODUCT_ELIGIBLE_FOR_SPLITTING);</TD></TR><TR CLASS="z"><TD CLASS="l">1630</TD><TD>                returnCode = OrderRoutingReasons.CROSS_PRODUCT_ELIGIBLE_FOR_SPLITTING;</TD></TR><TR><TD CLASS="l">1631</TD><TD>            }            </TD></TR><TR CLASS="z"><TD CLASS="l">1632</TD><TD>        } catch (DataValidationException ex) {</TD></TR><TR CLASS="z"><TD CLASS="l">1633</TD><TD>            Log.alarm(&#34;Can't find OrderBook for product: &#34; + prodKey);</TD></TR><TR CLASS="z"><TD CLASS="l">1634</TD><TD>        } catch (SystemException se) {</TD></TR><TR CLASS="z"><TD CLASS="l">1635</TD><TD>            Log.exception(&#34;Exception occured during CPS order splitting validation&#34;, se);</TD></TR><TR CLASS="z"><TD CLASS="l">1636</TD><TD>        } catch (NotFoundException nfe) {</TD></TR><TR CLASS="z"><TD CLASS="l">1637</TD><TD>            Log.exception(&#34;Trading product not found during CPS order splitting validation&#34;, nfe);</TD></TR><TR><TD CLASS="l">1638</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1639</TD><TD>        return returnCode;</TD></TR><TR><TD CLASS="l"><A NAME="a">1640</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1641</TD><TD> </TD></TR><TR><TD CLASS="l">1642</TD><TD>    private short determineLimitOrderReturnCode(Order order, HandlingInstruction instruction)</TD></TR><TR><TD CLASS="l">1643</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1644</TD><TD>        short returnCode = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1645</TD><TD>        int tradedQuantity = instruction.getOrderQuantityReceived() - order.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1646</TD><TD>        Side orderSide = order.getSide();</TD></TR><TR CLASS="z"><TD CLASS="l">1647</TD><TD>        Price executionPrice = instruction.getExecutionPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">1648</TD><TD>        int maxVolume = instruction.getMaximumExecutionVolume();</TD></TR><TR><TD CLASS="l">1649</TD><TD>        try{</TD></TR><TR CLASS="z"><TD CLASS="l">1650</TD><TD>                OrderBook orderBook = getOrderBook(order.getProductKey().intValue());</TD></TR><TR CLASS="z"><TD CLASS="l">1651</TD><TD>                if (orderBook.getTradingProduct().isBuyWrite() &amp;&amp; instruction.getTradingRestriction() == TradingRestrictions.AUCTION)</TD></TR><TR><TD CLASS="l">1652</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1653</TD><TD>                    executionPrice = order.getPrice();</TD></TR><TR><TD CLASS="l">1654</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1655</TD><TD>        }catch(DataValidationException e){</TD></TR><TR><TD CLASS="l">1656</TD><TD>        }</TD></TR><TR><TD CLASS="l">1657</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>        if (! executionPrice.isNoPrice() &amp;&amp; orderSide.isFirstBetter(order.getPrice(), executionPrice) ||</TD></TR><TR CLASS="z"><TD CLASS="l">1659</TD><TD>            maxVolume != 0 &amp;&amp; maxVolume &lt; instruction.getOrderQuantityReceived())</TD></TR><TR><TD CLASS="l">1660</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1661</TD><TD>            if(instruction.getTradingRestriction() == TradingRestrictions.AUCTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">1662</TD><TD>                if (tradedQuantity != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1663</TD><TD>                    returnCode = OrderRoutingReasons.PARTIALLY_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1664</TD><TD>                }</TD></TR><TR><TD CLASS="l">1665</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">1666</TD><TD>                    returnCode = OrderRoutingReasons.NOT_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1667</TD><TD>                }</TD></TR><TR><TD CLASS="l">1668</TD><TD>            }</TD></TR><TR><TD CLASS="l">1669</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">1670</TD><TD>                if (tradedQuantity != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1671</TD><TD>                    returnCode = OrderRoutingReasons.PARTIALLY_TRADED;</TD></TR><TR><TD CLASS="l">1672</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1673</TD><TD>                else if (instruction.getTradingRestriction() == TradingRestrictions.BOOK)</TD></TR><TR><TD CLASS="l">1674</TD><TD>                {</TD></TR><TR><TD CLASS="l">1675</TD><TD>                    //return already set to return  -1, which will book the order</TD></TR><TR><TD CLASS="l">1676</TD><TD>                }</TD></TR><TR><TD CLASS="l">1677</TD><TD>                else</TD></TR><TR><TD CLASS="l">1678</TD><TD>                {</TD></TR><TR><TD CLASS="l">1679</TD><TD>                    // no instruction to book order and order has zero traded quantity</TD></TR><TR CLASS="z"><TD CLASS="l">1680</TD><TD>                    returnCode = OrderRoutingReasons.NOT_TRADED_EXEC_PRICE;</TD></TR><TR><TD CLASS="l">1681</TD><TD>                }</TD></TR><TR><TD CLASS="l">1682</TD><TD>            }</TD></TR><TR><TD CLASS="l">1683</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1684</TD><TD>        else if(instruction.getReturnedCode() == OrderRoutingReasons.ORDER_TOUCHES_LEG_QUOTES)</TD></TR><TR><TD CLASS="l">1685</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1686</TD><TD>            returnCode = OrderRoutingReasons.ORDER_TOUCHES_LEG_QUOTES;</TD></TR><TR><TD CLASS="l">1687</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1688</TD><TD>        else if(tradedQuantity == 0 ) </TD></TR><TR><TD CLASS="l">1689</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1690</TD><TD>            if(instruction.getTradingRestriction() == TradingRestrictions.AUTO_EX) {</TD></TR><TR CLASS="z"><TD CLASS="l">1691</TD><TD>                returnCode = OrderRoutingReasons.NOT_TRADED_EXEC_PRICE;</TD></TR><TR><TD CLASS="l">1692</TD><TD>            }</TD></TR><TR><TD CLASS="l">1693</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1694</TD><TD>        return returnCode;</TD></TR><TR><TD CLASS="l">1695</TD><TD>    }</TD></TR><TR><TD CLASS="l">1696</TD><TD> </TD></TR><TR><TD CLASS="l">1697</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1698</TD><TD>     * Par auction order is always returned.</TD></TR><TR><TD CLASS="l"><A NAME="d">1699</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1700</TD><TD>    private short determinePAuctionReturnCode(Order order, HandlingInstruction instruction)</TD></TR><TR><TD CLASS="l">1701</TD><TD>    {</TD></TR><TR><TD CLASS="l">1702</TD><TD>        short returnCode;</TD></TR><TR CLASS="z"><TD CLASS="l">1703</TD><TD>        int tradedQuantity = instruction.getOrderQuantityReceived() - order.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1704</TD><TD>        if (tradedQuantity != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1705</TD><TD>            returnCode = OrderRoutingReasons.PARTIALLY_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1706</TD><TD>        }</TD></TR><TR><TD CLASS="l">1707</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1708</TD><TD>            returnCode = OrderRoutingReasons.NOT_TRADED_AUCTIONED;</TD></TR><TR><TD CLASS="l">1709</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4e">1710</A></TD><TD>        return returnCode;</TD></TR><TR><TD CLASS="l">1711</TD><TD>    }</TD></TR><TR><TD CLASS="l">1712</TD><TD> </TD></TR><TR><TD CLASS="l">1713</TD><TD>    public void setBroker(Broker aBroker){</TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>        super.setBroker(aBroker);</TD></TR><TR><TD CLASS="l">1715</TD><TD>        //getHybridProcessor().setBroker(aBroker);</TD></TR><TR CLASS="z"><TD CLASS="l">1716</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="33">1717</A></TD><TD> </TD></TR><TR><TD CLASS="l">1718</TD><TD>    public boolean processCancel(Order anOrder, int quantity, String userAssignedCancelId, boolean p_publishReportsUnconditionally)</TD></TR><TR><TD CLASS="l">1719</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1720</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>        if (Log.isDebugOn()){</TD></TR><TR CLASS="z"><TD CLASS="l">1722</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImpl &gt;&gt;&gt; delegate processCancel call to BrokerProcessHybridImpl &#34; + anOrder.toString());</TD></TR><TR><TD CLASS="l">1723</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1724</TD><TD>        return getHybridProcessor(anOrder.getProductKey()).processCancel(anOrder,quantity,</TD></TR><TR CLASS="z"><TD CLASS="l">1725</TD><TD>                userAssignedCancelId,true);</TD></TR><TR><TD CLASS="l">1726</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="34">1727</A></TD><TD> </TD></TR><TR><TD CLASS="l">1728</TD><TD>    public void processCancelReplace(Order originalOrder, int quantity, Order newOrder, String userAssignedCancelId)</TD></TR><TR><TD CLASS="l">1729</TD><TD>    throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1730</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1731</TD><TD>        if (Log.isDebugOn()){</TD></TR><TR CLASS="z"><TD CLASS="l">1732</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImpl &gt;&gt;&gt; delegate processCancelReplace call to BrokerProcessHybridImpl &#34; + originalOrder.toString());</TD></TR><TR><TD CLASS="l">1733</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1734</TD><TD>        getHybridProcessor(originalOrder.getProductKey()).processCancelReplace(originalOrder, quantity, newOrder, userAssignedCancelId);</TD></TR><TR CLASS="z"><TD CLASS="l">1735</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="4a">1736</A></TD><TD> </TD></TR><TR><TD CLASS="l">1737</TD><TD>    public void returnCancelRequest(Order originalOrder, int quantity, String userAssignedCancelId, short reason)</TD></TR><TR><TD CLASS="l">1738</TD><TD>    throws DataValidationException, NotAcceptedException</TD></TR><TR><TD CLASS="l">1739</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1740</TD><TD>        if (Log.isDebugOn()){</TD></TR><TR CLASS="z"><TD CLASS="l">1741</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImpl &gt;&gt;&gt; delegate returnCancelRequest for: &#34; +  originalOrder.toString() + &#34; with reason: &#34; + reason);</TD></TR><TR><TD CLASS="l">1742</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1743</TD><TD>        getHybridProcessor(originalOrder.getProductKey()).returnCancelRequest(originalOrder,quantity,userAssignedCancelId,reason);</TD></TR><TR CLASS="z"><TD CLASS="l">1744</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="49">1745</A></TD><TD> </TD></TR><TR><TD CLASS="l">1746</TD><TD>    public void returnCancelReplaceRequest(Order originalOrder, int quantity, Order replacementOrder, String userAssignedCancelId, short reason)</TD></TR><TR><TD CLASS="l">1747</TD><TD>    throws DataValidationException, NotAcceptedException</TD></TR><TR><TD CLASS="l">1748</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1749</TD><TD>        if (Log.isDebugOn()){</TD></TR><TR CLASS="z"><TD CLASS="l">1750</TD><TD>            Log.debug(&#34;BrokerProcessorSpreadHybridImpl &gt;&gt;&gt; delegate returnCancelReplaceRequest for: &#34; + originalOrder.toString() + &#34; with reason: &#34; + reason);</TD></TR><TR><TD CLASS="l">1751</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1752</TD><TD>        getHybridProcessor(originalOrder.getProductKey()).returnCancelReplaceRequest(originalOrder,quantity,replacementOrder,userAssignedCancelId,reason);</TD></TR><TR CLASS="z"><TD CLASS="l">1753</TD><TD>    }</TD></TR><TR><TD CLASS="l">1754</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="4d">1755</A></TD><TD>    public void setAuctionState(int productKey, short auctionType)</TD></TR><TR><TD CLASS="l">1756</TD><TD>    {</TD></TR><TR><TD CLASS="l">1757</TD><TD>        // this is to set the auction state of the new instance BrokerProcessHybridImpl</TD></TR><TR><TD CLASS="l">1758</TD><TD>        // in order for all the delegation to BrokerProcessHybridImpl to work properly</TD></TR><TR CLASS="z"><TD CLASS="l">1759</TD><TD>        getHybridProcessor(productKey).setAuctionState(productKey, auctionType);</TD></TR><TR CLASS="z"><TD CLASS="l">1760</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="e">1761</A></TD><TD> </TD></TR><TR><TD CLASS="l">1762</TD><TD>    protected void doHALTriggerExpiredPostProcessing(AuctionInternal auction, OrderBook book, Tradable terminatingTradable, HALStruct hal)</TD></TR><TR><TD CLASS="l">1763</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1764</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1765</TD><TD>        getHybridProcessor(book.getTradingProduct()).doHALTriggerExpiredPostProcessing(auction, book, terminatingTradable, hal);</TD></TR><TR CLASS="z"><TD CLASS="l">1766</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="22">1767</A></TD><TD> </TD></TR><TR><TD CLASS="l">1768</TD><TD>    protected void handleHALTrigger(QuoteTriggerTradable halTrigger, Tradable incomingTradable, OrderBook book, Price expectedTradePrice)</TD></TR><TR><TD CLASS="l">1769</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1770</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1771</TD><TD>        getHybridProcessor(book.getTradingProduct()).handleHALTrigger(halTrigger, incomingTradable, book, expectedTradePrice);</TD></TR><TR CLASS="z"><TD CLASS="l">1772</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="35">1773</A></TD><TD> </TD></TR><TR><TD CLASS="l">1774</TD><TD>    //Rule is that remaining size of Complex IOC order (after auction/trade) should be immediately cancelled.</TD></TR><TR><TD CLASS="l">1775</TD><TD>    private void processIOCCancel(Order auctionedOrder) throws DataValidationException</TD></TR><TR><TD CLASS="l">1776</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1777</TD><TD>        if (null != auctionedOrder)</TD></TR><TR><TD CLASS="l">1778</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1779</TD><TD>            int remainingQuantity = auctionedOrder.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1780</TD><TD>            if (    remainingQuantity &gt; 0 &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">1781</TD><TD>                    auctionedOrder.getContingencyType() == ContingencyTypes.IOC &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">1782</TD><TD>                    !(  null != auctionedOrder.getHandlingInstruction() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">1783</TD><TD>                        auctionedOrder.getHandlingInstruction().ignoreContingency())</TD></TR><TR><TD CLASS="l">1784</TD><TD>                )</TD></TR><TR><TD CLASS="l">1785</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1786</TD><TD>                Log.information(&#34;BrokerProcessorSpreadHybrid &gt;&gt;&gt; processIOCCancel cancelling qty:&#34; + remainingQuantity + &#34; of IOC Complex order &#34; +</TD></TR><TR CLASS="z"><TD CLASS="l">1787</TD><TD>                        StructToString.toString(auctionedOrder.getOrderId()) + &#34; after COA expiration&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1788</TD><TD>                auctionedOrder.cancel(auctionedOrder.getProductKey().intValue(), </TD></TR><TR CLASS="z"><TD CLASS="l">1789</TD><TD>                        remainingQuantity, auctionedOrder.getUserAssignedId(), ActivityReasons.USER,true);</TD></TR><TR><TD CLASS="l">1790</TD><TD>            }</TD></TR><TR><TD CLASS="l">1791</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1792</TD><TD>    }</TD></TR><TR><TD CLASS="l">1793</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1794</TD><TD>    * This method will process Cancel and CancelReplace pending requests for complex orders</TD></TR><TR><TD CLASS="l"><A NAME="3e">1795</A></TD><TD>    * Below code is moved from AuctionLocalImpl::auctionExpire(), to give the order chance to trade.</TD></TR><TR><TD CLASS="l">1796</TD><TD>    */</TD></TR><TR><TD CLASS="l">1797</TD><TD>    private void processPendingCancelRequest(Order auctionedOrder) throws DataValidationException</TD></TR><TR><TD CLASS="l">1798</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1799</TD><TD>        if (null != auctionedOrder)</TD></TR><TR><TD CLASS="l">1800</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1801</TD><TD>            if (auctionedOrder.isCancelRequestPending())</TD></TR><TR><TD CLASS="l">1802</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1803</TD><TD>                int pendingCancelQty = auctionedOrder.getPendingCancelQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>                String userAssignedCancelId = auctionedOrder.getPendingCancelRequestUserAssignedId();</TD></TR><TR CLASS="z"><TD CLASS="l">1805</TD><TD>                Order newOrder = auctionedOrder.getCancelReplaceNewOrder();</TD></TR><TR CLASS="z"><TD CLASS="l">1806</TD><TD>                int remainingQuantity = auctionedOrder.getRemainingQuantity();</TD></TR><TR><TD CLASS="l">1807</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1808</TD><TD>                int tltcQuantity = pendingCancelQty &gt; remainingQuantity ? pendingCancelQty - remainingQuantity : 0;   //SEDL4591 fix</TD></TR><TR CLASS="z"><TD CLASS="l">1809</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1810</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1811</TD><TD>                    Log.debug(  &#34;BrokerProcessorSpreadHybrid &gt;&gt;&gt; processPendingCancelRequest For orig order &#34; + StructToString.toString(auctionedOrder) +</TD></TR><TR CLASS="z"><TD CLASS="l">1812</TD><TD>                                &#34; Cancel request is pending. tlc/cancelledQ= &#34; + tltcQuantity + &#34;/&#34; + remainingQuantity);</TD></TR><TR><TD CLASS="l">1813</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1814</TD><TD>                auctionedOrder.cancel(auctionedOrder.getProductKey().intValue(),</TD></TR><TR CLASS="z"><TD CLASS="l">1815</TD><TD>                                        remainingQuantity, tltcQuantity, userAssignedCancelId,</TD></TR><TR CLASS="z"><TD CLASS="l">1816</TD><TD>                                        auctionedOrder.getMarkedCancelReason(), 0,true);</TD></TR><TR CLASS="z"><TD CLASS="l">1817</TD><TD>                if (newOrder != null)</TD></TR><TR><TD CLASS="l">1818</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1819</TD><TD>                    newOrder.changeToState(InternalOrderStates.ROUTED_AWAY);</TD></TR><TR CLASS="z"><TD CLASS="l">1820</TD><TD>                    ReturnHybridOrderCancelReplaceCommand command = null;</TD></TR><TR><TD CLASS="l">1821</TD><TD>                    try</TD></TR><TR><TD CLASS="l">1822</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1823</TD><TD>                        if (tltcQuantity &gt; 0)                         </TD></TR><TR><TD CLASS="l">1824</TD><TD>                        {                            </TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>                            command = ReturnHybridOrderCancelReplaceCommand.getInstance(auctionedOrder, remainingQuantity, myBroker, newOrder, userAssignedCancelId, OrderRoutingReasons.MISMATCH_QUANTITY);</TD></TR><TR><TD CLASS="l">1826</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1827</TD><TD>                        else </TD></TR><TR><TD CLASS="l">1828</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1829</TD><TD>                            command = ReturnHybridOrderCancelReplaceCommand.getInstance(auctionedOrder, remainingQuantity, myBroker, newOrder, userAssignedCancelId, OrderRoutingReasons.SUCCESS);</TD></TR><TR><TD CLASS="l">1830</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1831</TD><TD>                        myBroker.acceptCommand(command,false);</TD></TR><TR><TD CLASS="l">1832</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1833</TD><TD>                    catch (Exception e)</TD></TR><TR><TD CLASS="l">1834</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1835</TD><TD>                        Log.exception(&#34;BrokerProcessorSpreadHybrid &gt;&gt;&gt; processPendingCancelRequest::Exception thrown while processing return command &#34;, e);</TD></TR><TR><TD CLASS="l">1836</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1837</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1838</TD><TD>                auctionedOrder.pendingCancelProcessed();</TD></TR><TR><TD CLASS="l">1839</TD><TD>            }</TD></TR><TR><TD CLASS="l">1840</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1841</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="47">1842</A></TD><TD> </TD></TR><TR><TD CLASS="l">1843</TD><TD>    protected boolean processedWithActiveHALTrigger (Tradable incomingTradable, OrderBook book, Price tradeEndingPrice)</TD></TR><TR><TD CLASS="l">1844</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">1845</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1846</TD><TD>        return getHybridProcessor(book.getTradingProduct()).processedWithActiveHALTrigger(incomingTradable, book, tradeEndingPrice);</TD></TR><TR><TD CLASS="l">1847</TD><TD>    }</TD></TR><TR><TD CLASS="l">1848</TD><TD> </TD></TR><TR><TD CLASS="l">1849</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1850</TD><TD>     *  processUnauctionedFirmMatchOrder</TD></TR><TR><TD CLASS="l">1851</TD><TD>     * @param firmOrder</TD></TR><TR><TD CLASS="l"><A NAME="45">1852</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1853</TD><TD>    public void processUnauctionedFirmMatchOrder(Order firmOrder)</TD></TR><TR><TD CLASS="l">1854</TD><TD>    throws DataValidationException</TD></TR><TR><TD CLASS="l">1855</TD><TD>    {        </TD></TR><TR CLASS="z"><TD CLASS="l">1856</TD><TD>        getHybridProcessor(firmOrder.getProductKey()).processUnauctionedFirmMatchOrder(firmOrder);</TD></TR><TR CLASS="z"><TD CLASS="l">1857</TD><TD>    }</TD></TR><TR><TD CLASS="l">1858</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="46">1859</A></TD><TD>    public void processUnauctionedInternalizedOrder(Order internalizedOrder, short reason)</TD></TR><TR><TD CLASS="l">1860</TD><TD>    throws DataValidationException</TD></TR><TR><TD CLASS="l">1861</TD><TD>    {</TD></TR><TR><TD CLASS="l">1862</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1863</TD><TD>        if (reason == OrderRoutingReasons.NOT_ELIGIBLE_FOR_AUCTION)</TD></TR><TR><TD CLASS="l">1864</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1865</TD><TD>            reason = OrderRoutingReasons.NOT_ELIGIBLE_FOR_COMPLEX_AUCTION;</TD></TR><TR><TD CLASS="l">1866</TD><TD>        }        </TD></TR><TR CLASS="z"><TD CLASS="l">1867</TD><TD>        Log.information(&#34;The routing reason of primary Order is &#34; +reason); </TD></TR><TR CLASS="z"><TD CLASS="l">1868</TD><TD>        getHybridProcessor(internalizedOrder.getProductKey()).processUnauctionedInternalizedOrder(internalizedOrder, reason);</TD></TR><TR CLASS="z"><TD CLASS="l">1869</TD><TD>    }</TD></TR><TR><TD CLASS="l">1870</TD><TD>  </TD></TR><TR><TD CLASS="l">1871</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1872</TD><TD>     * process internalization</TD></TR><TR><TD CLASS="l">1873</TD><TD>     * overwrite the method of the super class to implement it for hybrid tradeServer</TD></TR><TR><TD CLASS="l">1874</TD><TD>     * @param theInternalizationPair</TD></TR><TR><TD CLASS="l"><A NAME="36">1875</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1876</TD><TD>    public void processInternalizationOrders(InternalizationPair theInternalizationPair)</TD></TR><TR><TD CLASS="l">1877</TD><TD>        throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">1878</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1879</TD><TD>        OrderBook book = getOrderBook(theInternalizationPair.getPrimaryOrder().getProductKey());</TD></TR><TR><TD CLASS="l">1880</TD><TD>        </TD></TR><TR><TD CLASS="l">1881</TD><TD>        // if STS enabled class, to expire leg auction, has to call HTS</TD></TR><TR CLASS="z"><TD CLASS="l">1882</TD><TD>        if (book.getTradingProduct().isRolledoutSpreadClass() &amp;&amp; !book.getTradingProduct().isProxy()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1883</TD><TD>            OrderRoutingParameterStruct ors = StrategyTradeServiceHelper.getOrderRoutingParameterStructForSpreadEnalbed(book.getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">1884</TD><TD>            OrderBookSummaryStruct[] legMarkets = null;</TD></TR><TR><TD CLASS="l">1885</TD><TD>            try</TD></TR><TR><TD CLASS="l">1886</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1887</TD><TD>                legMarkets = getOrderRoutingDestinationService()</TD></TR><TR CLASS="z"><TD CLASS="l">1888</TD><TD>                    .expireAllLegTimerBasedHoldupForAIMComplexOrder(ors, theInternalizationPair.getPrimaryOrder().getStruct());</TD></TR><TR><TD CLASS="l">1889</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1890</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">1891</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1892</TD><TD>                Log.exception(&#34;Failed to get ORS for AIMComplext Order expiring Leg auctions&#34;, e);</TD></TR><TR><TD CLASS="l">1893</TD><TD>            }</TD></TR><TR><TD CLASS="l">1894</TD><TD>            // refresh legs current market</TD></TR><TR CLASS="z"><TD CLASS="l">1895</TD><TD>            StrategyTradeServiceHelper.refreshLegsCurrentMarketCache(legMarkets);</TD></TR><TR><TD CLASS="l">1896</TD><TD>            // get DQ based on the refreshed leg markets returned from HTS</TD></TR><TR CLASS="z"><TD CLASS="l">1897</TD><TD>            DerivedQuote dq = StrategyTradeServiceHelper.getDerivedQuoteWithouRefreshLegMarkets(book.getTradingProduct(), legMarkets);</TD></TR><TR CLASS="z"><TD CLASS="l">1898</TD><TD>            theInternalizationPair.setDerivedQuote(dq);</TD></TR><TR><TD CLASS="l">1899</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1900</TD><TD>        TradingStrategyLeg[] legs = book.getTradingProduct().getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">1901</TD><TD>        for (TradingStrategyLeg leg:legs)</TD></TR><TR><TD CLASS="l">1902</TD><TD>        {            </TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>           TradingProduct product = leg.getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">1904</TD><TD>           if(product != null)</TD></TR><TR><TD CLASS="l">1905</TD><TD>           {    </TD></TR><TR CLASS="z"><TD CLASS="l">1906</TD><TD>               OrderBook legBook = product.getOrderBook();</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>               Auction auctionOnTheLeg = getAuctionService().findAuction(product.getProductKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1908</TD><TD>               if (auctionOnTheLeg!=null)</TD></TR><TR><TD CLASS="l">1909</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">1910</TD><TD>                   product.getBroker().getProcessor().processAuctionExpire(auctionOnTheLeg, AuctionTerminateReasons.NEW_AUCTION,null);</TD></TR><TR><TD CLASS="l">1911</TD><TD>               }</TD></TR><TR><TD CLASS="l">1912</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1913</TD><TD>               getHybridProcessor(product).forceExpireQuoteTrigger(legBook);   </TD></TR><TR><TD CLASS="l">1914</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1915</TD><TD>               if (legBook.isLocked())</TD></TR><TR><TD CLASS="l">1916</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">1917</TD><TD>                getHybridProcessor(product).forceExpireQuoteLock(legBook);</TD></TR><TR><TD CLASS="l">1918</TD><TD>               }</TD></TR><TR><TD CLASS="l">1919</TD><TD>            }</TD></TR><TR><TD CLASS="l">1920</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1921</TD><TD>            DerivedQuote dq = StrategyTradeServiceHelper.getDerivedQuote(book.getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">1922</TD><TD>            theInternalizationPair.setDerivedQuote(dq);</TD></TR><TR><TD CLASS="l">1923</TD><TD>        }</TD></TR><TR><TD CLASS="l">1924</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1925</TD><TD>        if (book.isEmpty() == true)//book is empty hence the productstate may not be up-to-date</TD></TR><TR><TD CLASS="l">1926</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1927</TD><TD>            processLegBestBookChange(theInternalizationPair.getPrimaryOrder().getProductKey());</TD></TR><TR><TD CLASS="l">1928</TD><TD>        }</TD></TR><TR><TD CLASS="l">1929</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1930</TD><TD>        getHybridProcessor(theInternalizationPair.getPrimaryOrder().getProductKey()).processInternalizationOrders(theInternalizationPair);</TD></TR><TR CLASS="z"><TD CLASS="l">1931</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="11">1932</A></TD><TD>    </TD></TR><TR><TD CLASS="l">1933</TD><TD>    public void expireAllLegTimerBasedHoldupForAIMComplexOrder(TradingProduct tradingProduct)</TD></TR><TR><TD CLASS="l">1934</TD><TD>        throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">1935</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>        TradingStrategyLeg[] legs = tradingProduct.getStrategyLegs();</TD></TR><TR CLASS="z"><TD CLASS="l">1937</TD><TD>        if (legs == null || legs.length == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1938</TD><TD>            tradingProduct.setLegBestMarkets(new OrderBookSummaryStruct[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">1939</TD><TD>        for (int i=0; i&lt;legs.length; i++)</TD></TR><TR><TD CLASS="l">1940</TD><TD>        {            </TD></TR><TR CLASS="z"><TD CLASS="l">1941</TD><TD>           TradingProduct product = legs[i].getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">1942</TD><TD>           if(product != null)</TD></TR><TR><TD CLASS="l">1943</TD><TD>           {    </TD></TR><TR CLASS="z"><TD CLASS="l">1944</TD><TD>               OrderBookImpl legBook = (OrderBookImpl)product.getOrderBook();</TD></TR><TR CLASS="z"><TD CLASS="l">1945</TD><TD>               Auction auctionOnTheLeg = getAuctionService().findAuction(product.getProductKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1946</TD><TD>               if (auctionOnTheLeg!=null)</TD></TR><TR><TD CLASS="l">1947</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">1948</TD><TD>                   product.getBroker().getProcessor().processAuctionExpire(auctionOnTheLeg, AuctionTerminateReasons.NEW_AUCTION,null);</TD></TR><TR><TD CLASS="l">1949</TD><TD>               }</TD></TR><TR><TD CLASS="l">1950</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1951</TD><TD>               if (legBook.isLocked())</TD></TR><TR><TD CLASS="l">1952</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">1953</TD><TD>                   getHybridProcessor(product).forceExpireQuoteLock(legBook);</TD></TR><TR><TD CLASS="l">1954</TD><TD>               }</TD></TR><TR><TD CLASS="l">1955</TD><TD>            }</TD></TR><TR><TD CLASS="l">1956</TD><TD>        }</TD></TR><TR><TD CLASS="l">1957</TD><TD>        // set the leg best markets to trading product</TD></TR><TR CLASS="z"><TD CLASS="l">1958</TD><TD>        OrderBookSummaryStruct[] legBestMarkets = StrategyTradeServiceHelper.getBestLegMarketsStructs(tradingProduct);</TD></TR><TR CLASS="z"><TD CLASS="l">1959</TD><TD>        tradingProduct.setLegBestMarkets(legBestMarkets);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="13">1960</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1961</TD><TD>    </TD></TR><TR><TD CLASS="l">1962</TD><TD>    protected void findAndReturnBookedOrdersForIndexHybrid(OrderBook book, StrategyLegTradeContainer legTradeContainer, DerivedQuote derivedQuote, Side tradeSide)</TD></TR><TR><TD CLASS="l">1963</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1964</TD><TD>        boolean manualQuoteExists = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1965</TD><TD>        TradingProduct tProduct = book.getTradingProduct();</TD></TR><TR><TD CLASS="l">1966</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1967</TD><TD>        if (IndexHybridStrategyHelper.isIndexHybridEnabled(tProduct))</TD></TR><TR><TD CLASS="l">1968</TD><TD>        {</TD></TR><TR><TD CLASS="l">1969</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1970</TD><TD>                manualQuoteExists = IndexHybridStrategyHelper.manualQuoteExistsOnTradableLegSide(tProduct, tradeSide);</TD></TR><TR CLASS="z"><TD CLASS="l">1971</TD><TD>                if (manualQuoteExists)</TD></TR><TR><TD CLASS="l">1972</TD><TD>                {                    </TD></TR><TR CLASS="z"><TD CLASS="l">1973</TD><TD>                    Enumeration tradablesEnum = book.getTradables(tradeSide);</TD></TR><TR CLASS="z"><TD CLASS="l">1974</TD><TD>                    while (tradablesEnum.hasMoreElements())</TD></TR><TR><TD CLASS="l">1975</TD><TD>                    {                        </TD></TR><TR CLASS="z"><TD CLASS="l">1976</TD><TD>                        Tradable bookedTradable = (Tradable) tradablesEnum.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">1977</TD><TD>                        legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(book.getTradingProduct(), derivedQuote, bookedTradable);</TD></TR><TR CLASS="z"><TD CLASS="l">1978</TD><TD>                        if (legTradeContainer.getCanTradeWithLegs())</TD></TR><TR><TD CLASS="l">1979</TD><TD>                        {                            </TD></TR><TR><TD CLASS="l">1980</TD><TD>                            //unbook the tradable and return the order to TPF</TD></TR><TR CLASS="z"><TD CLASS="l">1981</TD><TD>                            if (bookedTradable.isTradable(TradableTypes.ORDER))</TD></TR><TR><TD CLASS="l">1982</TD><TD>                            {</TD></TR><TR><TD CLASS="l">1983</TD><TD>                                try</TD></TR><TR><TD CLASS="l">1984</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1985</TD><TD>                                    book.unbook(bookedTradable,bookedTradable.getQuantity(),tradeSide,bookedTradable.getPrice());</TD></TR><TR CLASS="z"><TD CLASS="l">1986</TD><TD>                                    IndexHybridStrategyHelper.setOverRideReasonForIndexHybrid((Order)bookedTradable, OrderRoutingReasons.STRATEGY_MARKETABLE_WITH_MANUAL_QUOTE);</TD></TR><TR CLASS="z"><TD CLASS="l">1987</TD><TD>                                    postProcess((Order)bookedTradable, book);                                    </TD></TR><TR><TD CLASS="l">1988</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1989</TD><TD>                                catch (OrderBookTradableNotFoundException e)</TD></TR><TR><TD CLASS="l">1990</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1991</TD><TD>                                    Log.exception(this,&#34;Error while trying to unbook the Complex Order = &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">1992</TD><TD>                                     + StructToString.toString(bookedTradable) + &#34; &#34; + e.getMessage(), e);</TD></TR><TR><TD CLASS="l">1993</TD><TD>                                }          </TD></TR><TR CLASS="z"><TD CLASS="l">1994</TD><TD>                                catch (SystemException e)</TD></TR><TR><TD CLASS="l">1995</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1996</TD><TD>                                    Log.exception(this,&#34;Error while trying to return the Complex Order = &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">1997</TD><TD>                                            + StructToString.toString(bookedTradable) + &#34; &#34; + e.getMessage(), e);</TD></TR><TR><TD CLASS="l">1998</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1999</TD><TD>                            }</TD></TR><TR CLASS="z"><TD CLASS="l">2000</TD><TD>                            else if (bookedTradable.isTradable(TradableTypes.QUOTE_SIDE))</TD></TR><TR><TD CLASS="l">2001</TD><TD>                            {</TD></TR><TR><TD CLASS="l">2002</TD><TD>                                //cancel the whole quote</TD></TR><TR CLASS="z"><TD CLASS="l">2003</TD><TD>                                Quote aQuote = ( (QuoteSide)bookedTradable).getQuote();</TD></TR><TR CLASS="z"><TD CLASS="l">2004</TD><TD>                                aQuote.setCancelReason(ActivityReasons.SYSTEM);</TD></TR><TR><TD CLASS="l">2005</TD><TD>                                try</TD></TR><TR><TD CLASS="l">2006</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">2007</TD><TD>                                    processCancel(aQuote);</TD></TR><TR><TD CLASS="l">2008</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2009</TD><TD>                                catch (SystemException e)</TD></TR><TR><TD CLASS="l">2010</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>                                    Log.exception(this,&#34;Error while trying to cancel the Quote = &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">2012</TD><TD>                                            + StructToString.toString(bookedTradable) + &#34; &#34; + e.getMessage(), e);</TD></TR><TR><TD CLASS="l">2013</TD><TD>                                }                                </TD></TR><TR><TD CLASS="l">2014</TD><TD>                            }</TD></TR><TR><TD CLASS="l">2015</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2016</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2017</TD><TD>                }</TD></TR><TR><TD CLASS="l">2018</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2019</TD><TD>            catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">2020</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2021</TD><TD>                Log.exception(&#34;Broker unable to find order book for leg: &#34;, e);</TD></TR><TR><TD CLASS="l">2022</TD><TD>            }</TD></TR><TR><TD CLASS="l">2023</TD><TD>        }                    </TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>    }</TD></TR><TR><TD CLASS="l">2025</TD><TD>    </TD></TR><TR><TD CLASS="l">2026</TD><TD>    /*</TD></TR><TR><TD CLASS="l"><A NAME="6">2027</A></TD><TD>     * Cancel I order if marked to route back for BoB Class </TD></TR><TR><TD CLASS="l">2028</TD><TD>     */</TD></TR><TR><TD CLASS="l">2029</TD><TD>    private void cancelIOrderForBoB(Order order) throws DataValidationException</TD></TR><TR><TD CLASS="l">2030</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2031</TD><TD>        if (order.getHandlingInstruction() != null)</TD></TR><TR><TD CLASS="l">2032</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2033</TD><TD>                int remQty = order.getRemainingQuantity();</TD></TR><TR CLASS="z"><TD CLASS="l">2034</TD><TD>            if  (  order.treatedLikeQuote() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">2035</TD><TD>                    order.getHandlingInstruction().isOrderReturnReasonSetForIndexHybrid() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">2036</TD><TD>                    remQty &gt; 0</TD></TR><TR><TD CLASS="l">2037</TD><TD>                )</TD></TR><TR><TD CLASS="l">2038</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2039</TD><TD>                order.cancel(ActivityReasons.SYSTEM);</TD></TR><TR CLASS="z"><TD CLASS="l">2040</TD><TD>                Log.information(&#34;Cancelled I complex order's remaning qty : &#34; + remQty + &#34;, due to ManualQuote. Order = &#34; + StructToString.toString(order));</TD></TR><TR><TD CLASS="l">2041</TD><TD>            }</TD></TR><TR><TD CLASS="l">2042</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2043</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="41">2044</A></TD><TD> </TD></TR><TR><TD CLASS="l">2045</TD><TD>    private boolean processReCOAOrders(List&lt;Order&gt; orders, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">2046</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">2047</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2048</TD><TD>        Order order = orders.get(0);</TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>        AuctionInternal activeAuction = orderBook.getTradingProduct().getActiveAuction();</TD></TR><TR><TD CLASS="l">2050</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>        if (null != activeAuction)</TD></TR><TR><TD CLASS="l">2052</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2053</TD><TD>            if (shouldExpireDueToIncomingTradable(activeAuction, order))</TD></TR><TR><TD CLASS="l">2054</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2055</TD><TD>                Log.information(this, &#34;reCOA order: &#34; + order + &#34; will expire the current COA: &#34; + activeAuction); </TD></TR><TR><TD CLASS="l">2056</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2057</TD><TD>                cleanupLegTimerBasedHoldups(activeAuction.getAuctionBook().getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">2058</TD><TD>                getSpreadAuctionProcessor(order.getProductKey()).endAuctionByReCOAOrders(activeAuction, orders, AuctionTerminateReasons.ORDER_MARKETABLE_AGAINST_AUCTION);</TD></TR><TR CLASS="z"><TD CLASS="l">2059</TD><TD>                performPostAuctionProcessing(activeAuction);</TD></TR><TR><TD CLASS="l">2060</TD><TD> </TD></TR><TR><TD CLASS="l">2061</TD><TD>                // remove any reCOA orders that are fully traded during ending COA</TD></TR><TR CLASS="z"><TD CLASS="l">2062</TD><TD>                List&lt;Order&gt; remainedOrders = new ArrayList&lt;Order&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2063</TD><TD>                for (Order aOrder : orders)</TD></TR><TR><TD CLASS="l">2064</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2065</TD><TD>                    if (aOrder.getQuantityAllowed() &lt;= 0)</TD></TR><TR><TD CLASS="l">2066</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2067</TD><TD>                        unbookReCOAOrder(aOrder, orderBook);</TD></TR><TR><TD CLASS="l">2068</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2069</TD><TD>                    else</TD></TR><TR><TD CLASS="l">2070</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2071</TD><TD>                        remainedOrders.add(aOrder);</TD></TR><TR><TD CLASS="l">2072</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2073</TD><TD>                }</TD></TR><TR><TD CLASS="l">2074</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2075</TD><TD>                if (remainedOrders.size() &gt; 0)</TD></TR><TR><TD CLASS="l">2076</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>                    return processOrderWithoutActiveAuction(remainedOrders, orderBook);</TD></TR><TR><TD CLASS="l">2078</TD><TD>                }</TD></TR><TR><TD CLASS="l">2079</TD><TD>                else</TD></TR><TR><TD CLASS="l">2080</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2081</TD><TD>                    Log.information(this, &#34;all reCOA orders were traded when ending the active auction: &#34; + activeAuction); </TD></TR><TR CLASS="z"><TD CLASS="l">2082</TD><TD>                    return false;</TD></TR><TR><TD CLASS="l">2083</TD><TD>                }</TD></TR><TR><TD CLASS="l">2084</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2085</TD><TD>            else if (shouldJoin(activeAuction, order))</TD></TR><TR><TD CLASS="l">2086</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2087</TD><TD>                unbookReCOAOrders(orders, orderBook);</TD></TR><TR><TD CLASS="l">2088</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2089</TD><TD>                for (Order aOrder : orders)</TD></TR><TR><TD CLASS="l">2090</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2091</TD><TD>                    Log.information(this, &#34;reCOA order: &#34; + aOrder + &#34; will join the current COA: &#34; + activeAuction); </TD></TR><TR CLASS="z"><TD CLASS="l">2092</TD><TD>                    getSpreadAuctionProcessor(activeAuction.getProductKey()).joinActiveAuction(activeAuction, aOrder);</TD></TR><TR><TD CLASS="l">2093</TD><TD>                }</TD></TR><TR><TD CLASS="l">2094</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2095</TD><TD>                processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2096</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">2097</TD><TD>            }</TD></TR><TR><TD CLASS="l">2098</TD><TD>        }</TD></TR><TR><TD CLASS="l">2099</TD><TD>        else</TD></TR><TR><TD CLASS="l">2100</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2101</TD><TD>            return processOrderWithoutActiveAuction(orders, orderBook);</TD></TR><TR><TD CLASS="l">2102</TD><TD>        }</TD></TR><TR><TD CLASS="l">2103</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2104</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">2105</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="3c">2106</A></TD><TD> </TD></TR><TR><TD CLASS="l">2107</TD><TD>    private boolean processOrderWithoutActiveAuction(List&lt;Order&gt; orders, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">2108</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">2109</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2110</TD><TD>        Order order = orders.get(0);</TD></TR><TR CLASS="z"><TD CLASS="l">2111</TD><TD>        preAuctionCleanup(order, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2112</TD><TD>        boolean ignoreDQlocks = false;</TD></TR><TR><TD CLASS="l">2113</TD><TD>        try</TD></TR><TR><TD CLASS="l">2114</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2115</TD><TD>            ignoreDQlocks = !orderBook.getTradingProduct().getTradingClass().getAllowComplexTradesWithQuotes() &amp;&amp; StrategyTradeServiceHelper.checkLegsHaveAutoQuotes(order, orderBook.getTradingProduct());</TD></TR><TR><TD CLASS="l">2116</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2117</TD><TD>        catch(DataValidationException ex)</TD></TR><TR><TD CLASS="l">2118</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2119</TD><TD>            Log.information(&#34;BrokerProcessorSpreadHyBridImpl &gt;&gt; processOrderWithoutActiveAuction. Could not determine if order locks AQ for Spread protection: &#34; + ex.getMessage()); </TD></TR><TR><TD CLASS="l">2120</TD><TD>        } // Ignore price outside DQ, only for Spread protection enabled</TD></TR><TR CLASS="z"><TD CLASS="l">2121</TD><TD>        Price auctionStartingPrice = getSpreadAuctionProcessor(order.getProductKey()).canStartAuction(orders, orderBook, ignoreDQlocks);</TD></TR><TR CLASS="z"><TD CLASS="l">2122</TD><TD>        if (null != auctionStartingPrice)</TD></TR><TR><TD CLASS="l">2123</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2124</TD><TD>            unbookReCOAOrders(orders, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2125</TD><TD>            AuctionInternal auction = getSpreadAuctionProcessor(order.getProductKey()).startAuction(orders, auctionStartingPrice, orderBook);</TD></TR><TR><TD CLASS="l">2126</TD><TD>            </TD></TR><TR><TD CLASS="l">2127</TD><TD>            // This will set the cap details used for PMM entitlement.</TD></TR><TR CLASS="z"><TD CLASS="l">2128</TD><TD>            setAllocationContext(auction, order, orderBook);</TD></TR><TR><TD CLASS="l">2129</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2130</TD><TD>            StringBuilder sb = new StringBuilder(&#34;reCOA orders: &#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">2131</TD><TD>            for (Order aOrder : orders)</TD></TR><TR><TD CLASS="l">2132</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2133</TD><TD>                sb.append(aOrder + &#34; &#34;);</TD></TR><TR><TD CLASS="l">2134</TD><TD>                //set markAuctionStarted as true for all orders</TD></TR><TR CLASS="z"><TD CLASS="l">2135</TD><TD>                aOrder.markAuctionStarted(true);</TD></TR><TR><TD CLASS="l">2136</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2137</TD><TD>            sb.append(&#34; will start a new COA: &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2138</TD><TD>            sb.append(auction);</TD></TR><TR CLASS="z"><TD CLASS="l">2139</TD><TD>            Log.information(this, sb.toString());</TD></TR><TR><TD CLASS="l">2140</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2141</TD><TD>            processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2142</TD><TD>            return true;</TD></TR><TR><TD CLASS="l">2143</TD><TD>        }</TD></TR><TR><TD CLASS="l">2144</TD><TD>        else</TD></TR><TR><TD CLASS="l">2145</TD><TD>        {</TD></TR><TR><TD CLASS="l">2146</TD><TD>            //could not reCOA, check for AQ present and leg locking for Spread Protection</TD></TR><TR><TD CLASS="l">2147</TD><TD>            DerivedQuote derivedQuote; </TD></TR><TR><TD CLASS="l">2148</TD><TD>            //Get the leg Trade Container to see if the spread order can trade with legs - Spread Protections Phase1</TD></TR><TR CLASS="z"><TD CLASS="l">2149</TD><TD>            derivedQuote = StrategyTradeServiceHelper.getDerivedQuote(orderBook.getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">2150</TD><TD>            if (derivedQuote == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2151</TD><TD>                processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2152</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">2153</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2154</TD><TD>            Price aPrice = order.getPrice();</TD></TR><TR><TD CLASS="l">2155</TD><TD>            //when the order does not lock the market, it should not be routed, check for getCanTradeWithLegs</TD></TR><TR CLASS="z"><TD CLASS="l">2156</TD><TD>            StrategyLegTradeContainer legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(order.getSide(), aPrice,order.getQuantityAllowed(), order.getMinQuantity(), orderBook.getTradingProduct(), derivedQuote);           </TD></TR><TR CLASS="z"><TD CLASS="l">2157</TD><TD>            if(!orderBook.getTradingProduct().getTradingClass().getAllowComplexTradesWithQuotes() &amp;&amp; legTradeContainer.getCanTradeWithLegs() &amp;&amp; StrategyTradeServiceHelper.checkLegsHaveAutoQuotes(order,orderBook.getTradingProduct()))</TD></TR><TR><TD CLASS="l">2158</TD><TD>            {</TD></TR><TR><TD CLASS="l">2159</TD><TD>              //Check if the routing is due to tradable manual quote</TD></TR><TR CLASS="z"><TD CLASS="l">2160</TD><TD>                boolean isIndexHybridEnabled = IndexHybridStrategyHelper.isIndexHybridEnabled(orderBook.getTradingProduct());</TD></TR><TR CLASS="z"><TD CLASS="l">2161</TD><TD>                boolean manualQuoteExists = IndexHybridStrategyHelper.manualQuoteExistsOnTradableLegSide(orderBook.getTradingProduct(), order.getSide());</TD></TR><TR CLASS="z"><TD CLASS="l">2162</TD><TD>                for(Order anOrder : orders)</TD></TR><TR><TD CLASS="l">2163</TD><TD>                {</TD></TR><TR><TD CLASS="l">2164</TD><TD>                    try</TD></TR><TR><TD CLASS="l">2165</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2166</TD><TD>                        orderBook.unbook(anOrder, anOrder.getQuantityAllowed(), anOrder.getSide(), anOrder.getPrice());</TD></TR><TR><TD CLASS="l">2167</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2168</TD><TD>                    catch (OrderBookTradableNotFoundException e)</TD></TR><TR><TD CLASS="l">2169</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2170</TD><TD>                        Log.exception(this, &#34;failed to unbook order: &#34; + anOrder, e);</TD></TR><TR><TD CLASS="l">2171</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2172</TD><TD>                    if(anOrder.getHandlingInstruction() == null)</TD></TR><TR><TD CLASS="l">2173</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2174</TD><TD>                        anOrder.setHandlingInstruction(new OrderHandlingInstructionNoReflectionImpl());</TD></TR><TR CLASS="z"><TD CLASS="l">2175</TD><TD>                        anOrder.getHandlingInstruction().setExecutionPrice(NO_PRICE);</TD></TR><TR><TD CLASS="l">2176</TD><TD>                    }  </TD></TR><TR CLASS="z"><TD CLASS="l">2177</TD><TD>                    if(isIndexHybridEnabled &amp;&amp; manualQuoteExists)</TD></TR><TR><TD CLASS="l">2178</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2179</TD><TD>                        anOrder.getHandlingInstruction().setReturnedCode(OrderRoutingReasons.MARKETABLE_WITH_MANUAL_QUOTE);</TD></TR><TR CLASS="z"><TD CLASS="l">2180</TD><TD>                        postProcess(anOrder, orderBook);</TD></TR><TR><TD CLASS="l">2181</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2182</TD><TD>                    else</TD></TR><TR><TD CLASS="l">2183</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">2184</TD><TD>                        anOrder.getHandlingInstruction().setReturnedCode(OrderRoutingReasons.ORDER_TOUCHES_LEG_QUOTES);</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>                        postProcess(anOrder, orderBook);</TD></TR><TR><TD CLASS="l">2186</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2187</TD><TD>                }</TD></TR><TR><TD CLASS="l">2188</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2189</TD><TD>            processRefreshBestBook(orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2190</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">2191</TD><TD>        }</TD></TR><TR><TD CLASS="l">2192</TD><TD>    }</TD></TR><TR><TD CLASS="l">2193</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="54">2194</A></TD><TD>    private void unbookReCOAOrder(Order order, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">2195</TD><TD>    {</TD></TR><TR><TD CLASS="l">2196</TD><TD>        try</TD></TR><TR><TD CLASS="l">2197</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2198</TD><TD>            orderBook.unbook(order, order.getQuantityAllowed(), order.getSide(), order.getPrice());</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>            ((OrderImpl)order).setReCOAQuantity(order.getQuantityAllowed());</TD></TR><TR><TD CLASS="l">2200</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>        catch (OrderBookTradableNotFoundException e)</TD></TR><TR><TD CLASS="l">2202</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2203</TD><TD>            Log.exception(this, &#34;failed to unbook reCOA order: &#34; + order, e);</TD></TR><TR><TD CLASS="l">2204</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2205</TD><TD>    }</TD></TR><TR><TD CLASS="l">2206</TD><TD>    </TD></TR><TR><TD CLASS="l">2207</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2208</TD><TD>     * set the current time after auction expires </TD></TR><TR><TD CLASS="l">2209</TD><TD>     * and before order book event happen.</TD></TR><TR><TD CLASS="l">2210</TD><TD>     * Null implementation is in BrokerProcessorBase class</TD></TR><TR><TD CLASS="l"><A NAME="4f">2211</A></TD><TD>     *             </TD></TR><TR><TD CLASS="l">2212</TD><TD>     */</TD></TR><TR><TD CLASS="l">2213</TD><TD>    public void setCOAStartedTime(Order order) </TD></TR><TR><TD CLASS="l">2214</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2215</TD><TD>        Integer classKey = new Integer(order.getClassKey());</TD></TR><TR><TD CLASS="l">2216</TD><TD>        try </TD></TR><TR><TD CLASS="l">2217</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2218</TD><TD>            getReCOAManagerHome().findByClass(classKey).coaStarted(order.getProductKey());</TD></TR><TR><TD CLASS="l">2219</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2220</TD><TD>        catch (DataValidationException e) </TD></TR><TR><TD CLASS="l">2221</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2222</TD><TD>            Log.exception(this, &#34;Failed to set the current time for auction expired order&#34;, e);</TD></TR><TR><TD CLASS="l">2223</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="55">2224</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2225</TD><TD> </TD></TR><TR><TD CLASS="l">2226</TD><TD>    private void unbookReCOAOrders(List&lt;Order&gt; orders, OrderBook orderBook)</TD></TR><TR><TD CLASS="l">2227</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2228</TD><TD>        StringBuilder sb = new StringBuilder(&#34;unbook reCOA orders: &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2229</TD><TD>        for (Order order : orders)</TD></TR><TR><TD CLASS="l">2230</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2231</TD><TD>            unbookReCOAOrder(order, orderBook);</TD></TR><TR CLASS="z"><TD CLASS="l">2232</TD><TD>            sb.append(order + &#34; &#34;);</TD></TR><TR><TD CLASS="l">2233</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2234</TD><TD>        Log.information(this, sb.toString());</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3">2235</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2236</TD><TD> </TD></TR><TR><TD CLASS="l">2237</TD><TD>    protected boolean canDoTrade(Tradable newTradable, OrderBook anBook, Price EPW, Price tradeEndingPrice)</TD></TR><TR><TD CLASS="l">2238</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2239</TD><TD>        boolean result = super.canDoTrade(newTradable, anBook, EPW, tradeEndingPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">2240</TD><TD>        if (newTradable.getPrice().isMarketPrice() &amp;&amp; !result)</TD></TR><TR><TD CLASS="l">2241</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2242</TD><TD>            ((Order)newTradable).getHandlingInstruction().setReturnedCode(OrderRoutingReasons.NOT_TRADED_WIDE_MKT);</TD></TR><TR><TD CLASS="l">2243</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2244</TD><TD>        return result;</TD></TR><TR><TD CLASS="l"><A NAME="4">2245</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2246</TD><TD> </TD></TR><TR><TD CLASS="l">2247</TD><TD>    protected boolean canProcessMktPricedTradableWithLegs(Tradable newTradable, StrategyLegTradeContainer legTradeContainer, TradingProduct tradingProduct)</TD></TR><TR><TD CLASS="l">2248</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2249</TD><TD>        Price tradePrice = this.getTradePriceForOtherSide(legTradeContainer.getTradablePrice());</TD></TR><TR><TD CLASS="l">2250</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2251</TD><TD>        return StrategyHelper.canTradeMarketOrderWithTradePrice(newTradable, tradePrice, tradingProduct);</TD></TR><TR><TD CLASS="l">2252</TD><TD>    }</TD></TR><TR><TD CLASS="l">2253</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="42">2254</A></TD><TD>    </TD></TR><TR><TD CLASS="l">2255</TD><TD>    public void processSpreadOrderForLegTrade (Order p_spreadOrder, AuctionInternal p_auction)</TD></TR><TR><TD CLASS="l">2256</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">2257</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2258</TD><TD>        int totalTradedQuantity = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2259</TD><TD>        TradingProduct product = getTradingProduct(p_spreadOrder.getProductKey());</TD></TR><TR><TD CLASS="l">2260</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2261</TD><TD>        Price tradeEndingPrice = (p_spreadOrder.getHandlingInstruction() != null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">2262</TD><TD>                        !p_spreadOrder.getHandlingInstruction().getExecutionPrice().isNoPrice()) ?</TD></TR><TR CLASS="z"><TD CLASS="l">2263</TD><TD>                        p_spreadOrder.getHandlingInstruction().getExecutionPrice() : p_spreadOrder.getPrice();</TD></TR><TR CLASS="z"><TD CLASS="l">2264</TD><TD>        int iterationCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2265</TD><TD>        Tradable newTradable = p_spreadOrder;</TD></TR><TR CLASS="z"><TD CLASS="l">2266</TD><TD>        boolean isIndexHybridEnabled = IndexHybridStrategyHelper.isIndexHybridEnabled(product);</TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>        boolean manualQuoteExists = IndexHybridStrategyHelper.manualQuoteExistsOnTradableLegSide(</TD></TR><TR CLASS="z"><TD CLASS="l">2268</TD><TD>                product, newTradable.getSide());</TD></TR><TR><TD CLASS="l">2269</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2270</TD><TD>        DerivedQuote derivedQuote = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2271</TD><TD>        while (newTradable.getQuantityAllowed() &gt; 0 &amp;&amp; product.areAllLegsValid())</TD></TR><TR><TD CLASS="l">2272</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2273</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2274</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2275</TD><TD>                Log.debug(&#34;BrokerProcessorSpreadImpl.processTradable&gt;&gt; tradeEndingPrice = &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">2276</TD><TD>                        + tradeEndingPrice);</TD></TR><TR><TD CLASS="l">2277</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2278</TD><TD>            int currentQuantity = newTradable.getQuantityAllowed();</TD></TR><TR CLASS="z"><TD CLASS="l">2279</TD><TD>            boolean hitMaxNonCustQty = false;</TD></TR><TR><TD CLASS="l">2280</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2281</TD><TD>            boolean useSavedDQ = cleanupLegTimerBasedHoldups(product);</TD></TR><TR><TD CLASS="l">2282</TD><TD>            // get DQ again</TD></TR><TR CLASS="z"><TD CLASS="l">2283</TD><TD>            if(!(isRolledoutSpreadClass(product) &amp;&amp; useSavedDQ))  </TD></TR><TR><TD CLASS="l">2284</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2285</TD><TD>                derivedQuote = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR><TD CLASS="l">2286</TD><TD>            }</TD></TR><TR><TD CLASS="l">2287</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2288</TD><TD>            if (derivedQuote == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2289</TD><TD>                break;</TD></TR><TR><TD CLASS="l">2290</TD><TD>            }</TD></TR><TR><TD CLASS="l">2291</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2292</TD><TD>            int iterationQuantity = newTradable.getQuantityAllowed();</TD></TR><TR><TD CLASS="l">2293</TD><TD>            // 03/12/03...If Order has no remaining quantity, tradeWithLegs(...) should never</TD></TR><TR><TD CLASS="l">2294</TD><TD>            // executed ...</TD></TR><TR CLASS="z"><TD CLASS="l">2295</TD><TD>            if (iterationQuantity &gt; 0)</TD></TR><TR><TD CLASS="l">2296</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2297</TD><TD>                iterationCount++;</TD></TR><TR CLASS="z"><TD CLASS="l">2298</TD><TD>                Price price = tradeEndingPrice;</TD></TR><TR><TD CLASS="l">2299</TD><TD>//                if (tradeEndingPrice == null || tradeEndingPrice.isNoPrice())</TD></TR><TR><TD CLASS="l">2300</TD><TD>//                {</TD></TR><TR><TD CLASS="l">2301</TD><TD>//                    price = newTradable.getPrice();</TD></TR><TR><TD CLASS="l">2302</TD><TD>//                }</TD></TR><TR><TD CLASS="l">2303</TD><TD>//                else</TD></TR><TR><TD CLASS="l">2304</TD><TD>//                {</TD></TR><TR><TD CLASS="l">2305</TD><TD>//                    price = getTradableEffectivePrice(newTradable, tradeEndingPrice);</TD></TR><TR><TD CLASS="l">2306</TD><TD>//                }</TD></TR><TR><TD CLASS="l">2307</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">2308</TD><TD>                StrategyLegTradeContainer legTradeContainer = StrategyTradeServiceHelper</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>                        .getStrategyLegTradeContainer(newTradable.getSide(), price,</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>                                iterationQuantity, newTradable.getMinQuantity(), product,</TD></TR><TR CLASS="z"><TD CLASS="l">2311</TD><TD>                                derivedQuote);</TD></TR><TR><TD CLASS="l">2312</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2313</TD><TD>                if (IndexHybridStrategyHelper.checkOrderNeedsToBeReturned(newTradable, product,</TD></TR><TR CLASS="z"><TD CLASS="l">2314</TD><TD>                        isIndexHybridEnabled, iterationCount, legTradeContainer))</TD></TR><TR><TD CLASS="l">2315</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2316</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2317</TD><TD>                }</TD></TR><TR><TD CLASS="l">2318</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2319</TD><TD>                if (legTradeContainer.getCanTradeWithLegs())</TD></TR><TR><TD CLASS="l">2320</TD><TD>                {</TD></TR><TR><TD CLASS="l">2321</TD><TD>                    try</TD></TR><TR><TD CLASS="l">2322</TD><TD>                    {</TD></TR><TR><TD CLASS="l">2323</TD><TD>                        // derivedQuote = product.getDerivedQuote();</TD></TR><TR CLASS="z"><TD CLASS="l">2324</TD><TD>                        derivedQuote = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR CLASS="z"><TD CLASS="l">2325</TD><TD>                        if (derivedQuote == null)</TD></TR><TR><TD CLASS="l">2326</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2327</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2328</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2329</TD><TD>                        legTradeContainer = StrategyTradeServiceHelper</TD></TR><TR CLASS="z"><TD CLASS="l">2330</TD><TD>                                .getStrategyLegTradeContainer(newTradable.getSide(), price,</TD></TR><TR CLASS="z"><TD CLASS="l">2331</TD><TD>                                        iterationQuantity, newTradable.getMinQuantity(), product,</TD></TR><TR CLASS="z"><TD CLASS="l">2332</TD><TD>                                        derivedQuote);</TD></TR><TR><TD CLASS="l">2333</TD><TD> </TD></TR><TR><TD CLASS="l">2334</TD><TD>                        // Recalculate the DQ if Manual Quotes were cancelled or spread qty was</TD></TR><TR><TD CLASS="l">2335</TD><TD>                        // changed for IndexHybrid.</TD></TR><TR CLASS="z"><TD CLASS="l">2336</TD><TD>                        if (isIndexHybridEnabled &amp;&amp; newTradable.isTradable(TradableTypes.ORDER))</TD></TR><TR><TD CLASS="l">2337</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2338</TD><TD>                            if(p_spreadOrder.getBookedTime() &gt; 0 || p_auction != null)</TD></TR><TR><TD CLASS="l">2339</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">2340</TD><TD>                                hitMaxNonCustQty = false;</TD></TR><TR><TD CLASS="l">2341</TD><TD>                            }  </TD></TR><TR><TD CLASS="l">2342</TD><TD>                            else</TD></TR><TR><TD CLASS="l">2343</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">2344</TD><TD>                                OrderImpl orderimpl = (OrderImpl) newTradable;</TD></TR><TR><TD CLASS="l">2345</TD><TD>                                </TD></TR><TR><TD CLASS="l">2346</TD><TD>                                // Change the incoming tradable's quantity for index hybrid enabled</TD></TR><TR><TD CLASS="l">2347</TD><TD>                                // class.</TD></TR><TR CLASS="z"><TD CLASS="l">2348</TD><TD>                                hitMaxNonCustQty = IndexHybridStrategyHelper.processIndexHybridOrder(</TD></TR><TR CLASS="z"><TD CLASS="l">2349</TD><TD>                                        isIndexHybridEnabled, newTradable, legTradeContainer, product,</TD></TR><TR CLASS="z"><TD CLASS="l">2350</TD><TD>                                        derivedQuote, price, iterationQuantity);</TD></TR><TR><TD CLASS="l">2351</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">2352</TD><TD>                                orderimpl.setIndexHybridReturnCode(orderimpl.getHandlingInstruction().getOverRideReasonForIndexHybrid());</TD></TR><TR CLASS="z"><TD CLASS="l">2353</TD><TD>                                iterationQuantity = newTradable.getQuantityAllowed();</TD></TR><TR><TD CLASS="l">2354</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">2355</TD><TD>                                orderimpl.setIndexHybridHitMaxNonCustQty(hitMaxNonCustQty);</TD></TR><TR CLASS="z"><TD CLASS="l">2356</TD><TD>                                orderimpl.setIndexHybridRemainingVolAfterLegTrading(iterationQuantity);</TD></TR><TR CLASS="z"><TD CLASS="l">2357</TD><TD>                                derivedQuote = product.getDerivedQuote();</TD></TR><TR><TD CLASS="l">2358</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">2359</TD><TD>                                legTradeContainer = StrategyTradeServiceHelper</TD></TR><TR CLASS="z"><TD CLASS="l">2360</TD><TD>                                        .getStrategyLegTradeContainer(newTradable.getSide(), price,</TD></TR><TR CLASS="z"><TD CLASS="l">2361</TD><TD>                                                iterationQuantity, newTradable.getMinQuantity(),</TD></TR><TR CLASS="z"><TD CLASS="l">2362</TD><TD>                                                product, derivedQuote);</TD></TR><TR CLASS="z"><TD CLASS="l">2363</TD><TD>                                if (legTradeContainer.getCanTradeWithLegs() &amp;&amp; iterationQuantity == 0)</TD></TR><TR><TD CLASS="l">2364</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">2365</TD><TD>                                    ((Order) newTradable).getHandlingInstruction()</TD></TR><TR CLASS="z"><TD CLASS="l">2366</TD><TD>                                            .setDefaultMaxTradableQtyForIndexHybrid();</TD></TR><TR CLASS="z"><TD CLASS="l">2367</TD><TD>                                    break;</TD></TR><TR><TD CLASS="l">2368</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2369</TD><TD>                            }</TD></TR><TR><TD CLASS="l">2370</TD><TD>                        }   </TD></TR><TR><TD CLASS="l">2371</TD><TD>                        </TD></TR><TR CLASS="z"><TD CLASS="l">2372</TD><TD>                        if (legTradeContainer.getCanTradeWithLegs())</TD></TR><TR><TD CLASS="l">2373</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2374</TD><TD>                            if ((!canProcessMktPricedTradableWithLegs(newTradable,</TD></TR><TR CLASS="z"><TD CLASS="l">2375</TD><TD>                                    legTradeContainer, product)))</TD></TR><TR><TD CLASS="l">2376</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">2377</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">2378</TD><TD>                            }</TD></TR><TR><TD CLASS="l">2379</TD><TD>                            </TD></TR><TR CLASS="z"><TD CLASS="l">2380</TD><TD>                            int tradedQuantity = doSpreadOrderLegTrades (p_spreadOrder, derivedQuote, product, p_auction);</TD></TR><TR CLASS="z"><TD CLASS="l">2381</TD><TD>                            totalTradedQuantity += tradedQuantity;</TD></TR><TR><TD CLASS="l">2382</TD><TD>                            </TD></TR><TR CLASS="z"><TD CLASS="l">2383</TD><TD>                            if (isIndexHybridEnabled &amp;&amp; newTradable.isTradable(TradableTypes.ORDER))</TD></TR><TR><TD CLASS="l">2384</TD><TD>                            {</TD></TR><TR><TD CLASS="l">2385</TD><TD>                                // Reset IH qty, so getQuantityAllowed gives the right remaining</TD></TR><TR><TD CLASS="l">2386</TD><TD>                                // quantity for each iteration.</TD></TR><TR CLASS="z"><TD CLASS="l">2387</TD><TD>                                ((Order) newTradable).getHandlingInstruction()</TD></TR><TR CLASS="z"><TD CLASS="l">2388</TD><TD>                                        .setDefaultMaxTradableQtyForIndexHybrid();</TD></TR><TR><TD CLASS="l">2389</TD><TD>                                // Reset reason code only if the remaining qty is not tradable BUT</TD></TR><TR><TD CLASS="l">2390</TD><TD>                                // not due to MQ or AutoX</TD></TR><TR CLASS="z"><TD CLASS="l">2391</TD><TD>                                if ((legTradeContainer.getQuantity() &lt; currentQuantity)</TD></TR><TR CLASS="z"><TD CLASS="l">2392</TD><TD>                                        &amp;&amp; !manualQuoteExists &amp;&amp; !hitMaxNonCustQty)</TD></TR><TR><TD CLASS="l">2393</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">2394</TD><TD>                                    ((Order) newTradable).getHandlingInstruction()</TD></TR><TR CLASS="z"><TD CLASS="l">2395</TD><TD>                                            .setDefaultOverRideReasonForIndexHybrid();</TD></TR><TR><TD CLASS="l">2396</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2397</TD><TD>                            }</TD></TR><TR><TD CLASS="l">2398</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2399</TD><TD> </TD></TR><TR><TD CLASS="l">2400</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2401</TD><TD>                    catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">2402</TD><TD>                    {</TD></TR><TR><TD CLASS="l">2403</TD><TD>                        Log</TD></TR><TR CLASS="z"><TD CLASS="l">2404</TD><TD>                                .information(&#34;No longer can trade with Legs since we do not have valid market on legs to calculate DerivedQuote for order: &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">2405</TD><TD>                                        + newTradable.toString());</TD></TR><TR><TD CLASS="l">2406</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2407</TD><TD>                }</TD></TR><TR><TD CLASS="l">2408</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2409</TD><TD>            if ((iterationCount == 1 &amp;&amp; manualQuoteExists) || hitMaxNonCustQty)</TD></TR><TR><TD CLASS="l">2410</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2411</TD><TD>                break;</TD></TR><TR><TD CLASS="l">2412</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2413</TD><TD>            if (currentQuantity == newTradable.getQuantityAllowed())</TD></TR><TR><TD CLASS="l">2414</TD><TD>            {</TD></TR><TR><TD CLASS="l">2415</TD><TD>                // If order traded at all tradable price points and went to the next price and was</TD></TR><TR><TD CLASS="l">2416</TD><TD>                // not tradable,</TD></TR><TR><TD CLASS="l">2417</TD><TD>                // then reset the index hybrid properties, so order gets booked (Canceled for IOC)</TD></TR><TR><TD CLASS="l">2418</TD><TD>                // and not returned back.</TD></TR><TR CLASS="z"><TD CLASS="l">2419</TD><TD>                if (isIndexHybridEnabled &amp;&amp; newTradable.isTradable(TradableTypes.ORDER))</TD></TR><TR><TD CLASS="l">2420</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2421</TD><TD>                    super.resetIndexHybridProperties((Order) newTradable);</TD></TR><TR><TD CLASS="l">2422</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2423</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2424</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2425</TD><TD>                    Log.debug(&#34;BrokerProcessorSpreadImpl.processTradable&gt;&gt;Quantity &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">2426</TD><TD>                            + currentQuantity + &#34; can not be allocated&#34;);</TD></TR><TR><TD CLASS="l">2427</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2428</TD><TD>                break; // trade did not happen. Stop trying to trade it again</TD></TR><TR><TD CLASS="l">2429</TD><TD>            }</TD></TR><TR><TD CLASS="l">2430</TD><TD>        }</TD></TR><TR><TD CLASS="l">2431</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2432</TD><TD>        if (totalTradedQuantity &gt; 0)</TD></TR><TR><TD CLASS="l">2433</TD><TD>        {</TD></TR><TR><TD CLASS="l">2434</TD><TD>            // refresh best books of leg products to publish CM out.</TD></TR><TR CLASS="z"><TD CLASS="l">2435</TD><TD>            TradingStrategyLeg[] products = product.getStrategyLegs();</TD></TR><TR><TD CLASS="l">2436</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">2437</TD><TD>            if (products != null)</TD></TR><TR><TD CLASS="l">2438</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2439</TD><TD>                for (int i = 0; i &lt; products.length; i++)</TD></TR><TR><TD CLASS="l">2440</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2441</TD><TD>                    TradingProduct impl = products[i].getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">2442</TD><TD>                    if (impl != null)   // ignore remote leg</TD></TR><TR CLASS="z"><TD CLASS="l">2443</TD><TD>                        impl.getOrderBook().refreshBestBook();</TD></TR><TR><TD CLASS="l">2444</TD><TD>                }</TD></TR><TR><TD CLASS="l">2445</TD><TD>            }</TD></TR><TR><TD CLASS="l">2446</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2447</TD><TD>    }</TD></TR><TR><TD CLASS="l">2448</TD><TD> </TD></TR><TR><TD CLASS="l">2449</TD><TD>    </TD></TR><TR><TD CLASS="l">2450</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l">2451</TD><TD>     * @see com.cboe.interfaces.domain.BrokerProcessor#processSpreadOrderForLegTrade(com.cboe.interfaces.domain.Order, com.cboe.interfaces.domain.AuctionInternal)</TD></TR><TR><TD CLASS="l"><A NAME="43">2452</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">2453</TD><TD>    public void processSpreadOrderForLegTrade_old(Order p_spreadOrder, AuctionInternal p_auction)</TD></TR><TR><TD CLASS="l">2454</TD><TD>            throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">2455</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2456</TD><TD>        int totalTradedQuantity = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2457</TD><TD>        TradingProduct product = getTradingProduct(p_spreadOrder.getProductKey());</TD></TR><TR><TD CLASS="l">2458</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2459</TD><TD>        Price tradeEndingPrice = (p_spreadOrder.getHandlingInstruction() != null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">2460</TD><TD>                !p_spreadOrder.getHandlingInstruction().getExecutionPrice().isNoPrice()) ?</TD></TR><TR CLASS="z"><TD CLASS="l">2461</TD><TD>                   p_spreadOrder.getHandlingInstruction().getExecutionPrice() : p_spreadOrder.getPrice();</TD></TR><TR><TD CLASS="l">2462</TD><TD>                   </TD></TR><TR CLASS="z"><TD CLASS="l">2463</TD><TD>        boolean isIndexHybridEnabled = IndexHybridStrategyHelper.isIndexHybridEnabled(product);</TD></TR><TR CLASS="z"><TD CLASS="l">2464</TD><TD>        boolean manualQuoteExists = IndexHybridStrategyHelper.manualQuoteExistsOnTradableLegSide(product, p_spreadOrder.getSide());</TD></TR><TR CLASS="z"><TD CLASS="l">2465</TD><TD>        int originalQuantity = p_spreadOrder.getQuantityAllowed();</TD></TR><TR CLASS="z"><TD CLASS="l">2466</TD><TD>        while(p_spreadOrder.getQuantityAllowed() &gt; 0 &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">2467</TD><TD>                product.areAllLegsValid()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2468</TD><TD>            DerivedQuote derivedQuote = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR CLASS="z"><TD CLASS="l">2469</TD><TD>            if (derivedQuote == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2470</TD><TD>                break;    // DQ can't be calculated</TD></TR><TR><TD CLASS="l">2471</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">2472</TD><TD>            StrategyLegTradeContainer legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(</TD></TR><TR CLASS="z"><TD CLASS="l">2473</TD><TD>                    p_spreadOrder.getSide(),tradeEndingPrice,p_spreadOrder.getQuantityAllowed(), p_spreadOrder.getMinQuantity(), product, derivedQuote);</TD></TR><TR><TD CLASS="l">2474</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2475</TD><TD>           if(IndexHybridStrategyHelper.checkOrderNeedsToBeReturned(p_spreadOrder, product, isIndexHybridEnabled, 1, legTradeContainer)){</TD></TR><TR CLASS="z"><TD CLASS="l">2476</TD><TD>               break;</TD></TR><TR><TD CLASS="l">2477</TD><TD>           }</TD></TR><TR><TD CLASS="l">2478</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2479</TD><TD>           if(!legTradeContainer.getCanTradeWithLegs())</TD></TR><TR CLASS="z"><TD CLASS="l">2480</TD><TD>               break;</TD></TR><TR><TD CLASS="l">2481</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2482</TD><TD>           boolean useSavedDQ = cleanupLegTimerBasedHoldups(product);</TD></TR><TR><TD CLASS="l">2483</TD><TD>           // get DQ again</TD></TR><TR CLASS="z"><TD CLASS="l">2484</TD><TD>           if(!(isRolledoutSpreadClass(product) &amp;&amp; useSavedDQ))  </TD></TR><TR><TD CLASS="l">2485</TD><TD>           {</TD></TR><TR CLASS="z"><TD CLASS="l">2486</TD><TD>               derivedQuote = StrategyTradeServiceHelper.getDerivedQuote(product);</TD></TR><TR><TD CLASS="l">2487</TD><TD>           }</TD></TR><TR><TD CLASS="l">2488</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2489</TD><TD>           if (derivedQuote == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2490</TD><TD>               break;</TD></TR><TR><TD CLASS="l">2491</TD><TD>           }</TD></TR><TR><TD CLASS="l">2492</TD><TD>           </TD></TR><TR CLASS="z"><TD CLASS="l">2493</TD><TD>           legTradeContainer = StrategyTradeServiceHelper.getStrategyLegTradeContainer(</TD></TR><TR CLASS="z"><TD CLASS="l">2494</TD><TD>                   p_spreadOrder.getSide(),tradeEndingPrice,p_spreadOrder.getQuantityAllowed(), p_spreadOrder.getMinQuantity(), product, derivedQuote);</TD></TR><TR><TD CLASS="l">2495</TD><TD>           </TD></TR><TR CLASS="z"><TD CLASS="l">2496</TD><TD>           if(!legTradeContainer.getCanTradeWithLegs()) </TD></TR><TR CLASS="z"><TD CLASS="l">2497</TD><TD>               break;</TD></TR><TR><TD CLASS="l">2498</TD><TD>           </TD></TR><TR><TD CLASS="l">2499</TD><TD>           // call proper TradeService method based on Auction or not</TD></TR><TR CLASS="z"><TD CLASS="l">2500</TD><TD>           int tradedQuantity = doSpreadOrderLegTrades(p_spreadOrder, derivedQuote, product, p_auction);  </TD></TR><TR><TD CLASS="l">2501</TD><TD>           </TD></TR><TR CLASS="z"><TD CLASS="l">2502</TD><TD>           totalTradedQuantity = totalTradedQuantity + tradedQuantity;</TD></TR><TR><TD CLASS="l">2503</TD><TD>           </TD></TR><TR CLASS="z"><TD CLASS="l">2504</TD><TD>           if(tradedQuantity &lt;= 0)</TD></TR><TR><TD CLASS="l">2505</TD><TD>           {</TD></TR><TR CLASS="z"><TD CLASS="l">2506</TD><TD>               break;</TD></TR><TR><TD CLASS="l">2507</TD><TD>           }</TD></TR><TR><TD CLASS="l">2508</TD><TD>        }</TD></TR><TR><TD CLASS="l">2509</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2510</TD><TD>        if (totalTradedQuantity &gt; 0)</TD></TR><TR><TD CLASS="l">2511</TD><TD>        {</TD></TR><TR><TD CLASS="l">2512</TD><TD>            // refresh best books of leg products to publish CM out.</TD></TR><TR CLASS="z"><TD CLASS="l">2513</TD><TD>            TradingStrategyLeg[] products = product.getStrategyLegs();</TD></TR><TR><TD CLASS="l">2514</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">2515</TD><TD>            if (products != null)</TD></TR><TR><TD CLASS="l">2516</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2517</TD><TD>                for (int i = 0; i &lt; products.length; i++)</TD></TR><TR><TD CLASS="l">2518</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2519</TD><TD>                    TradingProduct impl = products[i].getTradingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>                    if (impl != null)   // ignore remote leg</TD></TR><TR CLASS="z"><TD CLASS="l">2521</TD><TD>                        impl.getOrderBook().refreshBestBook();</TD></TR><TR><TD CLASS="l">2522</TD><TD>                }</TD></TR><TR><TD CLASS="l">2523</TD><TD>            }</TD></TR><TR><TD CLASS="l">2524</TD><TD>        }</TD></TR><TR><TD CLASS="l">2525</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2526</TD><TD>    }</TD></TR><TR><TD CLASS="l">2527</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="10">2528</A></TD><TD>    private int doSpreadOrderLegTrades(Order spreadOrder, DerivedQuote derivedQuote, </TD></TR><TR><TD CLASS="l">2529</TD><TD>            TradingProduct tradingProduct, AuctionInternal auction) </TD></TR><TR><TD CLASS="l">2530</TD><TD>        throws DataValidationException, SystemException</TD></TR><TR><TD CLASS="l">2531</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2532</TD><TD>        int tradedQuantity = 0;</TD></TR><TR><TD CLASS="l">2533</TD><TD>     // If Spread Protection enabled class and legs only contain auto quotes, do not try to trade with the legs</TD></TR><TR CLASS="z"><TD CLASS="l">2534</TD><TD>        if(!tradingProduct.getTradingClass().getAllowComplexTradesWithQuotes() &amp;&amp; StrategyTradeServiceHelper.checkLegsHaveAutoQuotes(spreadOrder,tradingProduct)&amp;&amp; notTAReturn(spreadOrder))</TD></TR><TR><TD CLASS="l">2535</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2536</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2537</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2538</TD><TD>                Log.debug(&#34;BrokerProcessorSpreadHybridImpl.doSpreadOrderLegTrades&gt;&gt; Legs only contain auto quotes. Return to STS &#34;+ tradingProduct.getProductKey());</TD></TR><TR><TD CLASS="l">2539</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2540</TD><TD>            return tradedQuantity;</TD></TR><TR><TD CLASS="l">2541</TD><TD>            }</TD></TR><TR><TD CLASS="l">2542</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2543</TD><TD>        if (auction == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2544</TD><TD>            tradedQuantity = tradeWithLegs(spreadOrder, derivedQuote, tradingProduct);</TD></TR><TR CLASS="z"><TD CLASS="l">2545</TD><TD>            return tradedQuantity;</TD></TR><TR><TD CLASS="l">2546</TD><TD>        } </TD></TR><TR><TD CLASS="l">2547</TD><TD>        try</TD></TR><TR><TD CLASS="l">2548</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2549</TD><TD>            tradedQuantity = getTradeService(tradingProduct).createSpreadAuctionTradeWithLegs(auction, spreadOrder);</TD></TR><TR><TD CLASS="l">2550</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2551</TD><TD>        catch (SpreadProcessingException e)</TD></TR><TR><TD CLASS="l">2552</TD><TD>        {</TD></TR><TR><TD CLASS="l">2553</TD><TD>            //SpreadProcessingException should consider as a &#34;normal&#34; spread processing condition, where </TD></TR><TR><TD CLASS="l">2554</TD><TD>            //spread leg prices can not be calculated. In this case, no trade will happen. Just log inforamtion </TD></TR><TR CLASS="z"><TD CLASS="l">2555</TD><TD>            Log.information(&#34;BrokerProcessorSpreadHyBridImpl&gt;&gt;doSpreadOrderLegTrades.&#34; + e.getMessage()); </TD></TR><TR><TD CLASS="l">2556</TD><TD>        }</TD></TR><TR><TD CLASS="l">2557</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2558</TD><TD>        return tradedQuantity;</TD></TR><TR><TD CLASS="l">2559</TD><TD>    }</TD></TR><TR><TD CLASS="l">2560</TD><TD>    </TD></TR><TR><TD CLASS="l">2561</TD><TD>    private boolean isRolledoutSpreadClass(TradingProduct tradingProduct) throws DataValidationException</TD></TR><TR><TD CLASS="l"><A NAME="2a">2562</A></TD><TD> </TD></TR><TR><TD CLASS="l">2563</TD><TD>    {</TD></TR><TR><TD CLASS="l">2564</TD><TD>        try</TD></TR><TR><TD CLASS="l">2565</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2566</TD><TD>            if (productDataCacheHome == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2567</TD><TD>                productDataCacheHome = (ProductDataCacheHome)HomeFactory.getInstance().findHome(ProductDataCacheHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">2568</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">2569</TD><TD>            return productDataCacheHome.find().getProductClassData(tradingProduct.getProductKeys().classKey).getSpreadServerRolloutIndicator();</TD></TR><TR><TD CLASS="l">2570</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2571</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">2572</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2573</TD><TD>            Log.alarm(this, &#34;TradingProduct + &#34; + tradingProduct.getProductKey() + &#34; failed to get Spread Server Rollout indicator.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2574</TD><TD>            throw ExceptionBuilder.dataValidationException(e.toString(),  DataValidationCodes.INVALID_PRODUCT_CLASS);</TD></TR><TR><TD CLASS="l">2575</TD><TD>        }</TD></TR><TR><TD CLASS="l">2576</TD><TD>    }</TD></TR><TR><TD CLASS="l">2577</TD><TD>    </TD></TR><TR><TD CLASS="l">2578</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="38">2579</A></TD><TD>     * process leg best book changed with proxy option leg changed</TD></TR><TR><TD CLASS="l">2580</TD><TD>     */</TD></TR><TR><TD CLASS="l">2581</TD><TD>    public void processLegBestBookChange(int productKey, Boolean marketImproved, boolean legTransitionToOpen)</TD></TR><TR><TD CLASS="l">2582</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2583</TD><TD>        TradingProduct tradingProduct = null;</TD></TR><TR><TD CLASS="l">2584</TD><TD>        try</TD></TR><TR><TD CLASS="l">2585</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2586</TD><TD>            tradingProduct = getTradingProduct(productKey);</TD></TR><TR><TD CLASS="l">2587</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2588</TD><TD>        catch(DataValidationException e)</TD></TR><TR><TD CLASS="l">2589</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2590</TD><TD>            Log.exception(this, &#34;TradingProduct not found for: &#34; + productKey +&#34;; won't proceed with processLegBestBookChange()&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">2591</TD><TD>            return;</TD></TR><TR><TD CLASS="l">2592</TD><TD>        }</TD></TR><TR><TD CLASS="l">2593</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2594</TD><TD>        if(tradingProduct.getOrderBook() == null)</TD></TR><TR><TD CLASS="l">2595</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2596</TD><TD>            Log.information(this, &#34;OrderBook not found for TradingProduct: &#34; + productKey +&#34;; won't proceed with processLegBestBookChange()&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2597</TD><TD>            return;</TD></TR><TR><TD CLASS="l">2598</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2599</TD><TD>        boolean cobEmpty = tradingProduct.getOrderBook().isEmpty();</TD></TR><TR CLASS="z"><TD CLASS="l">2600</TD><TD>        boolean noActiveAuction = ( (tradingProduct.getActiveAuction() == null) || </TD></TR><TR CLASS="z"><TD CLASS="l">2601</TD><TD>                                    (tradingProduct.getActiveAuction() != null &amp;&amp; !tradingProduct.getActiveAuction().isActive()));</TD></TR><TR><TD CLASS="l">2602</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2603</TD><TD>        if( noActiveAuction &amp;&amp; (!legTransitionToOpen) &amp;&amp; (cobEmpty) )</TD></TR><TR><TD CLASS="l">2604</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2605</TD><TD>            return;</TD></TR><TR><TD CLASS="l">2606</TD><TD>        }</TD></TR><TR><TD CLASS="l">2607</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2608</TD><TD>        this.processLegBestBookChange(productKey, false);</TD></TR><TR><TD CLASS="l">2609</TD><TD>        // if leg market improved, expire AIM complex auction</TD></TR><TR CLASS="z"><TD CLASS="l">2610</TD><TD>        if (marketImproved != null &amp;&amp; marketImproved) {</TD></TR><TR><TD CLASS="l">2611</TD><TD>            </TD></TR><TR><TD CLASS="l">2612</TD><TD>            try</TD></TR><TR><TD CLASS="l">2613</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2614</TD><TD>                if (isRolledoutSpreadClass(tradingProduct)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2615</TD><TD>                    AuctionInternal activeAuction = tradingProduct.getActiveAuction();</TD></TR><TR CLASS="z"><TD CLASS="l">2616</TD><TD>                    if (activeAuction != null &amp;&amp; activeAuction.getAuctionType() == AuctionTypes.AUCTION_INTERNALIZATION) {</TD></TR><TR><TD CLASS="l">2617</TD><TD>                            // to expire auction, to guarantee AIM trade</TD></TR><TR CLASS="z"><TD CLASS="l">2618</TD><TD>                            processAuctionExpire(activeAuction, AuctionTerminateReasons.LEG_CURRENT_MARKET_IMPROVED, null);</TD></TR><TR><TD CLASS="l">2619</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2620</TD><TD>                }</TD></TR><TR><TD CLASS="l">2621</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2622</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">2623</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2624</TD><TD>                Log.exception(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;processLegBestBookChange. Unable to expire active AIM auction&#34;, e);</TD></TR><TR><TD CLASS="l">2625</TD><TD>            }</TD></TR><TR><TD CLASS="l">2626</TD><TD>        }</TD></TR><TR><TD CLASS="l">2627</TD><TD>        </TD></TR><TR><TD CLASS="l">2628</TD><TD>        try{</TD></TR><TR CLASS="z"><TD CLASS="l">2629</TD><TD>            if(!cobEmpty &amp;&amp; (tradingProduct.getCurrentStateCode() == ProductStates.OPEN || tradingProduct.getCurrentStateCode() == ProductStates.FAST_MARKET)) </TD></TR><TR><TD CLASS="l">2630</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2631</TD><TD>                Integer classKey = tradingProduct.getTradingClass().getProductClassKey();</TD></TR><TR CLASS="z"><TD CLASS="l">2632</TD><TD>                getReCOAManagerHome().findByClass(classKey).validateAndStartReCOA(tradingProduct);</TD></TR><TR><TD CLASS="l">2633</TD><TD>            }</TD></TR><TR><TD CLASS="l">2634</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2635</TD><TD>        catch(Exception de)</TD></TR><TR><TD CLASS="l">2636</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2637</TD><TD>            Log.exception(&#34;BrokerProcessorSpreadHybridImpl&gt;&gt;validateAndStartReCOA method.&#34;, de);</TD></TR><TR><TD CLASS="l">2638</TD><TD>        }    </TD></TR><TR CLASS="z"><TD CLASS="l">2639</TD><TD>    }</TD></TR><TR><TD CLASS="l">2640</TD><TD>  </TD></TR><TR><TD CLASS="l">2641</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2642</TD><TD>     * This method sets the cap details required for PDPM allcoation during a strategy trade.</TD></TR><TR><TD CLASS="l">2643</TD><TD>     * 1. Get the strategy legs.</TD></TR><TR><TD CLASS="l">2644</TD><TD>     * 2. For each leg </TD></TR><TR><TD CLASS="l">2645</TD><TD>     *  a. Iterate through the book to find the tob tradables. If the tradable belongs to one of the preferred firms, add it to the map with the quantity. This map is of for FirmQtyMap&lt;Firm,Qty&gt;.</TD></TR><TR><TD CLASS="l">2646</TD><TD>     *  b. Create another map pmmCapDetails&lt;productKey,FirmQtyMap&gt; where product key is the key for the leg product and FirmQtyMap from (a) is the TOB info for that leg</TD></TR><TR><TD CLASS="l">2647</TD><TD>     * 3. Set the pmmCapDetails map in Spread Trading Product.</TD></TR><TR><TD CLASS="l">2648</TD><TD>     * @param spreadProduct</TD></TR><TR><TD CLASS="l">2649</TD><TD>     * @param spreadOrderSide</TD></TR><TR><TD CLASS="l">2650</TD><TD>     * @param preferredFirms</TD></TR><TR><TD CLASS="l">2651</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">2652</TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l">2653</TD><TD>     * @throws DataValidationException</TD></TR><TR><TD CLASS="l">2654</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="50">2655</A></TD><TD>    public void setPMMDetails(int spreadProduct, char spreadOrderSide, String[] preferredFirms)</TD></TR><TR><TD CLASS="l">2656</TD><TD>    throws SystemException, DataValidationException</TD></TR><TR><TD CLASS="l">2657</TD><TD>        {</TD></TR><TR><TD CLASS="l">2658</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2659</TD><TD>                HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt; pmmCapDetails = new HashMap&lt;Integer,HashMap&lt;String,Integer&gt;&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2660</TD><TD>                TradingProduct spreadTradingProduct = null;</TD></TR><TR><TD CLASS="l">2661</TD><TD>                try</TD></TR><TR><TD CLASS="l">2662</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2663</TD><TD>                         spreadTradingProduct = getTradingProductHome().findByKey(spreadProduct);</TD></TR><TR><TD CLASS="l">2664</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2665</TD><TD>                catch(NotFoundException e)</TD></TR><TR><TD CLASS="l">2666</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2667</TD><TD>                        throw ExceptionBuilder.dataValidationException(</TD></TR><TR CLASS="z"><TD CLASS="l">2668</TD><TD>                        &#34;Unable to find product: &#34; + spreadProduct,</TD></TR><TR CLASS="z"><TD CLASS="l">2669</TD><TD>                        DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">2670</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2671</TD><TD>                TradingStrategyLeg[] tLegs = spreadTradingProduct.getStrategyLegs();</TD></TR><TR><TD CLASS="l">2672</TD><TD>                </TD></TR><TR><TD CLASS="l">2673</TD><TD>                // Iterate through each leg to get the tob tradables. If a tradable belongs to a preferred firm, add it to the map.</TD></TR><TR CLASS="z"><TD CLASS="l">2674</TD><TD>                for(TradingStrategyLeg tLeg : tLegs)</TD></TR><TR><TD CLASS="l">2675</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2676</TD><TD>                        HashMap&lt;String, Integer&gt; preferredFirmCapQtyMap = new HashMap&lt;String, Integer&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2677</TD><TD>                        if (tLeg.getTradingProduct() == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2678</TD><TD>                            continue;</TD></TR><TR CLASS="z"><TD CLASS="l">2679</TD><TD>                    OrderBook legBook = tLeg.getTradingProduct().getOrderBook();</TD></TR><TR><TD CLASS="l">2680</TD><TD>                    Side legSideToTrade;</TD></TR><TR><TD CLASS="l">2681</TD><TD>                        Price legSideBestPrice;</TD></TR><TR><TD CLASS="l">2682</TD><TD>                        //Find the side of the leg that will trade with the spread if spread to leg trade happens.</TD></TR><TR CLASS="z"><TD CLASS="l">2683</TD><TD>                        if(spreadOrderSide == Sides.AS_DEFINED)</TD></TR><TR><TD CLASS="l">2684</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2685</TD><TD>                                legSideToTrade = tLeg.getSide().getOtherSide();</TD></TR><TR><TD CLASS="l">2686</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2687</TD><TD>                        else</TD></TR><TR><TD CLASS="l">2688</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>                                legSideToTrade = tLeg.getSide();</TD></TR><TR><TD CLASS="l">2690</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2691</TD><TD>                        BestBook bestBook = tLeg.getTradingProduct().getOrderBook().getBestBook();</TD></TR><TR CLASS="z"><TD CLASS="l">2692</TD><TD>                        if(legSideToTrade.isBuySide())</TD></TR><TR><TD CLASS="l">2693</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2694</TD><TD>                                legSideBestPrice = bestBook.getContingentBidPrice();</TD></TR><TR><TD CLASS="l">2695</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2696</TD><TD>                        else</TD></TR><TR><TD CLASS="l">2697</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2698</TD><TD>                                legSideBestPrice = bestBook.getContingentAskPrice();</TD></TR><TR><TD CLASS="l">2699</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2700</TD><TD>                        Enumeration topOfBookTradables = legBook.getTradables(legSideToTrade, legSideBestPrice);</TD></TR><TR CLASS="z"><TD CLASS="l">2701</TD><TD>                        while(topOfBookTradables.hasMoreElements())</TD></TR><TR><TD CLASS="l">2702</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2703</TD><TD>                                Tradable tradable = (Tradable) topOfBookTradables.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">2704</TD><TD>                             String pFirm = isPreferred(preferredFirms, tradable);</TD></TR><TR CLASS="z"><TD CLASS="l">2705</TD><TD>                             if ( pFirm!=null &amp;&amp; (tradable.treatedLikeQuote()))</TD></TR><TR><TD CLASS="l">2706</TD><TD>                             {</TD></TR><TR CLASS="z"><TD CLASS="l">2707</TD><TD>                                        Integer value = preferredFirmCapQtyMap.get(pFirm);</TD></TR><TR CLASS="z"><TD CLASS="l">2708</TD><TD>                                        Integer qty = value != null ? value.intValue():0;</TD></TR><TR CLASS="z"><TD CLASS="l">2709</TD><TD>                                 preferredFirmCapQtyMap.put(pFirm, new Integer(tradable.getQuantityAllowed() + qty));</TD></TR><TR><TD CLASS="l">2710</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2711</TD><TD>        </TD></TR><TR><TD CLASS="l">2712</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2713</TD><TD>                        if (preferredFirmCapQtyMap.size() &gt;0)</TD></TR><TR CLASS="z"><TD CLASS="l">2714</TD><TD>                            pmmCapDetails.put(tLeg.getProductKey(),preferredFirmCapQtyMap);</TD></TR><TR><TD CLASS="l">2715</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2716</TD><TD>                spreadTradingProduct.setPMMCapDetails(pmmCapDetails);</TD></TR><TR CLASS="z"><TD CLASS="l">2717</TD><TD>        }</TD></TR><TR><TD CLASS="l">2718</TD><TD>    </TD></TR><TR><TD CLASS="l">2719</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2720</TD><TD>        * Checks if the given tradable is from a PMM</TD></TR><TR><TD CLASS="l">2721</TD><TD>        * @param tieredPdmp</TD></TR><TR><TD CLASS="l">2722</TD><TD>        * @param tradable</TD></TR><TR><TD CLASS="l"><A NAME="29">2723</A></TD><TD>        * @return</TD></TR><TR><TD CLASS="l">2724</TD><TD>        */</TD></TR><TR><TD CLASS="l">2725</TD><TD>        protected String isPreferred(String[] tieredPdmp, Tradable tradable)</TD></TR><TR><TD CLASS="l">2726</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2727</TD><TD>        for (int i=0; i&lt; tieredPdmp.length; i++)</TD></TR><TR><TD CLASS="l">2728</TD><TD>        {</TD></TR><TR><TD CLASS="l">2729</TD><TD>                try</TD></TR><TR><TD CLASS="l">2730</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2731</TD><TD>                String userAcr = tradable.getOriginatorAcronym().acronym;</TD></TR><TR CLASS="z"><TD CLASS="l">2732</TD><TD>                if ( isThisAcrPreferred( userAcr, (String) tieredPdmp[i]) )</TD></TR><TR><TD CLASS="l">2733</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2734</TD><TD>                    return (String)tieredPdmp[i];</TD></TR><TR><TD CLASS="l">2735</TD><TD>                }</TD></TR><TR><TD CLASS="l">2736</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2737</TD><TD>                catch(UnsupportedOperationException uoe)</TD></TR><TR><TD CLASS="l">2738</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2739</TD><TD>                  Log.information(&#34;BrokerProcessorSpreadHybridImpl - Unsupported exception - &#34; + uoe.getMessage());</TD></TR><TR><TD CLASS="l">2740</TD><TD>            }</TD></TR><TR><TD CLASS="l">2741</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2742</TD><TD>        return null;</TD></TR><TR><TD CLASS="l"><A NAME="1a">2743</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2744</TD><TD> </TD></TR><TR><TD CLASS="l">2745</TD><TD>        private OrderRoutingDestination getOrderRoutingDestinationService()</TD></TR><TR><TD CLASS="l">2746</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2747</TD><TD>        if (orderRoutingDestinationService == null)</TD></TR><TR><TD CLASS="l">2748</TD><TD>        {</TD></TR><TR><TD CLASS="l">2749</TD><TD>            OrderRoutingDestinationHome h;</TD></TR><TR><TD CLASS="l">2750</TD><TD>            try</TD></TR><TR><TD CLASS="l">2751</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2752</TD><TD>                h = (OrderRoutingDestinationHome) HomeFactory.getInstance().findHome(</TD></TR><TR CLASS="z"><TD CLASS="l">2753</TD><TD>                        OrderRoutingDestinationHome.ROUTING_PROXY_HOME_NAME);</TD></TR><TR><TD CLASS="l">2754</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2755</TD><TD>                orderRoutingDestinationService = h.find();</TD></TR><TR><TD CLASS="l">2756</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2757</TD><TD>            catch (CBOELoggableException e)</TD></TR><TR><TD CLASS="l">2758</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2759</TD><TD>                Log.exception(e);</TD></TR><TR><TD CLASS="l">2760</TD><TD>            }</TD></TR><TR><TD CLASS="l">2761</TD><TD>        }</TD></TR><TR><TD CLASS="l">2762</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2763</TD><TD>        return orderRoutingDestinationService;</TD></TR><TR><TD CLASS="l">2764</TD><TD>    }</TD></TR><TR><TD CLASS="l">2765</TD><TD>    </TD></TR><TR><TD CLASS="l">2766</TD><TD>}</TD></TR><TR><TD CLASS="l">2767</TD><TD> </TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../Coverage.html">all classes</A>][<A HREF="71.html">com.cboe.businessServices.brokerService</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 2</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>