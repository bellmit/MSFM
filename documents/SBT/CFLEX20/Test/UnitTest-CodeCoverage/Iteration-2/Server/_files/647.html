<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon May 16 15:10:41 CDT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="5c.html">com.cboe.internalBusinessServices.productService</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">ProductDownloadController.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>ProductDownloadController.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/77)</TD><TD CLASS="h">0%   (0/2617)</TD><TD CLASS="h">0%   (0/618)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">ProductDownloadController</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/77)</TD><TD CLASS="h">0%   (0/2617)</TD><TD CLASS="h">0%   (0/618)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">ProductDownloadController (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#3">activateProductAndItsClass (Product): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">baseProductType (int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#5">buildProductDescriptionForSpreadFrom (ProductDescriptionStruct): ProductDescr...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">checkTimeout (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#7">connectTie (): POA_ProductDefinitionInterface_tie</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">create (String, BOHome): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#9">defineClasses (String, String, short, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/192)</TD><TD CLASS="h">0%   (0/55)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">defineClasses (String, short, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/101)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#b">defineReportingClasses (ProductClass, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">disconnectTie (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#d">downloadProductDefinitions (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/175)</TD><TD CLASS="h">0%   (0/45)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">excludeClassesWithDerivatives (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/82)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#f">excludeStrategyClassesWithActiveFuture (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/113)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">findOptionProductClass (String, String []): ProductClass</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getCallback (): ProductDefinitionInterface</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getDownloadTimeout (): long</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getExpirationManager (): ProductExpirationManager</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getMaintenanceService (): ProductMaintenanceService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getProductClassHome (): ProductClassHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getProductClassKeys (short): HashSet</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#17">getProductDescriptionHome (): ProductDescriptionHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">getProductDescriptionNameForSpread (ProductDescriptionStruct): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#19">getProductForSymbol (ProductNameStruct): Product</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">getProductHome (): ProductHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">getProductTypeHome (): ProductTypeHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">getReportingClassHome (): ReportingClassHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">getReportingClassKeys (short): HashSet</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">getSessionCodesForProductType (ProductType): SessionCodeDescriptionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">getTie (): POA_ProductDefinitionInterface_tie</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">getTipsService (): TIPSProductService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#21">getTpfService (): TPFProductService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">isDownloadInProgress (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#23">loadSymbolMap (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/52)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">markProductClassesInactive (HashSet): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#25">markReportingClassesInactive (HashSet): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">publishAfterDownload (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/38)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#27">remapClasses (String, String [], HashMap): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">removeFromProductClassSet (int, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#29">removeFromProductSet (ProductStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">removeFromReportingClassSet (int, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">removeReportingClassesFromSet (ReportingClass []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">reportingClassUpdateComplete (String, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/131)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">resetDownloadTimer (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">setStepName (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">setTipsIndicator (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">setTpfIndicator (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#31">showDownloadStatus (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">skipTipsDownload (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#33">stopProductDownload (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">tipsDownloadInitialize (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/84)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#35">tipsDownloadPostProcess (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/70)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">tpfDownloadInitialize (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#37">tpfDownloadPostProcess (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">underlyingUpdateComplete (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#39">updateProduct (ProductStruct): ProductStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">updateProductClass (ClassDefinitionStruct): ProductClassStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">updateProductClassV6 (ClassDefinitionStructV6): ProductClassStructV6</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">updateProductClassWithKey (ClassDefinitionStructV2): ProductClassStructV2</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">updateProductClassWithKeyV3 (ClassDefinitionStructV3): ProductClassStructV3</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">updateProductClassWithKeyV6 (ClassDefinitionStructV6): ProductClassStructV6</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">updateProductClassWithSessionCode (ClassDefinitionStruct, String): ProductCla...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">updateProductDescription (ReportingClassStruct, ProductDescriptionStruct, Str...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/157)</TD><TD CLASS="h">0%   (0/35)</TD></TR><TR><TD CLASS="f"><A HREF="#41">updateProductV2 (ProductStructV2): ProductStructV2</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">updateProductV4 (ProductStructV4): ProductStructV4</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#43">updateProductWithKey (ProductStructV3): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">updateProductWithKeyV4 (ProductStructV4): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#45">updateProducts (ProductStruct []): ProductStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">updateProductsV4 (ProductStructV4 []): ProductStructV4 []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#47">updateProductsWithKey (ProductStructV3 []): ProductResultStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">updateProductsWithKeyV4 (ProductStructV4 []): ProductResultStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#49">updateReportingClass (ReportingClassStruct): ReportingClassStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">updateReportingClassWithKey (ReportingClassStructV2): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">validateBaseDescription (ProductDescriptionStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/128)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">waitForTipsCompletion (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">waitForTpfCompletion (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/7)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>package com.cboe.internalBusinessServices.productService;</TD></TR><TR><TD CLASS="l">2</TD><TD> </TD></TR><TR><TD CLASS="l">3</TD><TD>import com.cboe.domain.util.ProductStructBuilder;</TD></TR><TR><TD CLASS="l">4</TD><TD>import com.cboe.infrastructureServices.foundationFramework.*;</TD></TR><TR><TD CLASS="l">5</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Log;</TD></TR><TR><TD CLASS="l">6</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Transaction;</TD></TR><TR><TD CLASS="l">7</TD><TD>import com.cboe.infrastructureServices.orbService.*;</TD></TR><TR><TD CLASS="l">8</TD><TD>import com.cboe.interfaces.internalBusinessServices.*;</TD></TR><TR><TD CLASS="l">9</TD><TD>import com.cboe.interfaces.externalIntegrationServices.*;</TD></TR><TR><TD CLASS="l">10</TD><TD>import com.cboe.interfaces.domain.product.*;</TD></TR><TR><TD CLASS="l">11</TD><TD>import com.cboe.idl.internalBusinessServices.POA_ProductDefinitionInterface_tie;</TD></TR><TR><TD CLASS="l">12</TD><TD>import com.cboe.idl.cmiProduct.*;</TD></TR><TR><TD CLASS="l">13</TD><TD>import com.cboe.idl.product.*;</TD></TR><TR><TD CLASS="l">14</TD><TD>import com.cboe.idl.cmiConstants.ProductTypes;</TD></TR><TR><TD CLASS="l">15</TD><TD>import com.cboe.idl.cmiConstants.ListingStates;</TD></TR><TR><TD CLASS="l">16</TD><TD>import com.cboe.exceptions.*;</TD></TR><TR><TD CLASS="l">17</TD><TD>import com.cboe.interfaces.events.*;</TD></TR><TR><TD CLASS="l">18</TD><TD>import com.cboe.server.events.*;</TD></TR><TR><TD CLASS="l">19</TD><TD>import com.cboe.util.*;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">24</TD><TD>import com.cboe.server.util.ObjectResolver;</TD></TR><TR><TD CLASS="l">25</TD><TD> </TD></TR><TR><TD CLASS="l">26</TD><TD>/**</TD></TR><TR><TD CLASS="l">27</TD><TD> * A controller from the product download process.</TD></TR><TR><TD CLASS="l">28</TD><TD> *</TD></TR><TR><TD CLASS="l">29</TD><TD> * @author John Wickberg</TD></TR><TR><TD CLASS="l">30</TD><TD> */</TD></TR><TR><TD CLASS="l">31</TD><TD>public class ProductDownloadController extends BObject implements ProductDefinitionInterface</TD></TR><TR><TD CLASS="l"><A NAME="0">32</A></TD><TD>{</TD></TR><TR><TD CLASS="l">33</TD><TD>    /**</TD></TR><TR><TD CLASS="l">34</TD><TD>     * Name of the symbol mapping file.</TD></TR><TR><TD CLASS="l">35</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">36</TD><TD>    private static String SYMBOL_MAP_FILE=&#34;symbolMapFile&#34;;</TD></TR><TR><TD CLASS="l">37</TD><TD>        /**</TD></TR><TR><TD CLASS="l">38</TD><TD>         * A time period used while waiting for TIPS and TPF.</TD></TR><TR><TD CLASS="l">39</TD><TD>         */</TD></TR><TR><TD CLASS="l">40</TD><TD>        private static final long WAIT_PERIOD = 5000;</TD></TR><TR><TD CLASS="l">41</TD><TD>        /**</TD></TR><TR><TD CLASS="l">42</TD><TD>         * A reference to the product maintenance service.</TD></TR><TR><TD CLASS="l">43</TD><TD>         */</TD></TR><TR><TD CLASS="l">44</TD><TD>        private ProductMaintenanceService maintenanceService;</TD></TR><TR><TD CLASS="l">45</TD><TD>        /**</TD></TR><TR><TD CLASS="l">46</TD><TD>         * A reference to the home for product classes.</TD></TR><TR><TD CLASS="l">47</TD><TD>         */</TD></TR><TR><TD CLASS="l">48</TD><TD>        private ProductClassHome productClassHome;</TD></TR><TR><TD CLASS="l">49</TD><TD>        /**</TD></TR><TR><TD CLASS="l">50</TD><TD>         * A reference to the home for product descriptions.</TD></TR><TR><TD CLASS="l">51</TD><TD>         */</TD></TR><TR><TD CLASS="l">52</TD><TD>        private ProductDescriptionHome productDescriptionHome;</TD></TR><TR><TD CLASS="l">53</TD><TD>        /**</TD></TR><TR><TD CLASS="l">54</TD><TD>         * A reference to the home for reporting classes.</TD></TR><TR><TD CLASS="l">55</TD><TD>         */</TD></TR><TR><TD CLASS="l">56</TD><TD>        private ReportingClassHome reportingClassHome;</TD></TR><TR><TD CLASS="l">57</TD><TD>        /**</TD></TR><TR><TD CLASS="l">58</TD><TD>         * A reference to the home for products.</TD></TR><TR><TD CLASS="l">59</TD><TD>         */</TD></TR><TR><TD CLASS="l">60</TD><TD>        private ProductHome productHome;</TD></TR><TR><TD CLASS="l">61</TD><TD>        /**</TD></TR><TR><TD CLASS="l">62</TD><TD>         * A reference to the home for product types.</TD></TR><TR><TD CLASS="l">63</TD><TD>         */</TD></TR><TR><TD CLASS="l">64</TD><TD>        private ProductTypeHome productTypeHome;</TD></TR><TR><TD CLASS="l">65</TD><TD>        /**</TD></TR><TR><TD CLASS="l">66</TD><TD>         * An indicator that is set to &lt;code&gt;true&lt;/code&gt; while a download is in progress.</TD></TR><TR><TD CLASS="l">67</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">68</TD><TD>        private boolean downloadInProgress = false;</TD></TR><TR><TD CLASS="l">69</TD><TD>        /**</TD></TR><TR><TD CLASS="l">70</TD><TD>         * An indicator that is set to &lt;code&gt;true&lt;/code&gt; if the current download should</TD></TR><TR><TD CLASS="l">71</TD><TD>         * be interrupted.</TD></TR><TR><TD CLASS="l">72</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">73</TD><TD>        private boolean downloadInterrupted = true;</TD></TR><TR><TD CLASS="l">74</TD><TD>        /**</TD></TR><TR><TD CLASS="l">75</TD><TD>         * An indicator that is set to &lt;code&gt;true&lt;/code&gt; while the TIPS product</TD></TR><TR><TD CLASS="l">76</TD><TD>         * download is in progress.</TD></TR><TR><TD CLASS="l">77</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>        private boolean tipsInProgress = false;</TD></TR><TR><TD CLASS="l">79</TD><TD>    /**</TD></TR><TR><TD CLASS="l">80</TD><TD>     * Number of classes downloaded from Tips</TD></TR><TR><TD CLASS="l">81</TD><TD>     */</TD></TR><TR><TD CLASS="l">82</TD><TD>    private int numberSymbolsFromTips;</TD></TR><TR><TD CLASS="l">83</TD><TD>        /**</TD></TR><TR><TD CLASS="l">84</TD><TD>         * An indicator that is set to &lt;code&gt;true&lt;/code&gt; while the TPF product</TD></TR><TR><TD CLASS="l">85</TD><TD>         * download is in progress.</TD></TR><TR><TD CLASS="l">86</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">87</TD><TD>        private boolean tpfInProgress = false;</TD></TR><TR><TD CLASS="l">88</TD><TD>        /**</TD></TR><TR><TD CLASS="l">89</TD><TD>         * Current step in download process.  Used for status.</TD></TR><TR><TD CLASS="l">90</TD><TD>         */</TD></TR><TR><TD CLASS="l">91</TD><TD>        private String downloadStepName;</TD></TR><TR><TD CLASS="l">92</TD><TD>        /**</TD></TR><TR><TD CLASS="l">93</TD><TD>         * Time of last update message during a download.</TD></TR><TR><TD CLASS="l">94</TD><TD>         */</TD></TR><TR><TD CLASS="l">95</TD><TD>        private long lastUpdateTime;</TD></TR><TR><TD CLASS="l">96</TD><TD>        /**</TD></TR><TR><TD CLASS="l">97</TD><TD>         * Sets of active product classes by product type.  The sets are created in</TD></TR><TR><TD CLASS="l">98</TD><TD>         * tipsDownloadInitialize and used in tipsDownloadPostProcess.</TD></TR><TR><TD CLASS="l">99</TD><TD>         */</TD></TR><TR><TD CLASS="l">100</TD><TD>        private HashSet[] productClassKeys;</TD></TR><TR><TD CLASS="l">101</TD><TD>        /**</TD></TR><TR><TD CLASS="l">102</TD><TD>         * Sets of active reporting classes by product type.  The sets are created in</TD></TR><TR><TD CLASS="l">103</TD><TD>         * tipsDownloadInitialize and used in tipsDownloadPostProcess.</TD></TR><TR><TD CLASS="l">104</TD><TD>         */</TD></TR><TR><TD CLASS="l">105</TD><TD>        private HashSet[] reportingClassKeys;</TD></TR><TR><TD CLASS="l">106</TD><TD>        /**</TD></TR><TR><TD CLASS="l">107</TD><TD>         * A set of active product keys.  The set is created in tpfDownloadInitialize</TD></TR><TR><TD CLASS="l">108</TD><TD>         * and used in tpfDownloadPostProcess.</TD></TR><TR><TD CLASS="l">109</TD><TD>         */</TD></TR><TR><TD CLASS="l">110</TD><TD>        private HashSet productKeys;</TD></TR><TR><TD CLASS="l">111</TD><TD>        /**</TD></TR><TR><TD CLASS="l">112</TD><TD>         * Reference to the tie created for the service.  Needed for callback value in calls</TD></TR><TR><TD CLASS="l">113</TD><TD>         * to the TPF adapter.</TD></TR><TR><TD CLASS="l">114</TD><TD>         */</TD></TR><TR><TD CLASS="l">115</TD><TD>        private POA_ProductDefinitionInterface_tie downloadControllerTie;</TD></TR><TR><TD CLASS="l">116</TD><TD>        /**</TD></TR><TR><TD CLASS="l">117</TD><TD>         * Reference to callback associated with tie of this controller.</TD></TR><TR><TD CLASS="l">118</TD><TD>         */</TD></TR><TR><TD CLASS="l">119</TD><TD>        private com.cboe.idl.internalBusinessServices.ProductDefinitionInterface downloadControllerCallback;</TD></TR><TR><TD CLASS="l">120</TD><TD>        /**</TD></TR><TR><TD CLASS="l">121</TD><TD>         * Cached reference to the TIPS product service.</TD></TR><TR><TD CLASS="l">122</TD><TD>         */</TD></TR><TR><TD CLASS="l">123</TD><TD>        private TIPSProductService tipsService;</TD></TR><TR><TD CLASS="l">124</TD><TD>        /**</TD></TR><TR><TD CLASS="l">125</TD><TD>         * Cached reference to the TPF product service.</TD></TR><TR><TD CLASS="l">126</TD><TD>         */</TD></TR><TR><TD CLASS="l">127</TD><TD>        private TPFProductService tpfService;</TD></TR><TR><TD CLASS="l">128</TD><TD>        /**</TD></TR><TR><TD CLASS="l">129</TD><TD>         * Number of classes left to be downloaded from TPF.</TD></TR><TR><TD CLASS="l">130</TD><TD>         */</TD></TR><TR><TD CLASS="l">131</TD><TD>        private int tpfClassesRemainingCount;</TD></TR><TR><TD CLASS="l">132</TD><TD>    /**</TD></TR><TR><TD CLASS="l">133</TD><TD>     * OVERWRIDE Mapping of reporting classes to product class.</TD></TR><TR><TD CLASS="l">134</TD><TD>     * Key = reporting class symbol &amp; value is product class symbol.</TD></TR><TR><TD CLASS="l">135</TD><TD>     * This mapping is used to force certain rpeorting classes to point</TD></TR><TR><TD CLASS="l">136</TD><TD>     * to specific product classes.</TD></TR><TR><TD CLASS="l">137</TD><TD>     * These values are loaded from configuration.</TD></TR><TR><TD CLASS="l">138</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>     private java.util.Properties reportingClassSymbolMap = new java.util.Properties();</TD></TR><TR><TD CLASS="l">140</TD><TD> </TD></TR><TR><TD CLASS="l">141</TD><TD>    private ProductExpirationManager expirationManager;</TD></TR><TR CLASS="z"><TD CLASS="l">142</TD><TD>    private static String SKIP_TIPS_DOWNLOAD = &#34;skipTipsDownload&#34;;</TD></TR><TR><TD CLASS="l">143</TD><TD> </TD></TR><TR><TD CLASS="l">144</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="2">145</A></TD><TD> * ProductDownloadController constructor comment.</TD></TR><TR><TD CLASS="l">146</TD><TD> */</TD></TR><TR><TD CLASS="l">147</TD><TD>public ProductDownloadController()</TD></TR><TR><TD CLASS="l">148</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">149</TD><TD>        super();</TD></TR><TR CLASS="z"><TD CLASS="l">150</TD><TD>}</TD></TR><TR><TD CLASS="l">151</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="6">152</A></TD><TD> * Checks to see if time since last update exceeds time out period.</TD></TR><TR><TD CLASS="l">153</TD><TD> */</TD></TR><TR><TD CLASS="l">154</TD><TD>private void checkTimeout() throws InterruptedException</TD></TR><TR><TD CLASS="l">155</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>        if (System.currentTimeMillis() - lastUpdateTime &gt; getDownloadTimeout())</TD></TR><TR><TD CLASS="l">157</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">158</TD><TD>                throw new InterruptedException(&#34;Download interrupted due to timeout&#34;);</TD></TR><TR><TD CLASS="l">159</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>}</TD></TR><TR><TD CLASS="l">161</TD><TD>/**</TD></TR><TR><TD CLASS="l">162</TD><TD> * Returns a reference to the &#34;tie&#34; of the maintenance service.  This reference is</TD></TR><TR><TD CLASS="l">163</TD><TD> * needed as a callback value in calls to the Tips and Tpf services during product</TD></TR><TR><TD CLASS="l">164</TD><TD> * downloads.</TD></TR><TR><TD CLASS="l">165</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="7">166</A></TD><TD> * @return &#34;tie&#34; for this controller</TD></TR><TR><TD CLASS="l">167</TD><TD> */</TD></TR><TR><TD CLASS="l">168</TD><TD>private POA_ProductDefinitionInterface_tie connectTie()</TD></TR><TR><TD CLASS="l">169</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">170</TD><TD>        if (downloadControllerTie == null)</TD></TR><TR><TD CLASS="l">171</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">172</TD><TD>                downloadControllerTie = new POA_ProductDefinitionInterface_tie(this);</TD></TR><TR><TD CLASS="l">173</TD><TD>                try</TD></TR><TR><TD CLASS="l">174</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                        org.omg.CORBA.Object callback = POAHelper.connect(downloadControllerTie, null);</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>                        downloadControllerCallback = (com.cboe.idl.internalBusinessServices.ProductDefinitionInterface) ObjectResolver.resolveObject(callback, com.cboe.idl.internalBusinessServices.ProductDefinitionInterfaceHelper.class.getName() );</TD></TR><TR><TD CLASS="l">177</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                catch (NoSuchPOAException e)</TD></TR><TR><TD CLASS="l">179</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>                        Log.exception(this, &#34;Unable to connect download controller callback to POA&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">181</TD><TD>            Log.alarm(this, &#34;DOWNLOAD ERROR: Failed to create CORBA callback&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">182</TD><TD>                        downloadControllerTie = null;</TD></TR><TR CLASS="z"><TD CLASS="l">183</TD><TD>                        throw new NullPointerException(&#34;Unable to create CORBA callback&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">184</TD><TD>                }</TD></TR><TR><TD CLASS="l">185</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>        return downloadControllerTie;</TD></TR><TR><TD CLASS="l">187</TD><TD>}</TD></TR><TR><TD CLASS="l">188</TD><TD>/**</TD></TR><TR><TD CLASS="l">189</TD><TD> * Creates an valid instance of the service.</TD></TR><TR><TD CLASS="l">190</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="8">191</A></TD><TD> * @param name name of this object</TD></TR><TR><TD CLASS="l">192</TD><TD> */</TD></TR><TR><TD CLASS="l">193</TD><TD>public void create(String name, BOHome home)</TD></TR><TR><TD CLASS="l">194</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>        super.create(name);</TD></TR><TR><TD CLASS="l">196</TD><TD>        // Export a callback so the admin service can be used to request downloads.</TD></TR><TR><TD CLASS="l">197</TD><TD>        try</TD></TR><TR><TD CLASS="l">198</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">199</TD><TD>                home.registerCommand(this, &#34;showDownloadStatus&#34;, &#34;showDownloadStatus&#34;, &#34;Shows the current product downloading status&#34;, new String[0], new String[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                home.registerCommand(this, &#34;stopProductDownload&#34;, &#34;stopProductDownload&#34;, &#34;Stops the current product download&#34;, new String[0], new String[0]);</TD></TR><TR><TD CLASS="l">201</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>        catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">203</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                Log.alarm(this, &#34;Could not register a command with callback service&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>}</TD></TR><TR><TD CLASS="l">207</TD><TD>/**</TD></TR><TR><TD CLASS="l">208</TD><TD> * Disconnects the tie so that it can't be used.  The tie is disconnected if the download</TD></TR><TR><TD CLASS="l">209</TD><TD> * is interrupted or an unexpected exception occurs.  This will cause servers using the</TD></TR><TR><TD CLASS="l"><A NAME="c">210</A></TD><TD> * tie to get errors and stop their download processing.</TD></TR><TR><TD CLASS="l">211</TD><TD> */</TD></TR><TR><TD CLASS="l">212</TD><TD>private void disconnectTie()</TD></TR><TR><TD CLASS="l">213</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>        if (getTie() != null)</TD></TR><TR><TD CLASS="l">215</TD><TD>        {</TD></TR><TR><TD CLASS="l">216</TD><TD>                try</TD></TR><TR><TD CLASS="l">217</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                        POAHelper.disconnect(getTie(), null);</TD></TR><TR><TD CLASS="l">219</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">220</TD><TD>                catch (NoSuchPOAException e)</TD></TR><TR><TD CLASS="l">221</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                        Log.exception(this, &#34;Unable to disconnect from POA&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                }</TD></TR><TR><TD CLASS="l">224</TD><TD>                // need to reconnect on next try</TD></TR><TR><TD CLASS="l">225</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>        downloadControllerTie = null;</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>}</TD></TR><TR><TD CLASS="l">228</TD><TD>/**</TD></TR><TR><TD CLASS="l">229</TD><TD> * Defines underlying and reporting classes for products defined in Tips.  Called during Tips download to give base symbol and all</TD></TR><TR><TD CLASS="l">230</TD><TD> * aliases for each symbol defined in Tips.</TD></TR><TR><TD CLASS="l">231</TD><TD> *</TD></TR><TR><TD CLASS="l">232</TD><TD> * @param underlyingProductSymbol symbol of the underlying product</TD></TR><TR><TD CLASS="l">233</TD><TD> * @param productClassSymbol symbol of the product class.</TD></TR><TR><TD CLASS="l">234</TD><TD> * @param productType product type code of the underlying product</TD></TR><TR><TD CLASS="l">235</TD><TD> * @param reportingClasses all of the defined aliases for the product.  An option class will be defined underlying symbol and each</TD></TR><TR><TD CLASS="l">236</TD><TD> *                         of the aliases</TD></TR><TR><TD CLASS="l">237</TD><TD> * @exception DataValidationException if transaction fails</TD></TR><TR><TD CLASS="l"><A NAME="9">238</A></TD><TD> *</TD></TR><TR><TD CLASS="l">239</TD><TD> */</TD></TR><TR><TD CLASS="l">240</TD><TD>private void defineClasses(String underlyingProductSymbol, String productClassSymbol, short productType, String[] reportingClasses) throws DataValidationException {</TD></TR><TR><TD CLASS="l">241</TD><TD>        // check for existing option class - if found use as starting point for symbol changes.</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>        ProductClass productClass = findOptionProductClass(productClassSymbol, reportingClasses);</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>        if (productClass != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>                boolean committed = false;</TD></TR><TR><TD CLASS="l">245</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">247</TD><TD>                        // update product class</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                        String currentSymbol = productClass.getSymbol();</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                        productClass.setSymbol(productClassSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                        productClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                        removeFromProductClassSet(productClass.getClassKey(), ProductTypes.OPTION);</TD></TR><TR><TD CLASS="l">252</TD><TD> </TD></TR><TR><TD CLASS="l">253</TD><TD>                        // update the strategy classes for the options</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                        ReportingClass strategyReportingClass = getReportingClassHome().findBySymbol(currentSymbol, ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                        strategyReportingClass.setSymbol(productClassSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                        strategyReportingClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR><TD CLASS="l">257</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                        ProductClass strategyProductClass = strategyReportingClass.getProductClass();</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                        strategyProductClass.setSymbol(productClassSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                        strategyProductClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR><TD CLASS="l">261</TD><TD> </TD></TR><TR><TD CLASS="l">262</TD><TD>                        // update symbol of underlying and its classes</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                        Product underlyingProduct = productClass.getUnderlyingProduct();</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>                        ProductNameStruct newName = ProductStructBuilder.buildProductNameStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>                        newName.productSymbol = underlyingProductSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">266</TD><TD>                        underlyingProduct.updateName(newName);</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                        underlyingProduct.setListingState(ListingStates.ACTIVE);</TD></TR><TR><TD CLASS="l">268</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                        ProductClass underlyingProductClass = underlyingProduct.getProductClass();</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                        underlyingProductClass.setSymbol(underlyingProductSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>                        underlyingProductClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                        removeFromProductClassSet(underlyingProductClass.getClassKey(), underlyingProductClass.getProductType());</TD></TR><TR><TD CLASS="l">273</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                        ReportingClass underlyingReportingClass = underlyingProduct.getReportingClass();</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                        underlyingReportingClass.setSymbol(underlyingProductSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                        underlyingReportingClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                        removeFromReportingClassSet(underlyingReportingClass.getClassKey(), underlyingReportingClass.getProductType());</TD></TR><TR><TD CLASS="l">278</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                        committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">280</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>                        Log.exception(this, &#34;Unexpected exception during processing reporting class update&#34;, e);</TD></TR><TR><TD CLASS="l">283</TD><TD>                }</TD></TR><TR><TD CLASS="l">284</TD><TD>                finally {</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                        if (!committed) {</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>                                Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                                throw ExceptionBuilder.dataValidationException(&#34;Assuming that data problems caused transaction to fail&#34;, 0); // fixme</TD></TR><TR><TD CLASS="l">288</TD><TD>                        }</TD></TR><TR><TD CLASS="l">289</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>        }</TD></TR><TR><TD CLASS="l">291</TD><TD>        else {</TD></TR><TR><TD CLASS="l">292</TD><TD>                try {</TD></TR><TR><TD CLASS="l">293</TD><TD>                        // no option class found, must be new symbol</TD></TR><TR><TD CLASS="l">294</TD><TD>                        // create underlying product if not found, else update to be active if exist</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                        ProductStruct newProduct = ProductStructBuilder.buildProductStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">296</TD><TD>                        newProduct.productKeys.productType = productType;</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                        newProduct.productName.productSymbol = underlyingProductSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                        newProduct.listingState = ListingStates.ACTIVE;</TD></TR><TR><TD CLASS="l">299</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>            Product underlyingProduct = getProductForSymbol(newProduct.productName);</TD></TR><TR><TD CLASS="l">301</TD><TD> </TD></TR><TR><TD CLASS="l">302</TD><TD>            // to decide either update or add</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>            if(underlyingProduct == null)</TD></TR><TR><TD CLASS="l">304</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>                            getMaintenanceService().addProduct(newProduct);</TD></TR><TR><TD CLASS="l">306</TD><TD>            }</TD></TR><TR><TD CLASS="l">307</TD><TD>            else</TD></TR><TR><TD CLASS="l">308</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">309</TD><TD>                activateProductAndItsClass(underlyingProduct);</TD></TR><TR><TD CLASS="l">310</TD><TD>            }</TD></TR><TR><TD CLASS="l">311</TD><TD> </TD></TR><TR><TD CLASS="l">312</TD><TD>                        // Create product class for options</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                        ClassDefinitionStruct newProductClass = ProductStructBuilder.buildClassDefinitionStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                        newProductClass.classSymbol = productClassSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                        newProductClass.productType = ProductTypes.OPTION;</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>                        newProductClass.underlyingProduct.productName.productSymbol = underlyingProductSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                        newProductClass.listingState = ListingStates.ACTIVE;</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>                        getMaintenanceService().addProductClass(newProductClass);</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                        productClass = getProductClassHome().findBySymbol(productClassSymbol, ProductTypes.OPTION);</TD></TR><TR><TD CLASS="l">320</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>                        Log.exception(this, &#34;Unexpected exception when adding underlying product and product class&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                        throw ExceptionBuilder.dataValidationException(&#34;Assuming that data problems caused transaction to fail&#34;, 0); // fixme</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                }</TD></TR><TR><TD CLASS="l">325</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>        defineReportingClasses(productClass, reportingClasses);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3">327</A></TD><TD>}</TD></TR><TR><TD CLASS="l">328</TD><TD> </TD></TR><TR><TD CLASS="l">329</TD><TD>private void activateProductAndItsClass(Product underlyingProduct) throws DataValidationException</TD></TR><TR><TD CLASS="l">330</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                boolean committed = false;</TD></TR><TR><TD CLASS="l">332</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                        underlyingProduct.setListingState(ListingStates.ACTIVE);</TD></TR><TR><TD CLASS="l">335</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                        ProductClass underlyingProductClass = underlyingProduct.getProductClass();</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>            if(underlyingProductClass != null)</TD></TR><TR><TD CLASS="l">338</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>                            underlyingProductClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                            removeFromProductClassSet(underlyingProductClass.getClassKey(), underlyingProductClass.getProductType());</TD></TR><TR><TD CLASS="l">341</TD><TD>            }</TD></TR><TR><TD CLASS="l">342</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                        ReportingClass underlyingReportingClass = underlyingProduct.getReportingClass();</TD></TR><TR><TD CLASS="l">344</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>            if( underlyingReportingClass != null )</TD></TR><TR><TD CLASS="l">346</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                underlyingReportingClass.setListingState(ListingStates.ACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                            removeFromReportingClassSet(underlyingReportingClass.getClassKey(), underlyingReportingClass.getProductType());</TD></TR><TR><TD CLASS="l">349</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                        committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">351</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>                        Log.exception(this, &#34;Unexpected exception during processing underlying product update&#34;, e);</TD></TR><TR><TD CLASS="l">354</TD><TD>                }</TD></TR><TR><TD CLASS="l">355</TD><TD>                finally {</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                        if (!committed) {</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>                                Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                                throw ExceptionBuilder.dataValidationException(&#34;Assuming that data problems caused transaction to fail&#34;, 0); // fixme</TD></TR><TR><TD CLASS="l">359</TD><TD>                        }</TD></TR><TR><TD CLASS="l">360</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>}</TD></TR><TR><TD CLASS="l">362</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="19">363</A></TD><TD>private Product getProductForSymbol(ProductNameStruct prodName)</TD></TR><TR><TD CLASS="l">364</TD><TD>{</TD></TR><TR><TD CLASS="l">365</TD><TD>    try</TD></TR><TR><TD CLASS="l">366</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>        return getProductHome().findByName(prodName);</TD></TR><TR><TD CLASS="l">368</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>    catch(Exception e)</TD></TR><TR><TD CLASS="l">370</TD><TD>    {</TD></TR><TR><TD CLASS="l">371</TD><TD>        // no  need to log</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">373</TD><TD>    }</TD></TR><TR><TD CLASS="l">374</TD><TD>}</TD></TR><TR><TD CLASS="l">375</TD><TD> </TD></TR><TR><TD CLASS="l">376</TD><TD>/**</TD></TR><TR><TD CLASS="l">377</TD><TD> * Defines reporting classes for the product class.</TD></TR><TR><TD CLASS="l">378</TD><TD> *</TD></TR><TR><TD CLASS="l">379</TD><TD> * @param productClass product class for all reporting classes</TD></TR><TR><TD CLASS="l">380</TD><TD> * @param reportingClasses reporting class symbols</TD></TR><TR><TD CLASS="l"><A NAME="b">381</A></TD><TD> * @exception DataValidationException if updates fail</TD></TR><TR><TD CLASS="l">382</TD><TD> */</TD></TR><TR><TD CLASS="l">383</TD><TD>private void defineReportingClasses(ProductClass productClass, String[] reportingClasses)  throws DataValidationException {</TD></TR><TR><TD CLASS="l">384</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>                ReportingClassStruct reportingClass = ProductStructBuilder.buildReportingClassStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                reportingClass.reportingClassSymbol = productClass.getSymbol();</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>                reportingClass.productType = ProductTypes.OPTION;</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                reportingClass.listingState = ListingStates.ACTIVE;</TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>                reportingClass.productClassKey = productClass.getClassKey();</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>                getMaintenanceService().updateReportingClass(reportingClass);</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                removeFromReportingClassSet(reportingClass.classKey, ProductTypes.OPTION);</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                for (int i = 0; i &lt; reportingClasses.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>                        reportingClass.classKey = 0; // need to reset so symbol will be used for lookup</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                        reportingClass.reportingClassSymbol = reportingClasses[i];</TD></TR><TR CLASS="z"><TD CLASS="l">395</TD><TD>                        getMaintenanceService().updateReportingClass(reportingClass);</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>                        removeFromReportingClassSet(reportingClass.classKey, ProductTypes.OPTION);</TD></TR><TR><TD CLASS="l">397</TD><TD>                }</TD></TR><TR><TD CLASS="l">398</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">399</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                Log.exception(this, &#34;Unexpected exception when creating reporting classes&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Unable to create option reporting classes&#34;, 0); // fixme</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">403</TD><TD>}</TD></TR><TR><TD CLASS="l">404</TD><TD>/**</TD></TR><TR><TD CLASS="l">405</TD><TD> * Performs product download from TIPS and TPF.</TD></TR><TR><TD CLASS="l"><A NAME="d">406</A></TD><TD> */</TD></TR><TR><TD CLASS="l">407</TD><TD>public void downloadProductDefinitions()</TD></TR><TR><TD CLASS="l">408</TD><TD>{</TD></TR><TR><TD CLASS="l">409</TD><TD>        // make sure a download is not in progress</TD></TR><TR CLASS="z"><TD CLASS="l">410</TD><TD>        if (!downloadInProgress)</TD></TR><TR><TD CLASS="l">411</TD><TD>        {</TD></TR><TR><TD CLASS="l">412</TD><TD>        // load the reporting class remapping file</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>        loadSymbolMap();</TD></TR><TR><TD CLASS="l">414</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>                downloadInProgress = true;</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>                downloadInterrupted = false;</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>                connectTie();</TD></TR><TR CLASS="z"><TD CLASS="l">418</TD><TD>                resetDownloadTimer();</TD></TR><TR><TD CLASS="l">419</TD><TD>                try</TD></TR><TR><TD CLASS="l">420</TD><TD>                {</TD></TR><TR><TD CLASS="l">421</TD><TD>            // This will occur first - we want to rely on the publishing that happens in tpfDownloadPostProcess</TD></TR><TR><TD CLASS="l">422</TD><TD>            // to ensure product updates get published</TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>            Log.information(this, &#34;Expiring products defined on this system.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>            getExpirationManager().inactivateExpiredProducts();</TD></TR><TR CLASS="z"><TD CLASS="l">425</TD><TD>            Log.information(this, &#34;All product expiration complete.&#34;);</TD></TR><TR><TD CLASS="l">426</TD><TD> </TD></TR><TR><TD CLASS="l">427</TD><TD>                        // Download class definitions from TIPS.  TIPS will call underlyingUpdateComplete</TD></TR><TR><TD CLASS="l">428</TD><TD>                        // when all classes have been sent.</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>            if (!skipTipsDownload()) {</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>                Log.information(this, &#34;Starting product download from TIPS&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                tipsDownloadInitialize();</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                setTipsIndicator(true);</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                getTipsService().subscribeProductDefinitions(getCallback());</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                waitForTipsCompletion();</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>                tipsDownloadPostProcess();</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>                Log.information(this, &#34;TIPS download complete&#34;);</TD></TR><TR><TD CLASS="l">437</TD><TD>            }</TD></TR><TR><TD CLASS="l">438</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                Log.information(this, &#34;TIPS download is being skipped&#34;);</TD></TR><TR><TD CLASS="l">440</TD><TD>            }</TD></TR><TR><TD CLASS="l">441</TD><TD> </TD></TR><TR><TD CLASS="l">442</TD><TD>                        // Create array of active reporting class symbols</TD></TR><TR><TD CLASS="l">443</TD><TD>                        ReportingClass[] reportingClasses;</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                        reportingClasses = getReportingClassHome().findByType(ProductTypes.OPTION, true);</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>                        String[] classSymbols = new String[reportingClasses.length];</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                        for (int i = 0; i &lt; reportingClasses.length; i++)</TD></TR><TR><TD CLASS="l">447</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                                classSymbols[i] = reportingClasses[i].getSymbol();</TD></TR><TR><TD CLASS="l">449</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                        tpfClassesRemainingCount = classSymbols.length;</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>                        setTpfIndicator(true);</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                        tpfDownloadInitialize();</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>                        resetDownloadTimer();</TD></TR><TR><TD CLASS="l">454</TD><TD>                        // Request option data for classes from TPF adapter</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                        Log.information(this, &#34;Starting download of &#34; + tpfClassesRemainingCount + &#34; reporting classes from TPF&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>                        getTpfService().subscribeOptionClassDefinition(classSymbols, getCallback());</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                        waitForTpfCompletion();</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                        Log.information(this, &#34;TPF download complete - making products not received inactive&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                        tpfDownloadPostProcess();</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                        Log.information(this, &#34;All download processing complete.&#34;);</TD></TR><TR><TD CLASS="l">461</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                catch (InterruptedException e)</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                {   Log.alarm(this, &#34;DOWNLOAD ERROR: Product download interrupted&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                        Log.alarm(this, &#34;Product download interrupted: &#34; + e);</TD></TR><TR><TD CLASS="l">465</TD><TD>                        // Since the download was interrupted, disconnect the tie</TD></TR><TR CLASS="z"><TD CLASS="l">466</TD><TD>                        disconnectTie();</TD></TR><TR><TD CLASS="l">467</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">469</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>            Log.alarm(this, &#34;DOWNLOAD ERROR: Unexpected exception during product download&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">471</TD><TD>                        Log.alarm(this, &#34;Unexpeted exception during product download: &#34; + e);</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>                        Log.exception(this, e);</TD></TR><TR CLASS="z"><TD CLASS="l">473</TD><TD>                        disconnectTie();</TD></TR><TR><TD CLASS="l">474</TD><TD>                }</TD></TR><TR><TD CLASS="l">475</TD><TD>                finally</TD></TR><TR><TD CLASS="l">476</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">477</TD><TD>                        downloadInProgress = false;</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>                }</TD></TR><TR><TD CLASS="l">479</TD><TD>        }</TD></TR><TR><TD CLASS="l">480</TD><TD>        else</TD></TR><TR><TD CLASS="l">481</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>                Log.information(this, &#34;Download already in progress - request ignored&#34;);</TD></TR><TR><TD CLASS="l">483</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>}</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR><TD CLASS="l">486</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="32">487</A></TD><TD> * Checks to see if command line argument to skip the TIPS download is set.</TD></TR><TR><TD CLASS="l">488</TD><TD> * @return true if TIPS download should be skipped</TD></TR><TR><TD CLASS="l">489</TD><TD> */</TD></TR><TR><TD CLASS="l">490</TD><TD>private boolean skipTipsDownload() {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>    return Boolean.getBoolean(SKIP_TIPS_DOWNLOAD);</TD></TR><TR><TD CLASS="l">492</TD><TD>}</TD></TR><TR><TD CLASS="l">493</TD><TD> </TD></TR><TR><TD CLASS="l">494</TD><TD>    /**</TD></TR><TR><TD CLASS="l">495</TD><TD> * Loads the files containing the mapping of reporting classes to product class symbol.</TD></TR><TR><TD CLASS="l"><A NAME="23">496</A></TD><TD> * File is loaded as properties file.</TD></TR><TR><TD CLASS="l">497</TD><TD> */</TD></TR><TR><TD CLASS="l">498</TD><TD>private void loadSymbolMap()</TD></TR><TR><TD CLASS="l">499</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>    String fileName = SYMBOL_MAP_FILE;</TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>    java.io.InputStream in = null;</TD></TR><TR><TD CLASS="l">502</TD><TD> </TD></TR><TR><TD CLASS="l">503</TD><TD>    // clear all the entries first</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>    reportingClassSymbolMap.clear();</TD></TR><TR><TD CLASS="l">505</TD><TD> </TD></TR><TR><TD CLASS="l">506</TD><TD>    try {</TD></TR><TR><TD CLASS="l">507</TD><TD>        // Open the file</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>        in = new java.io.FileInputStream(fileName);</TD></TR><TR><TD CLASS="l">509</TD><TD> </TD></TR><TR><TD CLASS="l">510</TD><TD>        // Load the properties file</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>        reportingClassSymbolMap.load(in);</TD></TR><TR><TD CLASS="l">512</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>    catch (Exception e) { // Move on</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>        Log.exception(this,&#34;Error loading the Symbol Map File, MOVING ON WITHOUT IT : &#34; + fileName, e);</TD></TR><TR><TD CLASS="l">515</TD><TD>    }</TD></TR><TR><TD CLASS="l">516</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">517</TD><TD>        if (in != null) {</TD></TR><TR><TD CLASS="l">518</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>                in.close();</TD></TR><TR><TD CLASS="l">520</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">521</TD><TD>            catch (Exception e) {</TD></TR><TR><TD CLASS="l">522</TD><TD>                // Ignore exception</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>            }</TD></TR><TR><TD CLASS="l">524</TD><TD>        }</TD></TR><TR><TD CLASS="l">525</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>}</TD></TR><TR><TD CLASS="l">527</TD><TD>/**</TD></TR><TR><TD CLASS="l">528</TD><TD> * Need to exclude strategy classes with active futures from the list of classes to be made inactive.  Main</TD></TR><TR><TD CLASS="l">529</TD><TD> * reason for doing this is so that if a STRATEGY is shared by the FUTURE, we</TD></TR><TR><TD CLASS="l"><A NAME="f">530</A></TD><TD> * won't eventually delete the STRATEGY.</TD></TR><TR><TD CLASS="l">531</TD><TD> */</TD></TR><TR><TD CLASS="l">532</TD><TD>private void excludeStrategyClassesWithActiveFuture() {</TD></TR><TR><TD CLASS="l">533</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>    ProductClass[] futures = getProductClassHome().findByType(ProductTypes.FUTURE, true);</TD></TR><TR><TD CLASS="l">535</TD><TD>    ReportingClass reportingClass;</TD></TR><TR><TD CLASS="l">536</TD><TD>    ProductClass strategyClass;</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>    for (int i = 0; i &lt; futures.length; i++)</TD></TR><TR><TD CLASS="l">538</TD><TD>    {</TD></TR><TR><TD CLASS="l">539</TD><TD>        try</TD></TR><TR><TD CLASS="l">540</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">541</TD><TD>            reportingClass = getReportingClassHome().findBySymbol(futures[i].getSymbol(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>            removeFromReportingClassSet(reportingClass.getClassKey(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">544</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>                Log.debug(this, &#34;Strategy reporting class excluded: &#34; + futures[i].getSymbol());</TD></TR><TR><TD CLASS="l">546</TD><TD>            }</TD></TR><TR><TD CLASS="l">547</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>        catch(Exception e)</TD></TR><TR><TD CLASS="l">549</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">551</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                Log.debug(this, &#34;Strategy reporting class not found: &#34; + futures[i].getSymbol());</TD></TR><TR><TD CLASS="l">553</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>        }</TD></TR><TR><TD CLASS="l">555</TD><TD>        try</TD></TR><TR><TD CLASS="l">556</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>            strategyClass = getProductClassHome().findBySymbol(futures[i].getSymbol(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>            productClassKeys[ProductTypes.STRATEGY].remove(new Integer(strategyClass.getClassKey()));</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">560</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">561</TD><TD>                Log.debug(this, &#34;Strategy product class excluded: &#34; + futures[i].getSymbol());</TD></TR><TR><TD CLASS="l">562</TD><TD>            }</TD></TR><TR><TD CLASS="l">563</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>        catch(Exception e2)</TD></TR><TR><TD CLASS="l">565</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">566</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">567</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>                Log.debug(this, &#34;Strategy product class not found: &#34; + futures[i].getSymbol());</TD></TR><TR><TD CLASS="l">569</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>        }</TD></TR><TR><TD CLASS="l">571</TD><TD> </TD></TR><TR><TD CLASS="l">572</TD><TD>    }</TD></TR><TR><TD CLASS="l">573</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>}</TD></TR><TR><TD CLASS="l">575</TD><TD> </TD></TR><TR><TD CLASS="l">576</TD><TD> </TD></TR><TR><TD CLASS="l">577</TD><TD>/**</TD></TR><TR><TD CLASS="l">578</TD><TD> * Need to exclude classes with active derivatives from the list of classes to be made inactive.  Main</TD></TR><TR><TD CLASS="l"><A NAME="e">579</A></TD><TD> * reason for doing this is so that if a FUTURE is defined on a equity that isn't being traded for options, we</TD></TR><TR><TD CLASS="l">580</TD><TD> * won't eventually delete the underlying.</TD></TR><TR><TD CLASS="l">581</TD><TD> */</TD></TR><TR><TD CLASS="l">582</TD><TD>private void excludeClassesWithDerivatives() {</TD></TR><TR CLASS="z"><TD CLASS="l">583</TD><TD>        for (int i = 0; i &lt; productClassKeys.length; i++)</TD></TR><TR><TD CLASS="l">584</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>                if (baseProductType(i) &amp;&amp; productClassKeys[i] != null)</TD></TR><TR><TD CLASS="l">586</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>            Iterator iter = productClassKeys[i].iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>            while (iter.hasNext())</TD></TR><TR><TD CLASS="l">589</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>                int classKey = ((Integer) iter.next()).intValue();</TD></TR><TR><TD CLASS="l">591</TD><TD>                try</TD></TR><TR><TD CLASS="l">592</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">593</TD><TD>                    ProductClass productClass = getProductClassHome().findByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">594</TD><TD>                    Product[] products = productClass.getProducts(true);</TD></TR><TR CLASS="z"><TD CLASS="l">595</TD><TD>                    for (int j = 0; j &lt; products.length; j++)</TD></TR><TR><TD CLASS="l">596</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">597</TD><TD>                        ProductClass[] derivativeClasses = getProductClassHome().findByUnderlying(products[j], true);</TD></TR><TR CLASS="z"><TD CLASS="l">598</TD><TD>                        if (derivativeClasses.length &gt; 0)</TD></TR><TR><TD CLASS="l">599</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">600</TD><TD>                            iter.remove();</TD></TR><TR CLASS="z"><TD CLASS="l">601</TD><TD>                            removeReportingClassesFromSet(productClass.getReportingClasses(true));</TD></TR><TR CLASS="z"><TD CLASS="l">602</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">603</TD><TD>                        }</TD></TR><TR><TD CLASS="l">604</TD><TD>                    }</TD></TR><TR><TD CLASS="l">605</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">607</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                    Log.exception(&#34;Unexpected exception while checking class: &#34; + classKey, e);</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>            }</TD></TR><TR><TD CLASS="l">611</TD><TD>                }</TD></TR><TR><TD CLASS="l">612</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">613</TD><TD>}</TD></TR><TR><TD CLASS="l">614</TD><TD>/**</TD></TR><TR><TD CLASS="l">615</TD><TD> * Returns the option product class found.  If product class is not found, reporting</TD></TR><TR><TD CLASS="l">616</TD><TD> * classes are used to see if product class can be found through them.  The search by reporting class is</TD></TR><TR><TD CLASS="l">617</TD><TD> * required in case the product class symbol has been changed.</TD></TR><TR><TD CLASS="l">618</TD><TD> *</TD></TR><TR><TD CLASS="l">619</TD><TD> * @param classSymbol the class symbol</TD></TR><TR><TD CLASS="l"><A NAME="10">620</A></TD><TD> * @param reportingClasses reporting class symbols</TD></TR><TR><TD CLASS="l">621</TD><TD> * @return found class or null</TD></TR><TR><TD CLASS="l">622</TD><TD> */</TD></TR><TR><TD CLASS="l">623</TD><TD>private ProductClass findOptionProductClass(String classSymbol, String[] reportingClasses) {</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>        ProductClass result = null;</TD></TR><TR><TD CLASS="l">625</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                result = getProductClassHome().findBySymbol(classSymbol, ProductTypes.OPTION);</TD></TR><TR><TD CLASS="l">627</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">628</TD><TD>        catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">629</TD><TD>                for (int i = 0; result == null &amp;&amp; i &lt; reportingClasses.length; i++) {</TD></TR><TR><TD CLASS="l">630</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">631</TD><TD>                                result = getReportingClassHome().findBySymbol(reportingClasses[i], ProductTypes.OPTION).getProductClass();</TD></TR><TR><TD CLASS="l">632</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>                        catch (NotFoundException e2) {</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>                        }</TD></TR><TR><TD CLASS="l">635</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">636</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">638</TD><TD>}</TD></TR><TR><TD CLASS="l">639</TD><TD>/**</TD></TR><TR><TD CLASS="l">640</TD><TD> * Gets callback associated with tie of this controller.</TD></TR><TR><TD CLASS="l">641</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="11">642</A></TD><TD> * @return reference to callback</TD></TR><TR><TD CLASS="l">643</TD><TD> */</TD></TR><TR><TD CLASS="l">644</TD><TD>private com.cboe.idl.internalBusinessServices.ProductDefinitionInterface getCallback()</TD></TR><TR><TD CLASS="l">645</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>        return downloadControllerCallback;</TD></TR><TR><TD CLASS="l">647</TD><TD>}</TD></TR><TR><TD CLASS="l">648</TD><TD>/**</TD></TR><TR><TD CLASS="l">649</TD><TD> * Gets the value of the download timeout period.</TD></TR><TR><TD CLASS="l">650</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="12">651</A></TD><TD> * @return download timeout period in millis</TD></TR><TR><TD CLASS="l">652</TD><TD> */</TD></TR><TR><TD CLASS="l">653</TD><TD>private long getDownloadTimeout()</TD></TR><TR><TD CLASS="l">654</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>    return ((ProductMaintenanceServiceHomeImpl) getBOHome()).getDownloadTimeout();</TD></TR><TR><TD CLASS="l">656</TD><TD>}</TD></TR><TR><TD CLASS="l">657</TD><TD>/**</TD></TR><TR><TD CLASS="l">658</TD><TD> * Gets reference to maintenance service.</TD></TR><TR><TD CLASS="l">659</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="14">660</A></TD><TD> * @return reference to maintenance service</TD></TR><TR><TD CLASS="l">661</TD><TD> */</TD></TR><TR><TD CLASS="l">662</TD><TD>private ProductMaintenanceService getMaintenanceService()</TD></TR><TR><TD CLASS="l">663</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>        if (maintenanceService == null)</TD></TR><TR><TD CLASS="l">665</TD><TD>        {</TD></TR><TR><TD CLASS="l">666</TD><TD>            try</TD></TR><TR><TD CLASS="l">667</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>                    ProductMaintenanceServiceHome home = (ProductMaintenanceServiceHome) HomeFactory.getInstance().findHome(ProductMaintenanceServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                    maintenanceService = home.find();</TD></TR><TR><TD CLASS="l">670</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">672</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">673</TD><TD>                    throw new NullPointerException(&#34;Cannot not find maintenance service home&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                }</TD></TR><TR><TD CLASS="l">675</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>        return maintenanceService;</TD></TR><TR><TD CLASS="l">677</TD><TD>}</TD></TR><TR><TD CLASS="l">678</TD><TD>/**</TD></TR><TR><TD CLASS="l">679</TD><TD> * Gets reference to home for product classes.</TD></TR><TR><TD CLASS="l">680</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="15">681</A></TD><TD> * @return reference to product class home</TD></TR><TR><TD CLASS="l">682</TD><TD> */</TD></TR><TR><TD CLASS="l">683</TD><TD>private ProductClassHome getProductClassHome()</TD></TR><TR><TD CLASS="l">684</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>        if (productClassHome == null)</TD></TR><TR><TD CLASS="l">686</TD><TD>        {</TD></TR><TR><TD CLASS="l">687</TD><TD>            try</TD></TR><TR><TD CLASS="l">688</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                    productClassHome = (ProductClassHome) HomeFactory.getInstance().findHome(ProductClassHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">690</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">691</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">692</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>                    throw new NullPointerException(&#34;Cannot not find ProductClassHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">694</TD><TD>                }</TD></TR><TR><TD CLASS="l">695</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>        return productClassHome;</TD></TR><TR><TD CLASS="l">697</TD><TD>}</TD></TR><TR><TD CLASS="l">698</TD><TD>/**</TD></TR><TR><TD CLASS="l">699</TD><TD> * Gets reference to home for product descriptions.</TD></TR><TR><TD CLASS="l">700</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="17">701</A></TD><TD> * @return reference to product description home</TD></TR><TR><TD CLASS="l">702</TD><TD> */</TD></TR><TR><TD CLASS="l">703</TD><TD>private ProductDescriptionHome getProductDescriptionHome()</TD></TR><TR><TD CLASS="l">704</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>        if (productDescriptionHome == null)</TD></TR><TR><TD CLASS="l">706</TD><TD>        {</TD></TR><TR><TD CLASS="l">707</TD><TD>            try</TD></TR><TR><TD CLASS="l">708</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                        productDescriptionHome = (ProductDescriptionHome) HomeFactory.getInstance().findHome(ProductDescriptionHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">710</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">712</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                    throw new NullPointerException(&#34;Cannot not find ProductDescriptionHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                }</TD></TR><TR><TD CLASS="l">715</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>        return productDescriptionHome;</TD></TR><TR><TD CLASS="l">717</TD><TD>}</TD></TR><TR><TD CLASS="l">718</TD><TD>/**</TD></TR><TR><TD CLASS="l">719</TD><TD> * Creates set containing all active product class keys for type.</TD></TR><TR><TD CLASS="l">720</TD><TD> *</TD></TR><TR><TD CLASS="l">721</TD><TD> * @param productType requested product type</TD></TR><TR><TD CLASS="l"><A NAME="16">722</A></TD><TD> * @return set of product class keys</TD></TR><TR><TD CLASS="l">723</TD><TD> */</TD></TR><TR><TD CLASS="l">724</TD><TD>private HashSet getProductClassKeys(short productType)</TD></TR><TR><TD CLASS="l">725</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>        ProductClass[] classes = getProductClassHome().findByType(productType, true);</TD></TR><TR CLASS="z"><TD CLASS="l">727</TD><TD>        HashSet result = new HashSet(classes.length * 2 + 1, 0.75f);</TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>        for (int i = 0; i &lt; classes.length; i++)</TD></TR><TR><TD CLASS="l">729</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">730</TD><TD>                result.add(new Integer(classes[i].getClassKey()));</TD></TR><TR><TD CLASS="l">731</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">732</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">733</TD><TD>}</TD></TR><TR><TD CLASS="l">734</TD><TD>/**</TD></TR><TR><TD CLASS="l">735</TD><TD> * Gets reference to home for products.</TD></TR><TR><TD CLASS="l">736</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="1a">737</A></TD><TD> * @return reference to product home</TD></TR><TR><TD CLASS="l">738</TD><TD> */</TD></TR><TR><TD CLASS="l">739</TD><TD>private ProductHome getProductHome()</TD></TR><TR><TD CLASS="l">740</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">741</TD><TD>        if (productHome == null)</TD></TR><TR><TD CLASS="l">742</TD><TD>        {</TD></TR><TR><TD CLASS="l">743</TD><TD>            try</TD></TR><TR><TD CLASS="l">744</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>                    productHome = (ProductHome) HomeFactory.getInstance().findHome(ProductHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">746</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">748</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>                    throw new NullPointerException(&#34;Cannot not find ProductHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>                }</TD></TR><TR><TD CLASS="l">751</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">752</TD><TD>        return productHome;</TD></TR><TR><TD CLASS="l">753</TD><TD>}</TD></TR><TR><TD CLASS="l">754</TD><TD>/**</TD></TR><TR><TD CLASS="l">755</TD><TD> * Gets reference to home for product types.</TD></TR><TR><TD CLASS="l">756</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="1b">757</A></TD><TD> * @return reference to product type home</TD></TR><TR><TD CLASS="l">758</TD><TD> */</TD></TR><TR><TD CLASS="l">759</TD><TD>private ProductTypeHome getProductTypeHome()</TD></TR><TR><TD CLASS="l">760</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>        if (productTypeHome == null)</TD></TR><TR><TD CLASS="l">762</TD><TD>        {</TD></TR><TR><TD CLASS="l">763</TD><TD>            try</TD></TR><TR><TD CLASS="l">764</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                    productTypeHome = (ProductTypeHome) HomeFactory.getInstance().findHome(ProductTypeHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">766</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">768</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>                    throw new NullPointerException(&#34;Cannot not find ProductTypeHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>                }</TD></TR><TR><TD CLASS="l">771</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>        return productTypeHome;</TD></TR><TR><TD CLASS="l">773</TD><TD>}</TD></TR><TR><TD CLASS="l">774</TD><TD>/**</TD></TR><TR><TD CLASS="l">775</TD><TD> * Gets reference to home for reporting classes.</TD></TR><TR><TD CLASS="l">776</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="1c">777</A></TD><TD> * @return reference to reporting class home</TD></TR><TR><TD CLASS="l">778</TD><TD> */</TD></TR><TR><TD CLASS="l">779</TD><TD>private ReportingClassHome getReportingClassHome()</TD></TR><TR><TD CLASS="l">780</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>        if (reportingClassHome == null)</TD></TR><TR><TD CLASS="l">782</TD><TD>        {</TD></TR><TR><TD CLASS="l">783</TD><TD>            try</TD></TR><TR><TD CLASS="l">784</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>                    reportingClassHome = (ReportingClassHome) HomeFactory.getInstance().findHome(ReportingClassHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">786</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>                catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">788</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                    throw new NullPointerException(&#34;Cannot not find ReportingClassHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>                }</TD></TR><TR><TD CLASS="l">791</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>        return reportingClassHome;</TD></TR><TR><TD CLASS="l">793</TD><TD>}</TD></TR><TR><TD CLASS="l">794</TD><TD>/**</TD></TR><TR><TD CLASS="l">795</TD><TD> * Creates set containing all active reporting class keys for type.</TD></TR><TR><TD CLASS="l">796</TD><TD> *</TD></TR><TR><TD CLASS="l">797</TD><TD> * @param productType requested product type</TD></TR><TR><TD CLASS="l"><A NAME="1d">798</A></TD><TD> * @return set of reporting class keys</TD></TR><TR><TD CLASS="l">799</TD><TD> */</TD></TR><TR><TD CLASS="l">800</TD><TD>private HashSet getReportingClassKeys(short productType)</TD></TR><TR><TD CLASS="l">801</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>        ReportingClass[] classes = getReportingClassHome().findByType(productType, true);</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>        HashSet result = new HashSet(classes.length * 2 + 1, 0.75f);</TD></TR><TR CLASS="z"><TD CLASS="l">804</TD><TD>        for (int i = 0; i &lt; classes.length; i++)</TD></TR><TR><TD CLASS="l">805</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>                result.add(new Integer(classes[i].getClassKey()));</TD></TR><TR><TD CLASS="l">807</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">808</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">809</TD><TD>}</TD></TR><TR><TD CLASS="l">810</TD><TD>/**</TD></TR><TR><TD CLASS="l">811</TD><TD> * Gets current tie for this controller.</TD></TR><TR><TD CLASS="l">812</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="1f">813</A></TD><TD> * @return &#34;tie&#34; for this controller</TD></TR><TR><TD CLASS="l">814</TD><TD> */</TD></TR><TR><TD CLASS="l">815</TD><TD>private POA_ProductDefinitionInterface_tie getTie()</TD></TR><TR><TD CLASS="l">816</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">817</TD><TD>        return downloadControllerTie;</TD></TR><TR><TD CLASS="l">818</TD><TD>}</TD></TR><TR><TD CLASS="l">819</TD><TD>/**</TD></TR><TR><TD CLASS="l">820</TD><TD> * Gets reference to TIPS product service.</TD></TR><TR><TD CLASS="l">821</TD><TD> *</TD></TR><TR><TD CLASS="l">822</TD><TD> * @return a TIPS product service</TD></TR><TR><TD CLASS="l"><A NAME="20">823</A></TD><TD> * @exception NullPointerException if home for service can't be found</TD></TR><TR><TD CLASS="l">824</TD><TD> */</TD></TR><TR><TD CLASS="l">825</TD><TD>private TIPSProductService getTipsService()</TD></TR><TR><TD CLASS="l">826</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>        if (tipsService == null)</TD></TR><TR><TD CLASS="l">828</TD><TD>        {</TD></TR><TR><TD CLASS="l">829</TD><TD>                try</TD></TR><TR><TD CLASS="l">830</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>                        TIPSProductServiceHome home = (TIPSProductServiceHome) HomeFactory.getInstance().findHome(TIPSProductServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">832</TD><TD>                        tipsService = home.find();</TD></TR><TR><TD CLASS="l">833</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">835</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">836</TD><TD>                        Log.alarm(this, &#34;Cannot get home for TIPS product service: &#34; + e);</TD></TR><TR CLASS="z"><TD CLASS="l">837</TD><TD>                        Log.exception(this, e);</TD></TR><TR CLASS="z"><TD CLASS="l">838</TD><TD>                        throw new NullPointerException(&#34;No home for TIPS product service&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">839</TD><TD>                }</TD></TR><TR><TD CLASS="l">840</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">841</TD><TD>        return tipsService;</TD></TR><TR><TD CLASS="l">842</TD><TD>}</TD></TR><TR><TD CLASS="l">843</TD><TD>/**</TD></TR><TR><TD CLASS="l">844</TD><TD> * Gets reference to TPF product service.</TD></TR><TR><TD CLASS="l">845</TD><TD> *</TD></TR><TR><TD CLASS="l">846</TD><TD> * @return a TPF product service</TD></TR><TR><TD CLASS="l"><A NAME="21">847</A></TD><TD> * @exception NullPointerException if home for service can't be found</TD></TR><TR><TD CLASS="l">848</TD><TD> */</TD></TR><TR><TD CLASS="l">849</TD><TD>private TPFProductService getTpfService()</TD></TR><TR><TD CLASS="l">850</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">851</TD><TD>        if (tpfService == null)</TD></TR><TR><TD CLASS="l">852</TD><TD>        {</TD></TR><TR><TD CLASS="l">853</TD><TD>                try</TD></TR><TR><TD CLASS="l">854</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">855</TD><TD>                        TPFProductServiceHome home = (TPFProductServiceHome) HomeFactory.getInstance().findHome(TPFProductServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">856</TD><TD>                        tpfService = home.find();</TD></TR><TR><TD CLASS="l">857</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">858</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">859</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">860</TD><TD>                        Log.alarm(this, &#34;Cannot get home for TPF product service: &#34; + e);</TD></TR><TR CLASS="z"><TD CLASS="l">861</TD><TD>                        Log.exception(this, e);</TD></TR><TR CLASS="z"><TD CLASS="l">862</TD><TD>                        throw new NullPointerException(&#34;No home for TPF product service&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>                }</TD></TR><TR><TD CLASS="l">864</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>        return tpfService;</TD></TR><TR><TD CLASS="l">866</TD><TD>}</TD></TR><TR><TD CLASS="l">867</TD><TD>/**</TD></TR><TR><TD CLASS="l">868</TD><TD> * Returns status of this controller.</TD></TR><TR><TD CLASS="l">869</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="22">870</A></TD><TD> * @return true if download is in progress</TD></TR><TR><TD CLASS="l">871</TD><TD> */</TD></TR><TR><TD CLASS="l">872</TD><TD>public boolean isDownloadInProgress()</TD></TR><TR><TD CLASS="l">873</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">874</TD><TD>        return downloadInProgress;</TD></TR><TR><TD CLASS="l">875</TD><TD>}</TD></TR><TR><TD CLASS="l">876</TD><TD>/**</TD></TR><TR><TD CLASS="l">877</TD><TD> * Marks all of the product classes left in the set as inactive.</TD></TR><TR><TD CLASS="l">878</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="24">879</A></TD><TD> * @param classKeys set of keys for product classes not updated during download</TD></TR><TR><TD CLASS="l">880</TD><TD> */</TD></TR><TR><TD CLASS="l">881</TD><TD>private void markProductClassesInactive(HashSet classKeys)</TD></TR><TR><TD CLASS="l">882</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">883</TD><TD>        Iterator iter = classKeys.iterator();</TD></TR><TR><TD CLASS="l">884</TD><TD>        int classKey;</TD></TR><TR><TD CLASS="l">885</TD><TD>        ProductClass productClass;</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>        while (iter.hasNext())</TD></TR><TR><TD CLASS="l">887</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>                classKey = ((Integer) iter.next()).intValue();</TD></TR><TR><TD CLASS="l">889</TD><TD>                try</TD></TR><TR><TD CLASS="l">890</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">891</TD><TD>                        productClass = getProductClassHome().findByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">892</TD><TD>                        productClass.setListingState(ListingStates.INACTIVE);</TD></TR><TR><TD CLASS="l">893</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">894</TD><TD>                catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">895</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">896</TD><TD>                        Log.alarm(this, &#34;Could not mark product class &#34; + classKey + &#34; inactive&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">897</TD><TD>                }</TD></TR><TR><TD CLASS="l">898</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">899</TD><TD>}</TD></TR><TR><TD CLASS="l">900</TD><TD>/**</TD></TR><TR><TD CLASS="l">901</TD><TD> * Marks all of the reporting classes left in the set as inactive.</TD></TR><TR><TD CLASS="l">902</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="25">903</A></TD><TD> * @param classKeys set of keys for reporting classes not updated during download</TD></TR><TR><TD CLASS="l">904</TD><TD> */</TD></TR><TR><TD CLASS="l">905</TD><TD>private void markReportingClassesInactive(HashSet classKeys)</TD></TR><TR><TD CLASS="l">906</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">907</TD><TD>        Iterator iter = classKeys.iterator();</TD></TR><TR><TD CLASS="l">908</TD><TD>        int classKey;</TD></TR><TR><TD CLASS="l">909</TD><TD>        ReportingClass reportingClass;</TD></TR><TR CLASS="z"><TD CLASS="l">910</TD><TD>        while (iter.hasNext())</TD></TR><TR><TD CLASS="l">911</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">912</TD><TD>                classKey = ((Integer) iter.next()).intValue();</TD></TR><TR><TD CLASS="l">913</TD><TD>                try</TD></TR><TR><TD CLASS="l">914</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">915</TD><TD>                        reportingClass = getReportingClassHome().findByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">916</TD><TD>                        reportingClass.setListingState(ListingStates.INACTIVE);</TD></TR><TR><TD CLASS="l">917</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">918</TD><TD>                catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">919</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">920</TD><TD>                        Log.alarm(this, &#34;Could not mark reporting class &#34; + classKey + &#34; inactive&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">921</TD><TD>                }</TD></TR><TR><TD CLASS="l">922</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">923</TD><TD>}</TD></TR><TR><TD CLASS="l">924</TD><TD>/**</TD></TR><TR><TD CLASS="l">925</TD><TD> * Publishes all active classes at end of download.</TD></TR><TR><TD CLASS="l"><A NAME="26">926</A></TD><TD> *</TD></TR><TR><TD CLASS="l">927</TD><TD> */</TD></TR><TR><TD CLASS="l">928</TD><TD>private void publishAfterDownload()</TD></TR><TR><TD CLASS="l">929</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">930</TD><TD>        ProductClass[] activeClasses = getProductClassHome().findAll(true);</TD></TR><TR><TD CLASS="l">931</TD><TD>        try</TD></TR><TR><TD CLASS="l">932</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>                Log.information(this, &#34;Starting to publish classes after download&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">934</TD><TD>                ProductStatusConsumer publisher = EventHomes.getProductStatusConsumerHome().find();</TD></TR><TR CLASS="z"><TD CLASS="l">935</TD><TD>                for (int i = 0; i &lt; activeClasses.length; i++)</TD></TR><TR><TD CLASS="l">936</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">937</TD><TD>                        publisher.updateProductClass(activeClasses[i].toStruct(true, true, true));</TD></TR><TR><TD CLASS="l">938</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">939</TD><TD>                Log.information(this, &#34;Completed publishing classes after download&#34;);</TD></TR><TR><TD CLASS="l">940</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">941</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">942</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">943</TD><TD>                Log.exception(this, &#34;Unable to publish classes after download&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">944</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">945</TD><TD>}</TD></TR><TR><TD CLASS="l">946</TD><TD>/**</TD></TR><TR><TD CLASS="l">947</TD><TD> * Removes class from product class set.  Since class was updated, it will not need</TD></TR><TR><TD CLASS="l">948</TD><TD> * to be marked as inactive during post processing.</TD></TR><TR><TD CLASS="l">949</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="28">950</A></TD><TD> * @param classKey key of updated class</TD></TR><TR><TD CLASS="l">951</TD><TD> * @param productType product type of updated class</TD></TR><TR><TD CLASS="l">952</TD><TD> */</TD></TR><TR><TD CLASS="l">953</TD><TD>private void removeFromProductClassSet(int classKey, short productType) {</TD></TR><TR CLASS="z"><TD CLASS="l">954</TD><TD>        productClassKeys[productType].remove(new Integer(classKey));</TD></TR><TR><TD CLASS="l">955</TD><TD>        // Assume that the corresponding strategy classes for options have also been updated</TD></TR><TR CLASS="z"><TD CLASS="l">956</TD><TD>        if (productType == ProductTypes.OPTION) {</TD></TR><TR><TD CLASS="l">957</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">958</TD><TD>                        ProductClass optionClass = getProductClassHome().findByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">959</TD><TD>                        ReportingClass reportingClass = getReportingClassHome().findBySymbol(optionClass.getSymbol(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">960</TD><TD>                        removeFromReportingClassSet(reportingClass.getClassKey(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">961</TD><TD>                        ProductClass strategyClass = reportingClass.getProductClass();</TD></TR><TR CLASS="z"><TD CLASS="l">962</TD><TD>                        productClassKeys[ProductTypes.STRATEGY].remove(new Integer(strategyClass.getClassKey()));</TD></TR><TR><TD CLASS="l">963</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">964</TD><TD>                catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">965</TD><TD>                        Log.exception(this, &#34;Unable to remove strategy classes from sets for option class: &#34; + classKey, e);</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>                }</TD></TR><TR><TD CLASS="l">967</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">968</TD><TD>}</TD></TR><TR><TD CLASS="l">969</TD><TD>/**</TD></TR><TR><TD CLASS="l">970</TD><TD> * Removes product from product set.  Since product was updated, it will not need</TD></TR><TR><TD CLASS="l">971</TD><TD> * to be marked as inactive during post processing.</TD></TR><TR><TD CLASS="l">972</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="29">973</A></TD><TD> * @param updatedProduct an updated product</TD></TR><TR><TD CLASS="l">974</TD><TD> */</TD></TR><TR><TD CLASS="l">975</TD><TD>private void removeFromProductSet(ProductStruct updatedProduct)</TD></TR><TR><TD CLASS="l">976</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">977</TD><TD>        if (tpfInProgress)</TD></TR><TR><TD CLASS="l">978</TD><TD>        {</TD></TR><TR><TD CLASS="l">979</TD><TD>                // remove from product set</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>                productKeys.remove(new Integer(updatedProduct.productKeys.productKey));</TD></TR><TR><TD CLASS="l">981</TD><TD>        }</TD></TR><TR><TD CLASS="l">982</TD><TD>        else</TD></TR><TR><TD CLASS="l">983</TD><TD>        {</TD></TR><TR><TD CLASS="l">984</TD><TD>                // during TIPS download this will be an underlying product, remove created</TD></TR><TR><TD CLASS="l">985</TD><TD>                // classes from sets</TD></TR><TR CLASS="z"><TD CLASS="l">986</TD><TD>                removeFromProductClassSet(updatedProduct.productKeys.classKey, updatedProduct.productKeys.productType);</TD></TR><TR CLASS="z"><TD CLASS="l">987</TD><TD>                removeFromReportingClassSet(updatedProduct.productKeys.reportingClass, updatedProduct.productKeys.productType);</TD></TR><TR><TD CLASS="l">988</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>}</TD></TR><TR><TD CLASS="l">990</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="2b">991</A></TD><TD> * Removes all reporting classes from set of classes.</TD></TR><TR><TD CLASS="l">992</TD><TD> */</TD></TR><TR><TD CLASS="l">993</TD><TD>private void removeReportingClassesFromSet(ReportingClass[] reportingClasses)</TD></TR><TR><TD CLASS="l">994</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">995</TD><TD>    for (int i = 0; i &lt; reportingClasses.length; i++)</TD></TR><TR><TD CLASS="l">996</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">997</TD><TD>        removeFromReportingClassSet(reportingClasses[i].getClassKey(), reportingClasses[i].getProductType());</TD></TR><TR><TD CLASS="l">998</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>}</TD></TR><TR><TD CLASS="l">1000</TD><TD>/**</TD></TR><TR><TD CLASS="l">1001</TD><TD> * Removes class from reporting class set.  Since class was updated, it will not need</TD></TR><TR><TD CLASS="l">1002</TD><TD> * to be marked as inactive during post processing.</TD></TR><TR><TD CLASS="l">1003</TD><TD> *</TD></TR><TR><TD CLASS="l">1004</TD><TD> * @param classKey key of class to be removed</TD></TR><TR><TD CLASS="l"><A NAME="2a">1005</A></TD><TD> * @param productType product type of class</TD></TR><TR><TD CLASS="l">1006</TD><TD> */</TD></TR><TR><TD CLASS="l">1007</TD><TD>private void removeFromReportingClassSet(int classKey, short productType)</TD></TR><TR><TD CLASS="l">1008</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>        reportingClassKeys[productType].remove(new Integer(classKey));</TD></TR><TR CLASS="z"><TD CLASS="l">1010</TD><TD>}</TD></TR><TR><TD CLASS="l">1011</TD><TD>/**</TD></TR><TR><TD CLASS="l">1012</TD><TD> * Completes processing of reporting class being downloaded from TPF product service.</TD></TR><TR><TD CLASS="l">1013</TD><TD> *</TD></TR><TR><TD CLASS="l">1014</TD><TD> * @param reportingClassSymbol symbol of updated class</TD></TR><TR><TD CLASS="l"><A NAME="2c">1015</A></TD><TD> * @param type product type of class</TD></TR><TR><TD CLASS="l">1016</TD><TD> */</TD></TR><TR><TD CLASS="l">1017</TD><TD>public void reportingClassUpdateComplete(String reportingClassSymbol, short type)</TD></TR><TR><TD CLASS="l">1018</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1019</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1020</TD><TD>    String extendedLogMessage = &#34;&#34;;</TD></TR><TR><TD CLASS="l">1021</TD><TD>        // mark the class as inactive if there are no active products.</TD></TR><TR CLASS="z"><TD CLASS="l">1022</TD><TD>    Product[] products = new Product[0];</TD></TR><TR><TD CLASS="l">1023</TD><TD>        try</TD></TR><TR><TD CLASS="l">1024</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                ReportingClass updatedClass = getReportingClassHome().findBySymbol(reportingClassSymbol, type);</TD></TR><TR><TD CLASS="l">1026</TD><TD>                // get the active products of the class</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>                products = updatedClass.getProducts(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1028</TD><TD>                if (products.length == 0)</TD></TR><TR><TD CLASS="l">1029</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1030</TD><TD>                        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1031</TD><TD>                        boolean committed = false;</TD></TR><TR><TD CLASS="l">1032</TD><TD>                        try</TD></TR><TR><TD CLASS="l">1033</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1034</TD><TD>                                updatedClass.setListingState(ListingStates.INACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">1035</TD><TD>                                committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">1036</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1037</TD><TD>                        finally</TD></TR><TR><TD CLASS="l">1038</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>                                if (!committed)</TD></TR><TR><TD CLASS="l">1040</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>                                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1042</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1043</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1044</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1045</TD><TD>        extendedLogMessage = &#34;, Product Class = &#34; + updatedClass.getProductClass().getSymbol() +</TD></TR><TR><TD CLASS="l">1046</TD><TD>                             &#34;, Session Code = &#34; + updatedClass.getProductClass().getSessionCode() +</TD></TR><TR><TD CLASS="l">1047</TD><TD>                             &#34;, Qpe flag = &#34; + updatedClass.getProductClass().getQpeIndicator();</TD></TR><TR><TD CLASS="l">1048</TD><TD> </TD></TR><TR><TD CLASS="l">1049</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1050</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">1051</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>                Log.information(this, &#34;Could not find reporting class &#34; + reportingClassSymbol + &#34; type &#34; + type);</TD></TR><TR CLASS="z"><TD CLASS="l">1053</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>        tpfClassesRemainingCount--;</TD></TR><TR CLASS="z"><TD CLASS="l">1055</TD><TD>    if(products.length &gt; 0){// only log this message if TPF sent us some products (i.e. it was not a reject case)</TD></TR><TR CLASS="z"><TD CLASS="l">1056</TD><TD>        Log.information(this, &#34;Completed reporting class &#34; + reportingClassSymbol + extendedLogMessage);</TD></TR><TR><TD CLASS="l">1057</TD><TD>    }</TD></TR><TR><TD CLASS="l">1058</TD><TD>    else{</TD></TR><TR CLASS="z"><TD CLASS="l">1059</TD><TD>        Log.information(this, &#34;Did not receive any products from TPF for reporting class &#34; + reportingClassSymbol + &#34; type &#34; + type);</TD></TR><TR><TD CLASS="l">1060</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>        Log.information(this, &#34;Number of remaining classes = &#34; + tpfClassesRemainingCount);</TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>        if (tpfClassesRemainingCount &lt;= 0)</TD></TR><TR><TD CLASS="l">1063</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1064</TD><TD>                setTpfIndicator(false);</TD></TR><TR><TD CLASS="l">1065</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>}</TD></TR><TR><TD CLASS="l">1067</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="2d">1068</A></TD><TD> * Resets last update time.</TD></TR><TR><TD CLASS="l">1069</TD><TD> */</TD></TR><TR><TD CLASS="l">1070</TD><TD>private void resetDownloadTimer()</TD></TR><TR><TD CLASS="l">1071</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>        lastUpdateTime = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>}</TD></TR><TR><TD CLASS="l">1074</TD><TD>/**</TD></TR><TR><TD CLASS="l">1075</TD><TD> * Sets the download step name.</TD></TR><TR><TD CLASS="l">1076</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="2e">1077</A></TD><TD> * @param name name of the current step</TD></TR><TR><TD CLASS="l">1078</TD><TD> */</TD></TR><TR><TD CLASS="l">1079</TD><TD>private void setStepName(String name)</TD></TR><TR><TD CLASS="l">1080</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>        downloadStepName = name;</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>}</TD></TR><TR><TD CLASS="l">1083</TD><TD>/**</TD></TR><TR><TD CLASS="l">1084</TD><TD> * Sets TIPS in progress indicator.  Should set to true before starting</TD></TR><TR><TD CLASS="l"><A NAME="2f">1085</A></TD><TD> * product download.</TD></TR><TR><TD CLASS="l">1086</TD><TD> */</TD></TR><TR><TD CLASS="l">1087</TD><TD>protected synchronized void setTipsIndicator(boolean value)</TD></TR><TR><TD CLASS="l">1088</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1089</TD><TD>        tipsInProgress = value;</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>        notifyAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>}</TD></TR><TR><TD CLASS="l">1092</TD><TD>/**</TD></TR><TR><TD CLASS="l">1093</TD><TD> * Sets TPF in progress indicator.  Should set to true before starting</TD></TR><TR><TD CLASS="l"><A NAME="30">1094</A></TD><TD> * product download.</TD></TR><TR><TD CLASS="l">1095</TD><TD> */</TD></TR><TR><TD CLASS="l">1096</TD><TD>protected synchronized void setTpfIndicator(boolean value)</TD></TR><TR><TD CLASS="l">1097</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>        tpfInProgress = value;</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>        notifyAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1100</TD><TD>}</TD></TR><TR><TD CLASS="l">1101</TD><TD>/**</TD></TR><TR><TD CLASS="l">1102</TD><TD> * Returns status of product download.</TD></TR><TR><TD CLASS="l">1103</TD><TD> *</TD></TR><TR><TD CLASS="l">1104</TD><TD> * @return product download status</TD></TR><TR><TD CLASS="l"><A NAME="31">1105</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1106</TD><TD>public String showDownloadStatus()</TD></TR><TR><TD CLASS="l">1107</TD><TD>{</TD></TR><TR><TD CLASS="l">1108</TD><TD>        String result;</TD></TR><TR CLASS="z"><TD CLASS="l">1109</TD><TD>        if (downloadInProgress)</TD></TR><TR><TD CLASS="l">1110</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1111</TD><TD>                result = &#34;Current step = &#34; + downloadStepName +  &#34;\n&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1112</TD><TD>                if (tpfInProgress)</TD></TR><TR><TD CLASS="l">1113</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1114</TD><TD>                        result += &#34;Number classes remaining = &#34; + tpfClassesRemainingCount + &#34;\n&#34;;</TD></TR><TR><TD CLASS="l">1115</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                result += &#34;Millis since last update = &#34; + (System.currentTimeMillis() - lastUpdateTime) + &#34;\n&#34;;</TD></TR><TR><TD CLASS="l">1117</TD><TD>        }</TD></TR><TR><TD CLASS="l">1118</TD><TD>        else</TD></TR><TR><TD CLASS="l">1119</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>                result = &#34;Download is not in progress&#34;;</TD></TR><TR><TD CLASS="l">1121</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1122</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1123</TD><TD>}</TD></TR><TR><TD CLASS="l">1124</TD><TD>/**</TD></TR><TR><TD CLASS="l">1125</TD><TD> * Sets the interrupted flag so current download will be stopped.</TD></TR><TR><TD CLASS="l"><A NAME="33">1126</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1127</TD><TD>public String stopProductDownload()</TD></TR><TR><TD CLASS="l">1128</TD><TD>{</TD></TR><TR><TD CLASS="l">1129</TD><TD>        String result;</TD></TR><TR CLASS="z"><TD CLASS="l">1130</TD><TD>        if (downloadInProgress)</TD></TR><TR><TD CLASS="l">1131</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1132</TD><TD>                downloadInterrupted = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1133</TD><TD>                result = &#34;Halting product download&#34;;</TD></TR><TR><TD CLASS="l">1134</TD><TD>        }</TD></TR><TR><TD CLASS="l">1135</TD><TD>        else</TD></TR><TR><TD CLASS="l">1136</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>                result = &#34;Product download is not in progress&#34;;</TD></TR><TR><TD CLASS="l">1138</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1140</TD><TD>}</TD></TR><TR><TD CLASS="l">1141</TD><TD>/**</TD></TR><TR><TD CLASS="l">1142</TD><TD> * Creates sets of active product class symbols and reporting class symbols. These</TD></TR><TR><TD CLASS="l"><A NAME="34">1143</A></TD><TD> * sets will be updated during download processing and used in tipsDownloadPostProcess.</TD></TR><TR><TD CLASS="l">1144</TD><TD> */</TD></TR><TR><TD CLASS="l">1145</TD><TD>private void tipsDownloadInitialize()</TD></TR><TR><TD CLASS="l">1146</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>        setStepName(&#34;Initializing before calling TIPS&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1148</TD><TD>    numberSymbolsFromTips = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1149</TD><TD>        ProductType[] types = getProductTypeHome().findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1150</TD><TD>        int maxType = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1151</TD><TD>        for (int i = 0; i &lt; types.length; i++)</TD></TR><TR><TD CLASS="l">1152</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1153</TD><TD>                if (types[i].getType() &gt; maxType)</TD></TR><TR><TD CLASS="l">1154</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1155</TD><TD>                        maxType = types[i].getType();</TD></TR><TR><TD CLASS="l">1156</TD><TD>                }</TD></TR><TR><TD CLASS="l">1157</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>        productClassKeys = new HashSet[maxType + 1];</TD></TR><TR CLASS="z"><TD CLASS="l">1159</TD><TD>        reportingClassKeys = new HashSet[maxType + 1];</TD></TR><TR CLASS="z"><TD CLASS="l">1160</TD><TD>        for (int i = 0; i &lt; types.length; i++)</TD></TR><TR><TD CLASS="l">1161</TD><TD>        {</TD></TR><TR><TD CLASS="l">1162</TD><TD>        // Futures are maintained manually, so we don't want to mark them as inactive if not received</TD></TR><TR><TD CLASS="l">1163</TD><TD>        // from TIPS</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>        if (types[i].getType() != ProductTypes.FUTURE)</TD></TR><TR><TD CLASS="l">1165</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1166</TD><TD>                    productClassKeys[types[i].getType()] = getProductClassKeys(types[i].getType());</TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                    reportingClassKeys[types[i].getType()] = getReportingClassKeys(types[i].getType());</TD></TR><TR><TD CLASS="l">1168</TD><TD>        }</TD></TR><TR><TD CLASS="l">1169</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1170</TD><TD>}</TD></TR><TR><TD CLASS="l">1171</TD><TD>/**</TD></TR><TR><TD CLASS="l">1172</TD><TD> * Marks product and reporting classes that were not updated during download as</TD></TR><TR><TD CLASS="l"><A NAME="35">1173</A></TD><TD> * inactive except derivatives with active FUTUREs, and STRATEGY for the active FUTUREs</TD></TR><TR><TD CLASS="l">1174</TD><TD> */</TD></TR><TR><TD CLASS="l">1175</TD><TD>private void tipsDownloadPostProcess()</TD></TR><TR><TD CLASS="l">1176</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>        setStepName(&#34;Performing post-processing after TIPS&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1178</TD><TD>    Log.information(this, &#34;Total number of symbols recieved from TIPS = &#34; + numberSymbolsFromTips);</TD></TR><TR CLASS="z"><TD CLASS="l">1179</TD><TD>    excludeClassesWithDerivatives();</TD></TR><TR CLASS="z"><TD CLASS="l">1180</TD><TD>    excludeStrategyClassesWithActiveFuture();</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1182</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">1183</TD><TD>        try</TD></TR><TR><TD CLASS="l">1184</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                for (int i = 0; i &lt; productClassKeys.length; i++)</TD></TR><TR><TD CLASS="l">1186</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1187</TD><TD>                        if (productClassKeys[i] != null)</TD></TR><TR><TD CLASS="l">1188</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                                markProductClassesInactive(productClassKeys[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1190</TD><TD>                                markReportingClassesInactive(reportingClassKeys[i]);</TD></TR><TR><TD CLASS="l">1191</TD><TD>                                // free array entries</TD></TR><TR CLASS="z"><TD CLASS="l">1192</TD><TD>                                productClassKeys[i] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1193</TD><TD>                                reportingClassKeys[i] = null;</TD></TR><TR><TD CLASS="l">1194</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1195</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1196</TD><TD>                committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">1197</TD><TD>        }</TD></TR><TR><TD CLASS="l">1198</TD><TD>        finally</TD></TR><TR><TD CLASS="l">1199</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1200</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">1201</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1202</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1203</TD><TD>                }</TD></TR><TR><TD CLASS="l">1204</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1205</TD><TD>}</TD></TR><TR><TD CLASS="l">1206</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="36">1207</A></TD><TD> * Creates set of product keys for all active options.</TD></TR><TR><TD CLASS="l">1208</TD><TD> */</TD></TR><TR><TD CLASS="l">1209</TD><TD>private void tpfDownloadInitialize()</TD></TR><TR><TD CLASS="l">1210</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>        setStepName(&#34;Initializing before calling TPF&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1212</TD><TD>        ProductClass[] activeOptionClasses = getProductClassHome().findByType(ProductTypes.OPTION, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1213</TD><TD>        productKeys = new HashSet(activeOptionClasses.length * 100 + 1, 0.75f);</TD></TR><TR><TD CLASS="l">1214</TD><TD>        Product[] products;</TD></TR><TR CLASS="z"><TD CLASS="l">1215</TD><TD>        for (int i = 0; i &lt; activeOptionClasses.length; i++)</TD></TR><TR><TD CLASS="l">1216</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1217</TD><TD>                products = activeOptionClasses[i].getProducts(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>                for (int j = 0; j &lt; products.length; j++)</TD></TR><TR><TD CLASS="l">1219</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1220</TD><TD>                        productKeys.add(new Integer(products[j].getProductKey()));</TD></TR><TR><TD CLASS="l">1221</TD><TD>                }</TD></TR><TR><TD CLASS="l">1222</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1223</TD><TD>}</TD></TR><TR><TD CLASS="l">1224</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="37">1225</A></TD><TD> * Marks all products not updated during download as inactive.</TD></TR><TR><TD CLASS="l">1226</TD><TD> */</TD></TR><TR><TD CLASS="l">1227</TD><TD>private void tpfDownloadPostProcess()</TD></TR><TR><TD CLASS="l">1228</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1229</TD><TD>        setStepName(&#34;Performing post-processing after TPF&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1230</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1231</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">1232</TD><TD>        try</TD></TR><TR><TD CLASS="l">1233</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1234</TD><TD>                Iterator iter = productKeys.iterator();</TD></TR><TR><TD CLASS="l">1235</TD><TD>                int productKey;</TD></TR><TR><TD CLASS="l">1236</TD><TD>                Product product;</TD></TR><TR CLASS="z"><TD CLASS="l">1237</TD><TD>                while (iter.hasNext())</TD></TR><TR><TD CLASS="l">1238</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>                        productKey = ((Integer) iter.next()).intValue();</TD></TR><TR><TD CLASS="l">1240</TD><TD>                        try</TD></TR><TR><TD CLASS="l">1241</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1242</TD><TD>                                product = getProductHome().findByKey(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>                                product.setListingState(ListingStates.INACTIVE);</TD></TR><TR><TD CLASS="l">1244</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1245</TD><TD>                        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">1246</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1247</TD><TD>                                Log.alarm(this, &#34;Unable to mark product &#34; + productKey + &#34; inactive&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1248</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1249</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">1251</TD><TD>                if (committed){</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>                    publishAfterDownload();</TD></TR><TR><TD CLASS="l">1253</TD><TD>                }</TD></TR><TR><TD CLASS="l">1254</TD><TD>        }</TD></TR><TR><TD CLASS="l">1255</TD><TD>        finally</TD></TR><TR><TD CLASS="l">1256</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">1258</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1259</TD><TD>                        Log.alarm(this, &#34;Commit failed for marking products inactive after download.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1260</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1261</TD><TD>                }</TD></TR><TR><TD CLASS="l">1262</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1263</TD><TD>}</TD></TR><TR><TD CLASS="l">1264</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="38">1265</A></TD><TD> * Marks TIPS product download complete.</TD></TR><TR><TD CLASS="l">1266</TD><TD> */</TD></TR><TR><TD CLASS="l">1267</TD><TD>public void underlyingUpdateComplete()</TD></TR><TR><TD CLASS="l">1268</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1269</TD><TD>        setTipsIndicator(false);</TD></TR><TR CLASS="z"><TD CLASS="l">1270</TD><TD>}</TD></TR><TR><TD CLASS="l">1271</TD><TD>/**</TD></TR><TR><TD CLASS="l">1272</TD><TD> * Forwards call to maintenance service and removes product from inactive set.</TD></TR><TR><TD CLASS="l">1273</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="39">1274</A></TD><TD> * @see ProductMaintenanceServiceImpl#updateProduct</TD></TR><TR><TD CLASS="l">1275</TD><TD> */</TD></TR><TR><TD CLASS="l">1276</TD><TD>public ProductStruct updateProduct(ProductStruct updatedProduct) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1277</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1278</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1279</TD><TD>        ProductStruct result = getMaintenanceService().updateProduct(updatedProduct);</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>        removeFromProductSet(updatedProduct);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="41">1281</A></TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1282</TD><TD>}</TD></TR><TR><TD CLASS="l">1283</TD><TD>public com.cboe.idl.product.ProductStructV2 updateProductV2( com.cboe.idl.product.ProductStructV2 product ) throws com.cboe.exceptions.SystemException, com.cboe.exceptions.CommunicationException, com.cboe.exceptions.DataValidationException, com.cboe.exceptions.AuthorizationException</TD></TR><TR><TD CLASS="l">1284</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="43">1285</A></TD><TD>    throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt; method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1286</TD><TD>}</TD></TR><TR><TD CLASS="l">1287</TD><TD>public void updateProductWithKey(ProductStructV3 updatedProduct) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1288</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1289</TD><TD>    throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt; method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1290</TD><TD>}</TD></TR><TR><TD CLASS="l">1291</TD><TD>/**</TD></TR><TR><TD CLASS="l">1292</TD><TD> * Forwards call to maintenance service and removes class from inactive set.</TD></TR><TR><TD CLASS="l">1293</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="3a">1294</A></TD><TD> * @see ProductMaintenanceServiceImpl#updateProductClass</TD></TR><TR><TD CLASS="l">1295</TD><TD> */</TD></TR><TR><TD CLASS="l">1296</TD><TD>public ProductClassStruct updateProductClass(ClassDefinitionStruct updatedProductClass) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1297</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1298</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1299</TD><TD>        ProductClassStruct newStruct = getMaintenanceService().updateProductClass(updatedProductClass);</TD></TR><TR CLASS="z"><TD CLASS="l">1300</TD><TD>        removeFromProductClassSet(updatedProductClass.classKey, updatedProductClass.productType);</TD></TR><TR CLASS="z"><TD CLASS="l">1301</TD><TD>    return newStruct;</TD></TR><TR><TD CLASS="l"><A NAME="3c">1302</A></TD><TD>}</TD></TR><TR><TD CLASS="l">1303</TD><TD> </TD></TR><TR><TD CLASS="l">1304</TD><TD>public ProductClassStructV2 updateProductClassWithKey(ClassDefinitionStructV2 updatedProductClass) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1305</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1306</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1307</TD><TD>        ProductClassStructV2 newStruct = getMaintenanceService().updateProductClassWithKey(updatedProductClass);</TD></TR><TR CLASS="z"><TD CLASS="l">1308</TD><TD>        removeFromProductClassSet(updatedProductClass.classDefinition.classKey, updatedProductClass.classDefinition.productType);</TD></TR><TR CLASS="z"><TD CLASS="l">1309</TD><TD>    return newStruct;</TD></TR><TR><TD CLASS="l"><A NAME="3f">1310</A></TD><TD>}</TD></TR><TR><TD CLASS="l">1311</TD><TD> </TD></TR><TR><TD CLASS="l">1312</TD><TD>public ProductClassStruct updateProductClassWithSessionCode(ClassDefinitionStruct updatedProductClass, String sessionCode) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1313</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">1314</A></TD><TD>        throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt;method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1315</TD><TD>}</TD></TR><TR><TD CLASS="l">1316</TD><TD>public SessionCodeDescriptionStruct[] getSessionCodesForProductType(ProductType productType) throws TransactionFailedException, DataValidationException, SystemException,AuthorizationException</TD></TR><TR><TD CLASS="l">1317</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>        throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt; method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1319</TD><TD>}</TD></TR><TR><TD CLASS="l">1320</TD><TD>/**</TD></TR><TR><TD CLASS="l">1321</TD><TD> * Update product description info.</TD></TR><TR><TD CLASS="l">1322</TD><TD> * If the base description doesnot exist then create it, with the same values as the current</TD></TR><TR><TD CLASS="l">1323</TD><TD> * description. Then when the values for the original base description changes the update code</TD></TR><TR><TD CLASS="l">1324</TD><TD> * in here will update the modified values.</TD></TR><TR><TD CLASS="l">1325</TD><TD> *</TD></TR><TR><TD CLASS="l">1326</TD><TD> * @param reportingClass updated reporting class</TD></TR><TR><TD CLASS="l">1327</TD><TD> * @param description updated product description</TD></TR><TR><TD CLASS="l">1328</TD><TD> * @param sessionId session of product class</TD></TR><TR><TD CLASS="l"><A NAME="40">1329</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1330</TD><TD>public void updateProductDescription(ReportingClassStruct reportingClass, ProductDescriptionStruct description, String sessionId, String postNumber, String stationNumber, boolean qpeIndicator)</TD></TR><TR><TD CLASS="l">1331</TD><TD>        throws AuthorizationException, DataValidationException, TransactionFailedException, SystemException, CommunicationException {</TD></TR><TR><TD CLASS="l">1332</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1333</TD><TD>    validateBaseDescription(description);</TD></TR><TR CLASS="z"><TD CLASS="l">1334</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">1335</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1336</TD><TD>    Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">1337</TD><TD>        try {</TD></TR><TR><TD CLASS="l">1338</TD><TD>        // only contract size will be changed</TD></TR><TR CLASS="z"><TD CLASS="l">1339</TD><TD>                ReportingClass updatedClass = getReportingClassHome().findBySymbol(reportingClass.reportingClassSymbol, reportingClass.productType);</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>                updatedClass.setContractSize(reportingClass.contractSize);</TD></TR><TR><TD CLASS="l">1341</TD><TD>                ProductDescription productDescription;</TD></TR><TR><TD CLASS="l">1342</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>                        productDescription = getProductDescriptionHome().findByName(description.name);</TD></TR><TR CLASS="z"><TD CLASS="l">1344</TD><TD>                        productDescription.update(description);</TD></TR><TR><TD CLASS="l">1345</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1346</TD><TD>                catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1347</TD><TD>                        productDescription = getProductDescriptionHome().create(description);</TD></TR><TR CLASS="z"><TD CLASS="l">1348</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1349</TD><TD>                ProductClass productClass = updatedClass.getProductClass();</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>                productClass.setProductDescription(productDescription);</TD></TR><TR CLASS="z"><TD CLASS="l">1351</TD><TD>                productClass.setSessionCode(sessionId);</TD></TR><TR CLASS="z"><TD CLASS="l">1352</TD><TD>                productClass.setLocation( postNumber, stationNumber );</TD></TR><TR><TD CLASS="l">1353</TD><TD>        // removing code referencing qpe indicator from qpe phase I as part of qpe phase II</TD></TR><TR><TD CLASS="l">1354</TD><TD>        // productClass.setQpeIndicator(qpeIndicator);</TD></TR><TR><TD CLASS="l">1355</TD><TD>                // copy same changes to the strategy class.</TD></TR><TR CLASS="z"><TD CLASS="l">1356</TD><TD>                ProductClass strategyClass = getProductClassHome().findBySymbol(productClass.getSymbol(), ProductTypes.STRATEGY);</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>                ProductDescriptionStruct spreadDescription = buildProductDescriptionForSpreadFrom(description);</TD></TR><TR><TD CLASS="l">1358</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1359</TD><TD>                        productDescription = getProductDescriptionHome().findByName(spreadDescription.name);</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>                        productDescription.update(spreadDescription);</TD></TR><TR><TD CLASS="l">1361</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>                catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1363</TD><TD>                        productDescription = getProductDescriptionHome().create(spreadDescription);</TD></TR><TR CLASS="z"><TD CLASS="l">1364</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1365</TD><TD>                strategyClass.setProductDescription(productDescription);</TD></TR><TR CLASS="z"><TD CLASS="l">1366</TD><TD>                strategyClass.setSessionCode(sessionId);</TD></TR><TR CLASS="z"><TD CLASS="l">1367</TD><TD>                committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">1368</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1369</TD><TD>        catch (NotFoundException e) {</TD></TR><TR><TD CLASS="l">1370</TD><TD>        // removing code referencing qpe indicator from qpe phase I as part of qpe phase II</TD></TR><TR><TD CLASS="l">1371</TD><TD>        // Log.alarm(this, &#34;DOWNLOAD ERROR: Product description update failed for rpt_class/sessionId/post/station/qpeIndicator: &#34; +</TD></TR><TR><TD CLASS="l">1372</TD><TD>        //        reportingClass + &#34;/&#34; + sessionId + &#34;/&#34; + postNumber + &#34;/&#34; + stationNumber + &#34;/&#34; + qpeIndicator);</TD></TR><TR CLASS="z"><TD CLASS="l">1373</TD><TD>        Log.alarm(this, &#34;DOWNLOAD ERROR: Product description update failed for rpt_class/sessionId/post/station: &#34; +</TD></TR><TR><TD CLASS="l">1374</TD><TD>                reportingClass + &#34;/&#34; + sessionId + &#34;/&#34; + postNumber + &#34;/&#34; + stationNumber);</TD></TR><TR CLASS="z"><TD CLASS="l">1375</TD><TD>        Log.exception(this,e);</TD></TR><TR CLASS="z"><TD CLASS="l">1376</TD><TD>                throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">1377</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1378</TD><TD>        catch (AlreadyExistsException e) {</TD></TR><TR><TD CLASS="l">1379</TD><TD>        //Log.alarm(this, &#34;DOWNLOAD ERROR: Product description update failed for rpt_class/sessionId/post/station/qpeIndicator: &#34; +</TD></TR><TR><TD CLASS="l">1380</TD><TD>        //        reportingClass + &#34;/&#34; + sessionId + &#34;/&#34; + postNumber + &#34;/&#34; + stationNumber + &#34;/&#34; + qpeIndicator);</TD></TR><TR CLASS="z"><TD CLASS="l">1381</TD><TD>        Log.alarm(this, &#34;DOWNLOAD ERROR: Product description update failed for rpt_class/sessionId/post/station: &#34; +</TD></TR><TR><TD CLASS="l">1382</TD><TD>                        reportingClass + &#34;/&#34; + sessionId + &#34;/&#34; + postNumber + &#34;/&#34; + stationNumber);</TD></TR><TR CLASS="z"><TD CLASS="l">1383</TD><TD>        Log.exception(this,e);</TD></TR><TR CLASS="z"><TD CLASS="l">1384</TD><TD>                throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">1385</TD><TD>        }</TD></TR><TR><TD CLASS="l">1386</TD><TD>        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1387</TD><TD>                if (!committed) {</TD></TR><TR CLASS="z"><TD CLASS="l">1388</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">1389</TD><TD>                }</TD></TR><TR><TD CLASS="l">1390</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1391</TD><TD>}</TD></TR><TR><TD CLASS="l">1392</TD><TD>/**</TD></TR><TR><TD CLASS="l">1393</TD><TD> * Checks to verify that product type is a base type (equity, etc.).</TD></TR><TR><TD CLASS="l"><A NAME="4">1394</A></TD><TD> *</TD></TR><TR><TD CLASS="l">1395</TD><TD> */</TD></TR><TR><TD CLASS="l">1396</TD><TD>private boolean baseProductType(int typeCode)</TD></TR><TR><TD CLASS="l">1397</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1398</TD><TD>    boolean result = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1399</TD><TD>    switch (typeCode)</TD></TR><TR><TD CLASS="l">1400</TD><TD>    {</TD></TR><TR><TD CLASS="l">1401</TD><TD>        case ProductTypes.EQUITY:</TD></TR><TR><TD CLASS="l">1402</TD><TD>        case ProductTypes.DEBT:</TD></TR><TR><TD CLASS="l">1403</TD><TD>        case ProductTypes.COMMODITY:</TD></TR><TR><TD CLASS="l">1404</TD><TD>        case ProductTypes.INDEX:</TD></TR><TR><TD CLASS="l">1405</TD><TD>        case ProductTypes.VOLATILITY_INDEX:</TD></TR><TR CLASS="z"><TD CLASS="l">1406</TD><TD>        result = true;</TD></TR><TR><TD CLASS="l">1407</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1408</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1409</TD><TD>}</TD></TR><TR><TD CLASS="l">1410</TD><TD>/**</TD></TR><TR><TD CLASS="l">1411</TD><TD> * Build the product description for spread based on the description for the related option class.</TD></TR><TR><TD CLASS="l">1412</TD><TD> * The basic differences are: the minimumAbovePremiumFraction and the minimumBelowPremiumFraction should</TD></TR><TR><TD CLASS="l">1413</TD><TD> * be the same and equal to the minimum below value. Of course, the description will get a</TD></TR><TR><TD CLASS="l">1414</TD><TD> * different name.</TD></TR><TR><TD CLASS="l"><A NAME="5">1415</A></TD><TD> *</TD></TR><TR><TD CLASS="l">1416</TD><TD> * @param productDesc the product description for the related option class</TD></TR><TR><TD CLASS="l">1417</TD><TD> */</TD></TR><TR><TD CLASS="l">1418</TD><TD>private ProductDescriptionStruct buildProductDescriptionForSpreadFrom(ProductDescriptionStruct productDesc){</TD></TR><TR CLASS="z"><TD CLASS="l">1419</TD><TD>        ProductDescriptionStruct newDesc = new ProductDescriptionStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">1420</TD><TD>        newDesc.baseDescriptionName = productDesc.baseDescriptionName;</TD></TR><TR CLASS="z"><TD CLASS="l">1421</TD><TD>        newDesc.maxStrikePrice = productDesc.maxStrikePrice;</TD></TR><TR CLASS="z"><TD CLASS="l">1422</TD><TD>        newDesc.minimumAbovePremiumFraction = productDesc.minimumBelowPremiumFraction;</TD></TR><TR CLASS="z"><TD CLASS="l">1423</TD><TD>        newDesc.minimumBelowPremiumFraction = productDesc.minimumBelowPremiumFraction;</TD></TR><TR CLASS="z"><TD CLASS="l">1424</TD><TD>        newDesc.minimumStrikePriceFraction = productDesc.minimumStrikePriceFraction;</TD></TR><TR CLASS="z"><TD CLASS="l">1425</TD><TD>        newDesc.name = getProductDescriptionNameForSpread(productDesc);</TD></TR><TR CLASS="z"><TD CLASS="l">1426</TD><TD>        newDesc.premiumBreakPoint = productDesc.premiumBreakPoint;</TD></TR><TR CLASS="z"><TD CLASS="l">1427</TD><TD>        newDesc.premiumPriceFormat = productDesc.premiumPriceFormat;</TD></TR><TR CLASS="z"><TD CLASS="l">1428</TD><TD>        newDesc.priceDisplayType = productDesc.priceDisplayType;</TD></TR><TR CLASS="z"><TD CLASS="l">1429</TD><TD>        newDesc.strikePriceFormat = productDesc.strikePriceFormat;</TD></TR><TR CLASS="z"><TD CLASS="l">1430</TD><TD>        newDesc.underlyingPriceFormat = productDesc.underlyingPriceFormat;</TD></TR><TR CLASS="z"><TD CLASS="l">1431</TD><TD>        return newDesc;</TD></TR><TR><TD CLASS="l">1432</TD><TD>}</TD></TR><TR><TD CLASS="l">1433</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="18">1434</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1435</TD><TD> * get the product description name for spread</TD></TR><TR><TD CLASS="l">1436</TD><TD> */</TD></TR><TR><TD CLASS="l">1437</TD><TD>private String getProductDescriptionNameForSpread(ProductDescriptionStruct productDesc){</TD></TR><TR CLASS="z"><TD CLASS="l">1438</TD><TD>        return productDesc.name + &#34; &#34; + &#34;Spread&#34;;</TD></TR><TR><TD CLASS="l">1439</TD><TD>}</TD></TR><TR><TD CLASS="l">1440</TD><TD>/**</TD></TR><TR><TD CLASS="l">1441</TD><TD> * Create base product description info if necessary.</TD></TR><TR><TD CLASS="l">1442</TD><TD> * If the base description doesnot exist then create it, with the same values as the current</TD></TR><TR><TD CLASS="l">1443</TD><TD> * description. Then when the values for the original base description changes the update code</TD></TR><TR><TD CLASS="l">1444</TD><TD> * in here will update the modified values.</TD></TR><TR><TD CLASS="l">1445</TD><TD> *</TD></TR><TR><TD CLASS="l">1446</TD><TD> * @param description updated product description</TD></TR><TR><TD CLASS="l">1447</TD><TD> */</TD></TR><TR><TD CLASS="l">1448</TD><TD>private void validateBaseDescription(ProductDescriptionStruct description)</TD></TR><TR><TD CLASS="l">1449</TD><TD>        throws DataValidationException, TransactionFailedException {</TD></TR><TR><TD CLASS="l">1450</TD><TD> </TD></TR><TR><TD CLASS="l">1451</TD><TD>    // Save of the original description and base description names</TD></TR><TR><TD CLASS="l"><A NAME="4b">1452</A></TD><TD>    // because we may end up creating the base description using the same</TD></TR><TR><TD CLASS="l">1453</TD><TD>    // STRUCT's in which case we will just patch the names then later on</TD></TR><TR><TD CLASS="l">1454</TD><TD>    // when updating the real description we will need to revert back</TD></TR><TR><TD CLASS="l">1455</TD><TD>    // to the correct names.</TD></TR><TR CLASS="z"><TD CLASS="l">1456</TD><TD>        boolean committed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>    String originalDescriptionName = description.name;</TD></TR><TR CLASS="z"><TD CLASS="l">1458</TD><TD>    String originalBaseDescriptionName = description.baseDescriptionName;</TD></TR><TR><TD CLASS="l">1459</TD><TD> </TD></TR><TR><TD CLASS="l">1460</TD><TD>    // Make sure the base description exists if not create a new one.</TD></TR><TR CLASS="z"><TD CLASS="l">1461</TD><TD>    if (originalBaseDescriptionName != null &amp;&amp; originalBaseDescriptionName.length() != 0) {</TD></TR><TR><TD CLASS="l">1462</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1463</TD><TD>                           getProductDescriptionHome().findByName(originalBaseDescriptionName);</TD></TR><TR><TD CLASS="l">1464</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1465</TD><TD>            catch (NotFoundException e) {</TD></TR><TR><TD CLASS="l">1466</TD><TD>            // create the base description</TD></TR><TR><TD CLASS="l">1467</TD><TD>            // Change the names in the struct.</TD></TR><TR CLASS="z"><TD CLASS="l">1468</TD><TD>            Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">1469</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1470</TD><TD>                description.name = originalBaseDescriptionName;</TD></TR><TR CLASS="z"><TD CLASS="l">1471</TD><TD>                description.baseDescriptionName = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1472</TD><TD>                        getProductDescriptionHome().create(description);</TD></TR><TR CLASS="z"><TD CLASS="l">1473</TD><TD>                    committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">1474</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1475</TD><TD>            catch (AlreadyExistsException e1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1476</TD><TD>                Log.alarm(this, &#34;DOWNLOAD ERROR: Failed to create base product description with name: &#34; + originalBaseDescriptionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1477</TD><TD>                Log.exception(this,&#34;Error creating base production description. Got not found first  , so we tried to create it , then we get a AlreadyExistsException - What is going on here ???? for description: &#34; + description.name,e1);</TD></TR><TR><TD CLASS="l">1478</TD><TD>            }</TD></TR><TR><TD CLASS="l">1479</TD><TD>            finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1480</TD><TD>                if (!committed) {</TD></TR><TR CLASS="z"><TD CLASS="l">1481</TD><TD>                    Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">1482</TD><TD>                    throw ExceptionBuilder.transactionFailedException(&#34;Error creating base description: &#34; + description.name,0);</TD></TR><TR><TD CLASS="l">1483</TD><TD>                }</TD></TR><TR><TD CLASS="l">1484</TD><TD>            }</TD></TR><TR><TD CLASS="l">1485</TD><TD>        }</TD></TR><TR><TD CLASS="l">1486</TD><TD>        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1487</TD><TD>            description.name = originalDescriptionName;</TD></TR><TR CLASS="z"><TD CLASS="l">1488</TD><TD>            description.baseDescriptionName = originalBaseDescriptionName;</TD></TR><TR><TD CLASS="l">1489</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1490</TD><TD>        }</TD></TR><TR><TD CLASS="l">1491</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1492</TD><TD>}</TD></TR><TR><TD CLASS="l">1493</TD><TD> </TD></TR><TR><TD CLASS="l">1494</TD><TD>/**</TD></TR><TR><TD CLASS="l">1495</TD><TD> * Forwards call to maintenance service and removes products from inactive set.</TD></TR><TR><TD CLASS="l">1496</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="45">1497</A></TD><TD> * @see ProductMaintenanceServiceImpl#updateProductClass</TD></TR><TR><TD CLASS="l">1498</TD><TD> */</TD></TR><TR><TD CLASS="l">1499</TD><TD>public ProductStruct[] updateProducts(ProductStruct[] updatedProducts) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1500</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1501</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1502</TD><TD>        ProductStruct[] results = getMaintenanceService().updateProducts(updatedProducts);</TD></TR><TR CLASS="z"><TD CLASS="l">1503</TD><TD>        for (int i = 0; i &lt; updatedProducts.length; i++)</TD></TR><TR><TD CLASS="l">1504</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1505</TD><TD>                removeFromProductSet(updatedProducts[i]);</TD></TR><TR><TD CLASS="l">1506</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="47">1507</A></TD><TD>    return results;</TD></TR><TR><TD CLASS="l">1508</TD><TD>}</TD></TR><TR><TD CLASS="l">1509</TD><TD>public ProductResultStruct[] updateProductsWithKey(ProductStructV3[] updatedProducts) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1510</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1511</TD><TD>    throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt; method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1512</TD><TD>}</TD></TR><TR><TD CLASS="l">1513</TD><TD>/**</TD></TR><TR><TD CLASS="l">1514</TD><TD> * Forwards call to maintenance service and removes class from inactive set.</TD></TR><TR><TD CLASS="l">1515</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="49">1516</A></TD><TD> * @see ProductMaintenanceServiceImpl#updateReportingClass</TD></TR><TR><TD CLASS="l">1517</TD><TD> */</TD></TR><TR><TD CLASS="l">1518</TD><TD>public ReportingClassStruct updateReportingClass(ReportingClassStruct updatedReportingClass) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1519</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1520</TD><TD>        resetDownloadTimer();</TD></TR><TR CLASS="z"><TD CLASS="l">1521</TD><TD>        ReportingClassStruct result = getMaintenanceService().updateReportingClass(updatedReportingClass);</TD></TR><TR CLASS="z"><TD CLASS="l">1522</TD><TD>        removeFromReportingClassSet(updatedReportingClass.classKey, updatedReportingClass.productType);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4a">1523</A></TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1524</TD><TD>}</TD></TR><TR><TD CLASS="l">1525</TD><TD>public void updateReportingClassWithKey(ReportingClassStructV2 updatedReportingClass) throws TransactionFailedException, DataValidationException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">1526</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1527</TD><TD>    throw ExceptionBuilder.authorizationException(&#34;ProductDownloadController-&gt; method not implemented!&#34; , com.cboe.idl.cmiErrorCodes.AuthenticationCodes.FUNCTION_NOT_IMPLEMENTED);</TD></TR><TR><TD CLASS="l">1528</TD><TD>}</TD></TR><TR><TD CLASS="l">1529</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="4c">1530</A></TD><TD> * Waits for TIPS indicator to be set to true.</TD></TR><TR><TD CLASS="l">1531</TD><TD> */</TD></TR><TR><TD CLASS="l">1532</TD><TD>protected synchronized void waitForTipsCompletion() throws InterruptedException</TD></TR><TR><TD CLASS="l">1533</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1534</TD><TD>        setStepName(&#34;Waiting for TIPS completion&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1535</TD><TD>        while (tipsInProgress &amp;&amp; !downloadInterrupted)</TD></TR><TR><TD CLASS="l">1536</TD><TD>        {</TD></TR><TR><TD CLASS="l">1537</TD><TD>                // wait for notification or timeout</TD></TR><TR CLASS="z"><TD CLASS="l">1538</TD><TD>                wait(WAIT_PERIOD);</TD></TR><TR CLASS="z"><TD CLASS="l">1539</TD><TD>                checkTimeout();</TD></TR><TR><TD CLASS="l">1540</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>        if (downloadInterrupted)</TD></TR><TR><TD CLASS="l">1542</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1543</TD><TD>                throw new InterruptedException(&#34;Download interrupted while waiting for TIPS&#34;);</TD></TR><TR><TD CLASS="l">1544</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1545</TD><TD>}</TD></TR><TR><TD CLASS="l">1546</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="4d">1547</A></TD><TD> * Waits for TPF indicator to be set to true.</TD></TR><TR><TD CLASS="l">1548</TD><TD> */</TD></TR><TR><TD CLASS="l">1549</TD><TD>protected synchronized void waitForTpfCompletion() throws InterruptedException</TD></TR><TR><TD CLASS="l">1550</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1551</TD><TD>        setStepName(&#34;Waiting for TPF completion&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1552</TD><TD>        while (tpfInProgress &amp;&amp; !downloadInterrupted)</TD></TR><TR><TD CLASS="l">1553</TD><TD>        {</TD></TR><TR><TD CLASS="l">1554</TD><TD>                // wait for notification or timeout</TD></TR><TR CLASS="z"><TD CLASS="l">1555</TD><TD>                wait(WAIT_PERIOD);</TD></TR><TR CLASS="z"><TD CLASS="l">1556</TD><TD>                checkTimeout();</TD></TR><TR><TD CLASS="l">1557</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1558</TD><TD>        if (downloadInterrupted)</TD></TR><TR><TD CLASS="l">1559</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1560</TD><TD>                throw new InterruptedException(&#34;Download interrupted while waiting for TPF&#34;);</TD></TR><TR><TD CLASS="l">1561</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1562</TD><TD>}</TD></TR><TR><TD CLASS="l">1563</TD><TD> </TD></TR><TR><TD CLASS="l">1564</TD><TD>/**</TD></TR><TR><TD CLASS="l">1565</TD><TD> * Defines underlying and reporting classes for products defined in Tips. Called during Tips download to give base symbol and all</TD></TR><TR><TD CLASS="l">1566</TD><TD> * aliases for each symbol defined in Tips.</TD></TR><TR><TD CLASS="l">1567</TD><TD> *</TD></TR><TR><TD CLASS="l">1568</TD><TD> * This method will remap any reporting classes to their corresponding product classes as defined in the</TD></TR><TR><TD CLASS="l">1569</TD><TD> * symbol map file (which is loaded into the variable &lt;code&gt;reportingSymbolMap&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1570</TD><TD> *</TD></TR><TR><TD CLASS="l">1571</TD><TD> * NOTE: underlyingSymbolName is the same for all reporting classes remapped to different product classes.</TD></TR><TR><TD CLASS="l">1572</TD><TD> *</TD></TR><TR><TD CLASS="l">1573</TD><TD> * @param underlyingProductSymbol symbol of the underlying product</TD></TR><TR><TD CLASS="l">1574</TD><TD> * @param productType product type code of the underlying product</TD></TR><TR><TD CLASS="l">1575</TD><TD> * @param reportingClasses all of the defined aliases for the product.  An option class will be defined underlying symbol and each</TD></TR><TR><TD CLASS="l">1576</TD><TD> *                         of the aliases</TD></TR><TR><TD CLASS="l">1577</TD><TD> * @exception DataValidationException if transaction fails</TD></TR><TR><TD CLASS="l">1578</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="a">1579</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1580</TD><TD>public void defineClasses(String underlyingProductSymbol, short productType, String[] reportingClasses) throws DataValidationException {</TD></TR><TR><TD CLASS="l">1581</TD><TD> </TD></TR><TR><TD CLASS="l">1582</TD><TD>    // Key is productClassSymbol &amp; value is an Array list of reporting class names</TD></TR><TR CLASS="z"><TD CLASS="l">1583</TD><TD>    HashMap productClasses = new HashMap();</TD></TR><TR CLASS="z"><TD CLASS="l">1584</TD><TD>    numberSymbolsFromTips++;</TD></TR><TR CLASS="z"><TD CLASS="l">1585</TD><TD>    if (numberSymbolsFromTips % 100 == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1586</TD><TD>        Log.information(this, &#34;TIPS download in progress - number symbols receieved so far = &#34; + numberSymbolsFromTips);</TD></TR><TR><TD CLASS="l">1587</TD><TD>    }</TD></TR><TR><TD CLASS="l">1588</TD><TD> </TD></TR><TR><TD CLASS="l">1589</TD><TD>    // If no remaps of classes have occured then use this methods parameter values</TD></TR><TR CLASS="z"><TD CLASS="l">1590</TD><TD>    if (!remapClasses(underlyingProductSymbol,reportingClasses,productClasses)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1591</TD><TD>        defineClasses(underlyingProductSymbol,underlyingProductSymbol,productType,reportingClasses);</TD></TR><TR><TD CLASS="l">1592</TD><TD>    }</TD></TR><TR><TD CLASS="l">1593</TD><TD>    else{</TD></TR><TR><TD CLASS="l">1594</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1595</TD><TD>        Object[] remappedClasses = (productClasses.keySet()).toArray();</TD></TR><TR CLASS="z"><TD CLASS="l">1596</TD><TD>        String prodClassName = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>        String[] reportingClassList = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1598</TD><TD>        ArrayList list = null;</TD></TR><TR><TD CLASS="l">1599</TD><TD> </TD></TR><TR><TD CLASS="l">1600</TD><TD>        // Define classes for each product class.</TD></TR><TR><TD CLASS="l">1601</TD><TD>        // NOTE: all of them point to the same underlying.</TD></TR><TR CLASS="z"><TD CLASS="l">1602</TD><TD>        for (int i = 0; i &lt; remappedClasses.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1603</TD><TD>            prodClassName = (String)remappedClasses[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1604</TD><TD>            list = (ArrayList)productClasses.get(prodClassName);</TD></TR><TR CLASS="z"><TD CLASS="l">1605</TD><TD>            reportingClassList = new String[list.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1606</TD><TD>            list.toArray(reportingClassList);</TD></TR><TR CLASS="z"><TD CLASS="l">1607</TD><TD>            Log.information(this,&#34;Adding REMAPPED CLASS : Underlying:&#34; + underlyingProductSymbol + &#34;/ ProdClass: &#34; + prodClassName + &#34;/ ReportingClasses = &#34; + list.toString());</TD></TR><TR><TD CLASS="l">1608</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1609</TD><TD>            defineClasses(underlyingProductSymbol,prodClassName,productType,reportingClassList);</TD></TR><TR><TD CLASS="l">1610</TD><TD>        }</TD></TR><TR><TD CLASS="l">1611</TD><TD> </TD></TR><TR><TD CLASS="l">1612</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1613</TD><TD>}</TD></TR><TR><TD CLASS="l">1614</TD><TD> </TD></TR><TR><TD CLASS="l">1615</TD><TD> </TD></TR><TR><TD CLASS="l">1616</TD><TD> </TD></TR><TR><TD CLASS="l">1617</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1618</TD><TD> * This method will remap any reporting classes to their corresponding product classes as defined in the</TD></TR><TR><TD CLASS="l">1619</TD><TD> * symbol map file (which is loaded into the variable &lt;code&gt;reportingSymbolMap&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1620</TD><TD> *</TD></TR><TR><TD CLASS="l">1621</TD><TD> * @param underlyingProductSymbol the default product class symbol.</TD></TR><TR><TD CLASS="l">1622</TD><TD> * @param reportingClasses all of the defined aliases for the product.</TD></TR><TR><TD CLASS="l">1623</TD><TD> * @param productClasses the remapped output.</TD></TR><TR><TD CLASS="l">1624</TD><TD> *        (Key is productClassSymbol &amp; value is an Array list of reporting class names)</TD></TR><TR><TD CLASS="l"><A NAME="27">1625</A></TD><TD> *</TD></TR><TR><TD CLASS="l">1626</TD><TD> */</TD></TR><TR><TD CLASS="l">1627</TD><TD>private boolean remapClasses(String underlyingProductSymbol,String[] reportingClasses, HashMap productClasses) {</TD></TR><TR><TD CLASS="l">1628</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1629</TD><TD>    boolean remapOccured = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1630</TD><TD>    productClasses.clear();</TD></TR><TR><TD CLASS="l">1631</TD><TD> </TD></TR><TR><TD CLASS="l">1632</TD><TD>    // Remap if needed and separate out remap information in the map productClasses above.</TD></TR><TR CLASS="z"><TD CLASS="l">1633</TD><TD>    String prodClassSymbol = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1634</TD><TD>    ArrayList reportingClassList = null;</TD></TR><TR><TD CLASS="l">1635</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1636</TD><TD>    for (int i = 0; i &lt; reportingClasses.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1637</TD><TD>        prodClassSymbol = (String)reportingClassSymbolMap.get(reportingClasses[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1638</TD><TD>        if (prodClassSymbol != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1639</TD><TD>            remapOccured = true;</TD></TR><TR><TD CLASS="l">1640</TD><TD>        }</TD></TR><TR><TD CLASS="l">1641</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1642</TD><TD>            prodClassSymbol = underlyingProductSymbol;</TD></TR><TR><TD CLASS="l">1643</TD><TD>        }</TD></TR><TR><TD CLASS="l">1644</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1645</TD><TD>        reportingClassList = (ArrayList)productClasses.get(prodClassSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">1646</TD><TD>        if (reportingClassList == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1647</TD><TD>            reportingClassList = new ArrayList(10);</TD></TR><TR><TD CLASS="l">1648</TD><TD>            // Add reporting class with same name as product class.</TD></TR><TR CLASS="z"><TD CLASS="l">1649</TD><TD>            reportingClassList.add(prodClassSymbol);</TD></TR><TR CLASS="z"><TD CLASS="l">1650</TD><TD>            productClasses.put(prodClassSymbol,reportingClassList);</TD></TR><TR><TD CLASS="l">1651</TD><TD>        }</TD></TR><TR><TD CLASS="l">1652</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1653</TD><TD>        if (!reportingClassList.contains(reportingClasses[i])) {</TD></TR><TR CLASS="z"><TD CLASS="l">1654</TD><TD>            reportingClassList.add(reportingClasses[i]);</TD></TR><TR><TD CLASS="l">1655</TD><TD>        }</TD></TR><TR><TD CLASS="l">1656</TD><TD>    }</TD></TR><TR><TD CLASS="l">1657</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>    return remapOccured;</TD></TR><TR><TD CLASS="l"><A NAME="13">1659</A></TD><TD>}</TD></TR><TR><TD CLASS="l">1660</TD><TD> </TD></TR><TR><TD CLASS="l">1661</TD><TD>    private ProductExpirationManager getExpirationManager()</TD></TR><TR><TD CLASS="l">1662</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1663</TD><TD>        if(expirationManager == null)</TD></TR><TR><TD CLASS="l">1664</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1665</TD><TD>            expirationManager = new ProductExpirationManager();</TD></TR><TR CLASS="z"><TD CLASS="l">1666</TD><TD>            getBOHome().addToContainer(expirationManager);</TD></TR><TR CLASS="z"><TD CLASS="l">1667</TD><TD>            expirationManager.create();</TD></TR><TR><TD CLASS="l">1668</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1669</TD><TD>        return expirationManager;</TD></TR><TR><TD CLASS="l">1670</TD><TD>    }</TD></TR><TR><TD CLASS="l">1671</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l">1672</TD><TD>     * @see com.cboe.idl.internalBusinessServices.ProductUpdateInterfaceOperations#updateProductClassWithKeyV3(com.cboe.idl.product.ClassDefinitionStructV3)</TD></TR><TR><TD CLASS="l"><A NAME="3d">1673</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1674</TD><TD>    public ProductClassStructV3 updateProductClassWithKeyV3(ClassDefinitionStructV3 updatedProductClass) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">1675</TD><TD>    {</TD></TR><TR><TD CLASS="l">1676</TD><TD>        // TODO Auto-generated method stub</TD></TR><TR CLASS="z"><TD CLASS="l">1677</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">1678</TD><TD>    }</TD></TR><TR><TD CLASS="l">1679</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l">1680</TD><TD>     * @see com.cboe.idl.internalBusinessServices.ProductUpdateInterfaceOperations#updateProductV4(com.cboe.idl.product.ProductStructV4)</TD></TR><TR><TD CLASS="l"><A NAME="42">1681</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1682</TD><TD>    public ProductStructV4 updateProductV4(ProductStructV4 updatedProduct) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">1683</TD><TD>    {</TD></TR><TR><TD CLASS="l">1684</TD><TD>        // TODO Auto-generated method stub</TD></TR><TR CLASS="z"><TD CLASS="l">1685</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">1686</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="44">1687</A></TD><TD>    public void updateProductWithKeyV4(ProductStructV4 p_newProduct) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException, AlreadyExistsException</TD></TR><TR><TD CLASS="l">1688</TD><TD>    {</TD></TR><TR><TD CLASS="l">1689</TD><TD>        // TODO Auto-generated method stub</TD></TR><TR><TD CLASS="l">1690</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="46">1691</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1692</TD><TD>    public ProductStructV4[] updateProductsV4(ProductStructV4[] p_updatedProducts) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">1693</TD><TD>    {</TD></TR><TR><TD CLASS="l">1694</TD><TD>        // TODO Auto-generated method stub</TD></TR><TR CLASS="z"><TD CLASS="l">1695</TD><TD>        return null;</TD></TR><TR><TD CLASS="l"><A NAME="48">1696</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1697</TD><TD>    public ProductResultStruct[] updateProductsWithKeyV4(ProductStructV4[] p_updatedProducts) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">1698</TD><TD>    {</TD></TR><TR><TD CLASS="l">1699</TD><TD>        // TODO Auto-generated method stub</TD></TR><TR CLASS="z"><TD CLASS="l">1700</TD><TD>        return null;</TD></TR><TR><TD CLASS="l"><A NAME="3e">1701</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1702</TD><TD>    </TD></TR><TR><TD CLASS="l">1703</TD><TD>    public ProductClassStructV6 updateProductClassWithKeyV6(ClassDefinitionStructV6 arg0) throws SystemException, CommunicationException, DataValidationException, TransactionFailedException, AuthorizationException {</TD></TR><TR><TD CLASS="l">1704</TD><TD>            // TODO Auto-generated method stub</TD></TR><TR CLASS="z"><TD CLASS="l">1705</TD><TD>            return null;</TD></TR><TR><TD CLASS="l"><A NAME="3b">1706</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1707</TD><TD>    </TD></TR><TR><TD CLASS="l">1708</TD><TD>    public ProductClassStructV6 updateProductClassV6(ClassDefinitionStructV6 updatedProductClass) throws SystemException,CommunicationException,DataValidationException,TransactionFailedException,AuthorizationException</TD></TR><TR><TD CLASS="l">1709</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1710</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">1711</TD><TD>    }</TD></TR><TR><TD CLASS="l">1712</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="5c.html">com.cboe.internalBusinessServices.productService</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>