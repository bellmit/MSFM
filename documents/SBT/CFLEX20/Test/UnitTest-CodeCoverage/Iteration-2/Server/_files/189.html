<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon May 16 15:10:41 CDT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1e.html">com.cboe.businessServices.tradingSessionService</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">TradingSessionServiceLocalImpl.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>TradingSessionServiceLocalImpl.java</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/214)</TD><TD CLASS="h">0%   (0/11819)</TD><TD CLASS="h">0%   (0/2257)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">TradingSessionServiceLocalImpl</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/200)</TD><TD CLASS="h">0%   (0/10871)</TD><TD CLASS="h">0%   (0/2108)</TD></TR><TR><TD CLASS="f"><A HREF="#1">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/114)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">TradingSessionServiceLocalImpl (String, TradingSessionClientImpl, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/68)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#3">abortEndOfSession (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">acceptFlexStrategy (StrategyLegDefinitionStruct []): StrategyStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#5">acceptStrategy (String, StrategyRequestStruct): SessionStrategyStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/298)</TD><TD CLASS="h">0%   (0/36)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">acceptUnderlyingProductStateChange (int, String, ProductStateStruct []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/284)</TD><TD CLASS="h">0%   (0/41)</TD></TR><TR><TD CLASS="f"><A HREF="#0">access$000 (TradingSessionServiceLocalImpl): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">access$102 (Boolean): Boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#0">access$200 (TradingSessionServiceLocalImpl, TradingSession): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">access$300 (TradingSessionServiceLocalImpl, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#0">access$400 (TradingSessionServiceLocalImpl): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">addClassToTemplate (String, TemplateClassStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#d">addListener (TradingSessionEventType, int, TradingSessionListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">addStrategyProductToSession (TradingSession, StrategyStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/56)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#f">addStrategyProductToSessions (StrategyStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/102)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">addTradingSession (TradingSessionStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#11">addTradingSessionTemplate (TradingSessionElementTemplateStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">areAllProductsForClassInStateAndInTimeRange (String, int, short): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/224)</TD><TD CLASS="h">0%   (0/37)</TD></TR><TR><TD CLASS="f"><A HREF="#13">areAllSessionsClosed (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">areAllSessionsClosedOptimized (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#15">buildPendingOrderReportStruct (): PendingOrderReportStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">buildPendingOrderStruct (): PendingOrderStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#17">buildPendingStrategyProductKeys (PendingAdjustmentStruct, List): List</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/155)</TD><TD CLASS="h">0%   (0/29)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">buildSessionStrategyStruct (SessionProductStruct, String): SessionStrategyStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#19">buildSessionStrategyStruct (StrategyStruct, String): SessionStrategyStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">buildTemplateClassMapping (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/68)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">clearElementCache (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">clearSessionProdCache (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">clearSessionProdCache (String, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">convertErrorCodeToGroupErrorCode (String, ErrorCodeResultStruct []): GroupErr...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/194)</TD><TD CLASS="h">0%   (0/37)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">convertToPendingOrderStruct (PendingNameStruct, OrderStruct [], OrderStruct [...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/38)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">createCurrentBusinessDay (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/171)</TD><TD CLASS="h">0%   (0/36)</TD></TR><TR><TD CLASS="f"><A HREF="#21">createElementsForSession (String, DateStruct): TradingSessionElementStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">createStrategyLegsForFlex (StrategyLegDefinitionStruct []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/136)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR><TD CLASS="f"><A HREF="#23">execute (boolean, ClientAction): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">execute (boolean, ClientAction, Map, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/214)</TD><TD CLASS="h">0%   (0/42)</TD></TR><TR><TD CLASS="f"><A HREF="#25">execute (boolean, ClientAction, String [], String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/67)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">execute (boolean, TradingSessionEventType, TradingSessionStruct, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#27">fillPendingProductName (PendingOrderReportStruct, PendingAdjustmentStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">filterOrdersWithNonAdjustedProducts (PendingOrderStruct [], PendingAdjustment...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/52)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#29">fireEvent (int, String, String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">fireEvent (int, String, String, boolean, boolean): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">fireEvent (int, String, String, boolean, boolean, String [], String []): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/138)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">fireEventForServers (int, String, String, boolean, boolean, String []): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">getAbortEndOfSession (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">getAdjustedReportOrders (PendingOrderStruct [], PriceAdjustmentStruct, Pendin...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/115)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">getAllTemplates (): TradingSessionElementTemplateStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">getBusinessDayHome (): BusinessDayHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#31">getCachedDerivativeClassesForProduct (int): ClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/82)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">getCachedElementClasses (int): SessionClassDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/69)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#33">getCachedTradingSessionsForClass (int): String []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">getClassBySessionForKey (String, int): SessionClassStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#35">getClassBySessionForSymbol (String, short, String): SessionClassStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">getClassStatesForElement (int): ClassStateDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/38)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#37">getClassStatesForSession (String): ClassStateDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">getClassSymbol (int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#39">getClassesBySession (String): SessionClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">getClassesBySession (String, boolean): SessionClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">getClassesBySessionForType (String, short): SessionClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">getClassesBySessionWithParallelThreads (String, boolean): SessionClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/91)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">getClassesForElement (int): SessionClassDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">getClassesForElementPrivate (int): SessionClassDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">getClassesForSession (String): SessionClassDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">getClassesForSessionByGroup (String, String): SessionClassDetailStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/87)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#41">getClassesForTemplate (String): TemplateClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">getCurrentBusinessDay (): BusinessDayStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/165)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR><TD CLASS="f"><A HREF="#43">getCurrentBusinessDayWithParallelThread (): BusinessDayStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/175)</TD><TD CLASS="h">0%   (0/44)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">getCurrentElementsForSession (String): TradingSessionElementStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#45">getCurrentTradingSessionElements (): TradingSessionElementStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">getCurrentTradingSessionsForClasses (int []): TradingSessionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/49)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#47">getElementByKey (int): TradingSessionElementStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">getElementClassesForSessionByGroup (String, String): TradingSessionElementCla...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/134)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR><TD CLASS="f"><A HREF="#49">getElementsForSession (String, DateStruct): TradingSessionElementStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">getElementsForTemplate (String): TradingSessionElementStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">getEnabledOrderCancelling (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">getEndOfDayStrategies (): TradingSessionStrategyDescriptionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">getEndOfSessionStrategies (): TradingSessionStrategyDescriptionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">getEventGroup (String, int): TradingSessionEventGroupType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">getEventHistory (String): TradingSessionEventHistoryStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">getEventHistoryHome (): TradingSessionEventHistoryHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#51">getEventHistoryV2 (String): TradingSessionEventHistoryStructV2 []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">getEventTradingSesssion (String): TradingSessionStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#53">getMarketDataSummaryHome (): MarketDataSummaryHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">getNextSessionForClass (int): TradingSessionStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#55">getOrderHandlingService (): OrderHandlingService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">getPendingAdjustmentOrders (String): PendingOrderStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/213)</TD><TD CLASS="h">0%   (0/44)</TD></TR><TR><TD CLASS="f"><A HREF="#57">getPendingAdjustments (): PendingAdjustmentStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#58">getProductBySessionForKey (String, int): SessionProductStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#59">getProductBySessionForName (String, ProductNameStruct): SessionProductStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/56)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">getProductClassHome (): ProductClassHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">getProductClassesForSession (String, boolean, boolean): ProductClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">getProductConfigurationService (): ProductConfigurationService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">getProductHome (): ProductHome</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">getProductMaintenanceService (): ProductMaintenanceService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#5f">getProductQueryService (): ProductQueryService</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#60">getProductStateChangeStrategy (): ProductStateChangeStrategy</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#61">getProductTypesForSession (String): ProductTypeStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/83)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">getProductsBySessionForClass (String, int): SessionProductStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/45)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#63">getQuickStartSessionFlag (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#64">getRegisteredServersEventState (String): TradingSessionServerEventStateStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#65">getRemoteClients (): Map</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/345)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#66">getSessionLock (String): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#67">getSessionProdCache (String): HashMap</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/134)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#68">getStrategiesByComponent (int, String): SessionStrategyStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#69">getStrategiesBySessionForClass (String, int): SessionStrategyStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/127)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6a">getStrategiesForSession (String): SessionStrategyStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/78)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#6b">getStrategyBySessionForKey (String, int): SessionStrategyStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6c">getTemplate (String): TradingSessionElementTemplateStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#6d">getTemplatesForSession (String): TradingSessionElementTemplateStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6e">getTotalPendingOrders (List, int): PendingOrderStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/100)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#6f">getTotalPendingReportOrders (List, int): PendingOrderReportStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/111)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#70">getTradingSessionByName (String): TradingSessionStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#71">getTradingSessionEventStatePublisher (): TradingSessionEventStateConsumer</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#72">getTradingSessionPublisher (): TradingSessionConsumer</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#73">getTradingSessionRegistrationNames (): TradingSessionRegistrationStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#74">getTradingSessionRoutingGroupNames (): TradingSessionGroupStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#75">getTradingSessions (): TradingSessionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#76">getTradingSessionsByTime (TimeStruct, TimeStruct): TradingSessionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#77">getTradingSessionsForClass (int): TradingSessionStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#78">getUnassignedClasses (String): ClassStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#79">initialize (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/365)</TD><TD CLASS="h">0%   (0/62)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7a">initializeCachesForOpening (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/173)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR><TD CLASS="f"><A HREF="#7b">instantiateProductStateChangeStrategy (String): ProductStateChangeStrategy</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/44)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7c">isBusinessDayCurrent (DateStruct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7d">isBusinessDayStarted (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7e">isHaltRequestAndPreOpenState (String, ClassStruct, short): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#7f">isMultiClassStrategyLegs (TradingSession, StrategyRequestStruct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/78)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#80">isPendingProduct (PendingAdjustmentStruct, int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#81">isSessionTriggeredByUnderlyingStateChange (String, short): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/71)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#82">isTimetoApply (PendingAdjustmentStruct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#83">isValidStrategyLegCount (StrategyRequestStruct): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#84">lockServiceForUpdates (String [], String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/84)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#85">lockServiceForUpdates (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#86">logErrors (String, ErrorCodeResultStruct []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/45)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#87">logMessage (String, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#88">logMessage (String, String, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#89">matchTradingSessionEventTypeByNumber (int): TradingSessionEventType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8a">modifyTradingSession (TradingSessionStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#8b">modifyTradingSessionElement (TradingSessionElementStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8c">modifyTradingSessionTemplate (TradingSessionElementTemplateStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/83)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR><TD CLASS="f"><A HREF="#8d">populatePriceAdjustment (PriceAdjustmentStruct): PriceAdjustmentStruct</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/76)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8e">priceAdjustmentsComplete (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#8f">priceAdjustmentsComplete (String [], String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#90">priceAdjustmentsCompleteForServers (String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#91">processProductStateChangeErrorResults (GroupErrorCodeResultStruct []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/67)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#92">processStateChangeForDerivative (ClassStruct, ProductStateStruct, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/307)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR><TD CLASS="f"><A HREF="#93">publishCurrentDay (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#94">publishEventState (String, short, String, short, Map): TradingSessionEventHis...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/117)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR><TD CLASS="f"><A HREF="#95">publishIncrementalEventState (TradingSessionEventHistoryEntry, String, short)...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/96)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#96">publishTradingSessionElementUpdate (TradingSessionElementStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#97">publishTradingSessionState (TradingSession): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/71)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#98">registerClient (String, TradingSessionClient): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#99">registerClientWithSessions (String [], String, TradingSessionClient, KeyValue...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/182)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9a">releaseUpdateLock (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9b">releaseUpdateLock (String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9c">removeListener (TradingSessionEventType, TradingSessionListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#9d">removeListener (TradingSessionListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9e">removeTradingSession (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#9f">removeTradingSessionElement (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a0">removeTradingSessionTemplate (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#a1">resetBusinessDayCache (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a2">serviceEstablished (String, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#a3">serviceLost (String, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a4">setCurrentDayState (short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#a5">setEndOfSessionStatus (String, TradingSessionEventType): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a6">setProductStatesForElement (TradingSessionElement, short, boolean): GroupErro...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#a7">setProductStatesForElement (int, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a8">setProductStatesForElement (int, short, boolean): GroupErrorCodeResultStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#a9">setProductStatesForElementV2 (int, short): GroupErrorCodeResultStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#aa">setProductStatesForSession (String, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#ab">setProductStatesForSessionForGroup (String, String, short): ErrorCodeResultSt...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/88)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ac">setProductStatesForSessionV2 (String, short): GroupErrorCodeResultStruct []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#ad">setSessionState (TradingSession, short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ae">startClearEndOfSales (String, String [], String [], boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/111)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#af">startClearEndOfSales (String, boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b0">startClearEndOfSalesForServers (String, boolean, boolean, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#b1">startEndOfDay (boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b2">startEndOfDay (boolean, boolean, String [], String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/79)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#b3">startEndOfDayForServers (boolean, boolean, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b4">startEndOfSales (String, String [], String [], boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/111)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#b5">startEndOfSales (String, boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b6">startEndOfSalesForServers (String, boolean, boolean, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#b7">startEndOfSession (String, boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b8">startEndOfSession (String, boolean, boolean, String [], String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/120)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR><TD CLASS="f"><A HREF="#b9">startEndOfSessionForServers (String, boolean, boolean, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ba">startPriceAdjustments (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#bb">startPriceAdjustmentsForServers (String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#bc">startSession (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#bd">startSession (String, String [], String [], boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/112)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#be">startSession (String, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#bf">startSessionForServers (String, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c0">startSessionForServers (String, String [], boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#c1">stopSession (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c2">validateServerNames (String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#c3">validateServerNamesWithSession (String, String []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c4">validateStrategy (String, StrategyRequestStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#c5">validateStrategyLegs (String, StrategyRequestStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/129)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c6">validateStrategySession (String, StrategyRequestStruct): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#c7">verifySessionName (String): TradingSession</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c8">verifyTemplateName (String): TradingSessionElementTemplate</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#c9">TradingSessionServiceLocalImpl$1</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/99)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#c9">TradingSessionServiceLocalImpl$1 (TradingSessionServiceLocalImpl, TradingSess...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#cb">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/81)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#cc">TradingSessionServiceLocalImpl$1EndOfDayThread</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/92)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#cc">TradingSessionServiceLocalImpl$1EndOfDayThread (TradingSessionServiceLocalImp...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ce">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#cf">TradingSessionServiceLocalImpl$1EndSessionThread</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/250)</TD><TD CLASS="h">0%   (0/40)</TD></TR><TR><TD CLASS="f"><A HREF="#cf">TradingSessionServiceLocalImpl$1EndSessionThread (TradingSessionServiceLocalI...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d1">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/229)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#d2">TradingSessionServiceLocalImpl$1StartClearEndOfSalesThread</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#d2">TradingSessionServiceLocalImpl$1StartClearEndOfSalesThread (TradingSessionSer...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d4">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#d5">TradingSessionServiceLocalImpl$1StartEndOfSalesThread</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#d5">TradingSessionServiceLocalImpl$1StartEndOfSalesThread (TradingSessionServiceL...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d7">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#d8">TradingSessionServiceLocalImpl$1StartSessionThread</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/257)</TD><TD CLASS="h">0%   (0/40)</TD></TR><TR><TD CLASS="f"><A HREF="#d8">TradingSessionServiceLocalImpl$1StartSessionThread (TradingSessionServiceLoca...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#da">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/239)</TD><TD CLASS="h">0%   (0/34)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#db">TradingSessionServiceLocalImpl$2</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/80)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#db">TradingSessionServiceLocalImpl$2 (TradingSessionServiceLocalImpl, BusinessDay...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#dd">run (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/8)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>package com.cboe.businessServices.tradingSessionService;</TD></TR><TR><TD CLASS="l">2</TD><TD> </TD></TR><TR><TD CLASS="l">3</TD><TD>// Java classes</TD></TR><TR><TD CLASS="l">4</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">5</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">6</TD><TD>import java.util.Collection;</TD></TR><TR><TD CLASS="l">7</TD><TD>import java.util.Collections;</TD></TR><TR><TD CLASS="l">8</TD><TD>import java.util.Date;</TD></TR><TR><TD CLASS="l">9</TD><TD>import java.util.Enumeration;</TD></TR><TR><TD CLASS="l">10</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">11</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">12</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">13</TD><TD>import java.util.LinkedList;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">15</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.util.StringTokenizer;</TD></TR><TR><TD CLASS="l">18</TD><TD>import java.util.Map.Entry;</TD></TR><TR><TD CLASS="l">19</TD><TD>import java.util.concurrent.ConcurrentHashMap;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.util.concurrent.ThreadPoolExecutor;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.util.concurrent.TimeUnit;</TD></TR><TR><TD CLASS="l">22</TD><TD> </TD></TR><TR><TD CLASS="l">23</TD><TD>import org.omg.CORBA.UserException;</TD></TR><TR><TD CLASS="l">24</TD><TD> </TD></TR><TR><TD CLASS="l">25</TD><TD>import com.cboe.businessServices.productService.StrategyBuilder;</TD></TR><TR><TD CLASS="l">26</TD><TD>import com.cboe.businessServices.tradingSessionService.sessionManagement.TradingSessionImpl;</TD></TR><TR><TD CLASS="l">27</TD><TD>import com.cboe.businessServices.tradingSessionService.sessionManagement.TradingSessionThreadPoolHomeImpl;</TD></TR><TR><TD CLASS="l">28</TD><TD>import com.cboe.businessServices.util.MultiClassStrategyUtils;</TD></TR><TR><TD CLASS="l">29</TD><TD>import com.cboe.domain.product.ProductImpl;</TD></TR><TR><TD CLASS="l">30</TD><TD>import com.cboe.domain.tradingProperty.RolloutFlagByBCGroup;</TD></TR><TR><TD CLASS="l">31</TD><TD>import com.cboe.domain.tradingProperty.TradingPropertyFactoryHome;</TD></TR><TR><TD CLASS="l">32</TD><TD>import com.cboe.domain.tradingProperty.TradingPropertyTypeImpl;</TD></TR><TR><TD CLASS="l">33</TD><TD>import com.cboe.domain.util.DateWrapper;</TD></TR><TR><TD CLASS="l">34</TD><TD>import com.cboe.domain.util.GroupContainer;</TD></TR><TR><TD CLASS="l">35</TD><TD>import com.cboe.domain.util.OrderStructBuilder;</TD></TR><TR><TD CLASS="l">36</TD><TD>import com.cboe.domain.util.ProductStrategyStructBuilder;</TD></TR><TR><TD CLASS="l">37</TD><TD>import com.cboe.domain.util.ProductStructBuilder;</TD></TR><TR><TD CLASS="l">38</TD><TD>import com.cboe.domain.util.SessionStrategyStructHelper;</TD></TR><TR><TD CLASS="l">39</TD><TD>import com.cboe.domain.util.StructBuilder;</TD></TR><TR><TD CLASS="l">40</TD><TD>import com.cboe.domain.util.TradingSessionNameHelper;</TD></TR><TR><TD CLASS="l">41</TD><TD>import com.cboe.domain.util.intMaps.ConcurrentIntHashMap;</TD></TR><TR><TD CLASS="l">42</TD><TD>import com.cboe.domain.util.intMaps.IntHashMap;</TD></TR><TR><TD CLASS="l">43</TD><TD>import com.cboe.exceptions.AlreadyExistsException;</TD></TR><TR><TD CLASS="l">44</TD><TD>import com.cboe.exceptions.AuthorizationException;</TD></TR><TR><TD CLASS="l">45</TD><TD>import com.cboe.exceptions.CommunicationException;</TD></TR><TR><TD CLASS="l">46</TD><TD>import com.cboe.exceptions.DataValidationException;</TD></TR><TR><TD CLASS="l">47</TD><TD>import com.cboe.exceptions.NotFoundException;</TD></TR><TR><TD CLASS="l">48</TD><TD>import com.cboe.exceptions.SystemException;</TD></TR><TR><TD CLASS="l">49</TD><TD>import com.cboe.exceptions.TransactionFailedException;</TD></TR><TR><TD CLASS="l">50</TD><TD>import com.cboe.idl.cmiConstants.ClassStates;</TD></TR><TR><TD CLASS="l">51</TD><TD>import com.cboe.idl.cmiConstants.ListingStates;</TD></TR><TR><TD CLASS="l">52</TD><TD>import com.cboe.idl.cmiConstants.PriceAdjustmentTypes;</TD></TR><TR><TD CLASS="l">53</TD><TD>import com.cboe.idl.cmiConstants.ProductStates;</TD></TR><TR><TD CLASS="l">54</TD><TD>import com.cboe.idl.cmiConstants.ProductTypes;</TD></TR><TR><TD CLASS="l">55</TD><TD>import com.cboe.idl.cmiConstants.SessionNameValues;</TD></TR><TR><TD CLASS="l">56</TD><TD>import com.cboe.idl.cmiConstants.StrategyTypes;</TD></TR><TR><TD CLASS="l">57</TD><TD>import com.cboe.idl.cmiConstants.TradingSessionStates;</TD></TR><TR><TD CLASS="l">58</TD><TD>import com.cboe.idl.cmiErrorCodes.DataValidationCodes;</TD></TR><TR><TD CLASS="l">59</TD><TD>import com.cboe.idl.cmiErrorCodes.TransactionFailedCodes;</TD></TR><TR><TD CLASS="l">60</TD><TD>import com.cboe.idl.cmiOrder.OrderStruct;</TD></TR><TR><TD CLASS="l">61</TD><TD>import com.cboe.idl.cmiOrder.PendingOrderStruct;</TD></TR><TR><TD CLASS="l">62</TD><TD>import com.cboe.idl.cmiProduct.ClassStruct;</TD></TR><TR><TD CLASS="l">63</TD><TD>import com.cboe.idl.cmiProduct.PendingAdjustmentStruct;</TD></TR><TR><TD CLASS="l">64</TD><TD>import com.cboe.idl.cmiProduct.PendingNameStruct;</TD></TR><TR><TD CLASS="l">65</TD><TD>import com.cboe.idl.cmiProduct.ProductKeysStruct;</TD></TR><TR><TD CLASS="l">66</TD><TD>import com.cboe.idl.cmiProduct.ProductNameStruct;</TD></TR><TR><TD CLASS="l">67</TD><TD>import com.cboe.idl.cmiProduct.ProductStruct;</TD></TR><TR><TD CLASS="l">68</TD><TD>import com.cboe.idl.cmiProduct.ProductTypeStruct;</TD></TR><TR><TD CLASS="l">69</TD><TD>import com.cboe.idl.cmiSession.ProductStateStruct;</TD></TR><TR><TD CLASS="l">70</TD><TD>import com.cboe.idl.cmiSession.SessionClassDetailStruct;</TD></TR><TR><TD CLASS="l">71</TD><TD>import com.cboe.idl.cmiSession.SessionClassStruct;</TD></TR><TR><TD CLASS="l">72</TD><TD>import com.cboe.idl.cmiSession.SessionProductStruct;</TD></TR><TR><TD CLASS="l">73</TD><TD>import com.cboe.idl.cmiSession.SessionStrategyStruct;</TD></TR><TR><TD CLASS="l">74</TD><TD>import com.cboe.idl.cmiSession.TradingSessionStateStruct;</TD></TR><TR><TD CLASS="l">75</TD><TD>import com.cboe.idl.cmiStrategy.StrategyLegDefinitionStruct;</TD></TR><TR><TD CLASS="l">76</TD><TD>import com.cboe.idl.cmiStrategy.StrategyLegStruct;</TD></TR><TR><TD CLASS="l">77</TD><TD>import com.cboe.idl.cmiStrategy.StrategyRequestStruct;</TD></TR><TR><TD CLASS="l">78</TD><TD>import com.cboe.idl.cmiStrategy.StrategyStruct;</TD></TR><TR><TD CLASS="l">79</TD><TD>import com.cboe.idl.cmiUtil.DateStruct;</TD></TR><TR><TD CLASS="l">80</TD><TD>import com.cboe.idl.cmiUtil.KeyValueStruct;</TD></TR><TR><TD CLASS="l">81</TD><TD>import com.cboe.idl.cmiUtil.TimeStruct;</TD></TR><TR><TD CLASS="l">82</TD><TD>import com.cboe.idl.constants.BusinessDayStates;</TD></TR><TR><TD CLASS="l">83</TD><TD>import com.cboe.idl.constants.TradingSessionEventStates;</TD></TR><TR><TD CLASS="l">84</TD><TD>import com.cboe.idl.internalBusinessServices.AMI_TradingSessionClientHandler;</TD></TR><TR><TD CLASS="l">85</TD><TD>import com.cboe.idl.internalBusinessServices.TradingSessionClient;</TD></TR><TR><TD CLASS="l">86</TD><TD>import com.cboe.idl.internalBusinessServices.TradingSessionClientHelper;</TD></TR><TR><TD CLASS="l">87</TD><TD>import com.cboe.idl.order.PendingOrderReportStruct;</TD></TR><TR><TD CLASS="l">88</TD><TD>import com.cboe.idl.product.ErrorCodeResultStruct;</TD></TR><TR><TD CLASS="l">89</TD><TD>import com.cboe.idl.product.GroupErrorCodeResultStruct;</TD></TR><TR><TD CLASS="l">90</TD><TD>import com.cboe.idl.product.GroupStruct;</TD></TR><TR><TD CLASS="l">91</TD><TD>import com.cboe.idl.product.PriceAdjustmentClassStruct;</TD></TR><TR><TD CLASS="l">92</TD><TD>import com.cboe.idl.product.PriceAdjustmentStruct;</TD></TR><TR><TD CLASS="l">93</TD><TD>import com.cboe.idl.product.ProductClassStruct;</TD></TR><TR><TD CLASS="l">94</TD><TD>import com.cboe.idl.session.BusinessDaySessionStruct;</TD></TR><TR><TD CLASS="l">95</TD><TD>import com.cboe.idl.session.BusinessDayStruct;</TD></TR><TR><TD CLASS="l">96</TD><TD>import com.cboe.idl.session.ClassStateDetailStruct;</TD></TR><TR><TD CLASS="l">97</TD><TD>import com.cboe.idl.session.TemplateClassStruct;</TD></TR><TR><TD CLASS="l">98</TD><TD>import com.cboe.idl.session.TradingSessionElementClassesDetailStruct;</TD></TR><TR><TD CLASS="l">99</TD><TD>import com.cboe.idl.session.TradingSessionElementInfoStruct;</TD></TR><TR><TD CLASS="l">100</TD><TD>import com.cboe.idl.session.TradingSessionElementStruct;</TD></TR><TR><TD CLASS="l">101</TD><TD>import com.cboe.idl.session.TradingSessionElementTemplateStruct;</TD></TR><TR><TD CLASS="l">102</TD><TD>import com.cboe.idl.session.TradingSessionEventHistoryStruct;</TD></TR><TR><TD CLASS="l">103</TD><TD>import com.cboe.idl.session.TradingSessionEventHistoryStructV2;</TD></TR><TR><TD CLASS="l">104</TD><TD>import com.cboe.idl.session.TradingSessionGroupStruct;</TD></TR><TR><TD CLASS="l">105</TD><TD>import com.cboe.idl.session.TradingSessionRegistrationStruct;</TD></TR><TR><TD CLASS="l">106</TD><TD>import com.cboe.idl.session.TradingSessionServerEventStateStruct;</TD></TR><TR><TD CLASS="l">107</TD><TD>import com.cboe.idl.session.TradingSessionStrategyDescriptionStruct;</TD></TR><TR><TD CLASS="l">108</TD><TD>import com.cboe.idl.session.TradingSessionStruct;</TD></TR><TR><TD CLASS="l">109</TD><TD>import com.cboe.infrastructureServices.foundationFramework.BOHome;</TD></TR><TR><TD CLASS="l">110</TD><TD>import com.cboe.infrastructureServices.foundationFramework.BObject;</TD></TR><TR><TD CLASS="l">111</TD><TD>import com.cboe.infrastructureServices.foundationFramework.FoundationFramework;</TD></TR><TR><TD CLASS="l">112</TD><TD>import com.cboe.infrastructureServices.foundationFramework.HomeFactory;</TD></TR><TR><TD CLASS="l">113</TD><TD>import com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException;</TD></TR><TR><TD CLASS="l">114</TD><TD>import com.cboe.infrastructureServices.foundationFramework.exceptionHandling.FatalFoundationFrameworkException;</TD></TR><TR><TD CLASS="l">115</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Configuration;</TD></TR><TR><TD CLASS="l">116</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Log;</TD></TR><TR><TD CLASS="l">117</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.RouteNameHelper;</TD></TR><TR><TD CLASS="l">118</TD><TD>import com.cboe.infrastructureServices.foundationFramework.utilities.Transaction;</TD></TR><TR><TD CLASS="l">119</TD><TD>import com.cboe.infrastructureServices.systemsManagementService.InappropriateValueException;</TD></TR><TR><TD CLASS="l">120</TD><TD>import com.cboe.infrastructureServices.systemsManagementService.NoSuchPropertyException;</TD></TR><TR><TD CLASS="l">121</TD><TD>import com.cboe.infrastructureServices.timeService.TimeService;</TD></TR><TR><TD CLASS="l">122</TD><TD>import com.cboe.infrastructureServices.traderService.DirectoryQueryResult;</TD></TR><TR><TD CLASS="l">123</TD><TD>import com.cboe.infrastructureServices.traderService.TraderService;</TD></TR><TR><TD CLASS="l">124</TD><TD>import com.cboe.interfaces.businessServices.OrderHandlingService;</TD></TR><TR><TD CLASS="l">125</TD><TD>import com.cboe.interfaces.businessServices.OrderHandlingServiceHome;</TD></TR><TR><TD CLASS="l">126</TD><TD>import com.cboe.interfaces.businessServices.ProductQueryService;</TD></TR><TR><TD CLASS="l">127</TD><TD>import com.cboe.interfaces.businessServices.ProductQueryServiceHome;</TD></TR><TR><TD CLASS="l">128</TD><TD>import com.cboe.interfaces.businessServices.TradingSessionEventGroupType;</TD></TR><TR><TD CLASS="l">129</TD><TD>import com.cboe.interfaces.businessServices.TradingSessionEventType;</TD></TR><TR><TD CLASS="l">130</TD><TD>import com.cboe.interfaces.businessServices.TradingSessionService;</TD></TR><TR><TD CLASS="l">131</TD><TD>import com.cboe.interfaces.businessServices.TradingSessionStrategyAssignmentStrategy;</TD></TR><TR><TD CLASS="l">132</TD><TD>import com.cboe.interfaces.domain.marketDataSummary.MarketDataSummaryHome;</TD></TR><TR><TD CLASS="l">133</TD><TD>import com.cboe.interfaces.domain.product.Product;</TD></TR><TR><TD CLASS="l">134</TD><TD>import com.cboe.interfaces.domain.product.ProductClass;</TD></TR><TR><TD CLASS="l">135</TD><TD>import com.cboe.interfaces.domain.product.ProductClassHome;</TD></TR><TR><TD CLASS="l">136</TD><TD>import com.cboe.interfaces.domain.product.ProductHome;</TD></TR><TR><TD CLASS="l">137</TD><TD>import com.cboe.interfaces.domain.session.BusinessDay;</TD></TR><TR><TD CLASS="l">138</TD><TD>import com.cboe.interfaces.domain.session.BusinessDayHome;</TD></TR><TR><TD CLASS="l">139</TD><TD>import com.cboe.interfaces.domain.session.SessionElementClass;</TD></TR><TR><TD CLASS="l">140</TD><TD>import com.cboe.interfaces.domain.session.SessionElementClassHome;</TD></TR><TR><TD CLASS="l">141</TD><TD>import com.cboe.interfaces.domain.session.SessionElementProduct;</TD></TR><TR><TD CLASS="l">142</TD><TD>import com.cboe.interfaces.domain.session.TemplateClass;</TD></TR><TR><TD CLASS="l">143</TD><TD>import com.cboe.interfaces.domain.session.TemplateClassHome;</TD></TR><TR><TD CLASS="l">144</TD><TD>import com.cboe.interfaces.domain.session.TradingSession;</TD></TR><TR><TD CLASS="l">145</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionElement;</TD></TR><TR><TD CLASS="l">146</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionElementHome;</TD></TR><TR><TD CLASS="l">147</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionElementTemplate;</TD></TR><TR><TD CLASS="l">148</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionElementTemplateHome;</TD></TR><TR><TD CLASS="l">149</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionEventHistoryDetail;</TD></TR><TR><TD CLASS="l">150</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionEventHistoryEntry;</TD></TR><TR><TD CLASS="l">151</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionEventHistoryHome;</TD></TR><TR><TD CLASS="l">152</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionHome;</TD></TR><TR><TD CLASS="l">153</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionRegistrationMapHome;</TD></TR><TR><TD CLASS="l">154</TD><TD>import com.cboe.interfaces.domain.session.TradingSessionThreadPoolHome;</TD></TR><TR><TD CLASS="l">155</TD><TD>import com.cboe.interfaces.domain.tradingProperty.RolloutFlagByBC;</TD></TR><TR><TD CLASS="l">156</TD><TD>import com.cboe.interfaces.events.TradingSessionConsumer;</TD></TR><TR><TD CLASS="l">157</TD><TD>import com.cboe.interfaces.events.TradingSessionEventStateConsumer;</TD></TR><TR><TD CLASS="l">158</TD><TD>import com.cboe.interfaces.internalBusinessServices.ProductConfigurationService;</TD></TR><TR><TD CLASS="l">159</TD><TD>import com.cboe.interfaces.internalBusinessServices.ProductConfigurationServiceHome;</TD></TR><TR><TD CLASS="l">160</TD><TD>import com.cboe.interfaces.internalBusinessServices.ProductMaintenanceService;</TD></TR><TR><TD CLASS="l">161</TD><TD>import com.cboe.interfaces.internalBusinessServices.ProductMaintenanceServiceHome;</TD></TR><TR><TD CLASS="l">162</TD><TD>import com.cboe.interfaces.internalBusinessServices.ProductStateService;</TD></TR><TR><TD CLASS="l">163</TD><TD>import com.cboe.interfaces.internalBusinessServices.TradingSessionListener;</TD></TR><TR><TD CLASS="l">164</TD><TD>import com.cboe.internalBusinessServices.productService.ValidateProduct;</TD></TR><TR><TD CLASS="l">165</TD><TD>import com.cboe.internalBusinessServices.tradingSessionService.TradingSessionClientAMICallback;</TD></TR><TR><TD CLASS="l">166</TD><TD>import com.cboe.server.events.EventHomes;</TD></TR><TR><TD CLASS="l">167</TD><TD>import com.cboe.server.util.InternalBusinessServicesHelper;</TD></TR><TR><TD CLASS="l">168</TD><TD>import com.cboe.server.util.LockManager;</TD></TR><TR><TD CLASS="l">169</TD><TD>import com.cboe.server.util.LockManagerException;</TD></TR><TR><TD CLASS="l">170</TD><TD>import com.cboe.server.util.ObjectResolver;</TD></TR><TR><TD CLASS="l">171</TD><TD>import com.cboe.server.util.TimeHelper;</TD></TR><TR><TD CLASS="l">172</TD><TD>import com.cboe.server.util.TradingSessionClientImpl;</TD></TR><TR><TD CLASS="l">173</TD><TD>import com.cboe.util.ExceptionBuilder;</TD></TR><TR><TD CLASS="l">174</TD><TD> </TD></TR><TR><TD CLASS="l">175</TD><TD> </TD></TR><TR><TD CLASS="l">176</TD><TD>/**</TD></TR><TR><TD CLASS="l">177</TD><TD> * Base implementation of the TradingSessionService.  This service is</TD></TR><TR><TD CLASS="l">178</TD><TD> * used to perform session-scope operations on services &amp; products in the</TD></TR><TR><TD CLASS="l">179</TD><TD> * SBT.  All public methods, ex startSession(int), cause invocations of all</TD></TR><TR><TD CLASS="l">180</TD><TD> * known TradingSessionClient objects.</TD></TR><TR><TD CLASS="l">181</TD><TD> *</TD></TR><TR><TD CLASS="l">182</TD><TD> * &lt;p&gt;This class is principally a coordinator</TD></TR><TR><TD CLASS="l">183</TD><TD> * to synchronize client actions: it inforces rules such as &#34;all clients must finish</TD></TR><TR><TD CLASS="l">184</TD><TD> * step X before any clients proceed to step Y&#34;.</TD></TR><TR><TD CLASS="l">185</TD><TD> *</TD></TR><TR><TD CLASS="l">186</TD><TD> * &lt;p&gt;Clients are distributed on a per-process basis, while there is a single global</TD></TR><TR><TD CLASS="l">187</TD><TD> * instance of this class.</TD></TR><TR><TD CLASS="l">188</TD><TD> *</TD></TR><TR><TD CLASS="l">189</TD><TD> * @author Steven Sinclair</TD></TR><TR><TD CLASS="l">190</TD><TD> * @author Ravi Vazirani -- fixes to original code.</TD></TR><TR><TD CLASS="l">191</TD><TD> * @author Rizwan Ebrahim  Changed setProductStatesForElement to use configured strategies</TD></TR><TR><TD CLASS="l">192</TD><TD> * @author pyatetsk - If strategy is failed to be added to any session, the newly created</TD></TR><TR><TD CLASS="l">193</TD><TD> *                    Strategy product gets its state set to INACTIVE. So it would not effect openning of the</TD></TR><TR><TD CLASS="l"><A NAME="0">194</A></TD><TD> *                    class on the next Business day.</TD></TR><TR><TD CLASS="l">195</TD><TD> * @author Gijo Joseph</TD></TR><TR><TD CLASS="l">196</TD><TD> * @date   9/2010 - change to allow creation of strategies with with different leg classes. </TD></TR><TR><TD CLASS="l">197</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>public class TradingSessionServiceLocalImpl</TD></TR><TR><TD CLASS="l">199</TD><TD>    extends</TD></TR><TR><TD CLASS="l">200</TD><TD>        BObject</TD></TR><TR><TD CLASS="l">201</TD><TD>    implements</TD></TR><TR><TD CLASS="l">202</TD><TD>        com.cboe.interfaces.internalBusinessServices.TradingSessionServiceLocal,</TD></TR><TR><TD CLASS="l">203</TD><TD>        com.cboe.interfaces.businessServices.TradingSessionMaintenanceService,</TD></TR><TR><TD CLASS="l">204</TD><TD>        TradingSessionEventStatePublisher</TD></TR><TR><TD CLASS="l">205</TD><TD>{</TD></TR><TR><TD CLASS="l">206</TD><TD> </TD></TR><TR><TD CLASS="l">207</TD><TD>        // INSTANCE VARIABLES.</TD></TR><TR><TD CLASS="l">208</TD><TD> </TD></TR><TR><TD CLASS="l">209</TD><TD>    /**</TD></TR><TR><TD CLASS="l">210</TD><TD>     *  Number of Groups a class can be exist into.</TD></TR><TR><TD CLASS="l">211</TD><TD>     */</TD></TR><TR><TD CLASS="l">212</TD><TD>    private final static int DEFAULT_GROUP_SIZE=32;</TD></TR><TR><TD CLASS="l">213</TD><TD> </TD></TR><TR><TD CLASS="l">214</TD><TD>    /**</TD></TR><TR><TD CLASS="l">215</TD><TD>     *  Total number of Groups in System (Currently, its 99)</TD></TR><TR><TD CLASS="l">216</TD><TD>     */</TD></TR><TR><TD CLASS="l">217</TD><TD>    private final static int GROUP_SIZE=128;</TD></TR><TR><TD CLASS="l">218</TD><TD> </TD></TR><TR><TD CLASS="l">219</TD><TD>   /**</TD></TR><TR><TD CLASS="l">220</TD><TD>    *  All commands (&#34;admin requests&#34;) for this impl</TD></TR><TR><TD CLASS="l">221</TD><TD>    */</TD></TR><TR><TD CLASS="l">222</TD><TD>   private TradingSessionServiceCommands commands;</TD></TR><TR><TD CLASS="l">223</TD><TD> </TD></TR><TR><TD CLASS="l">224</TD><TD>   /**</TD></TR><TR><TD CLASS="l">225</TD><TD>        * If true then trader query for clients is done using</TD></TR><TR><TD CLASS="l">226</TD><TD>        * the remote route name otherwise the query is done</TD></TR><TR><TD CLASS="l">227</TD><TD>        * for all clients.</TD></TR><TR><TD CLASS="l">228</TD><TD>        */</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>        private boolean useRemoteRouteNameForClients = false;</TD></TR><TR><TD CLASS="l">230</TD><TD> </TD></TR><TR><TD CLASS="l">231</TD><TD>    /**</TD></TR><TR><TD CLASS="l">232</TD><TD>     * If true, then product state timer triggers and underlying ticks will</TD></TR><TR><TD CLASS="l">233</TD><TD>     * be ignored if the given product class is currently suspended.</TD></TR><TR><TD CLASS="l">234</TD><TD>     * This value is normally expected to be 'true'.</TD></TR><TR><TD CLASS="l">235</TD><TD>     */</TD></TR><TR><TD CLASS="l">236</TD><TD>    protected boolean blockAutoTransitionFromSuspended;</TD></TR><TR><TD CLASS="l">237</TD><TD> </TD></TR><TR><TD CLASS="l">238</TD><TD>   /**</TD></TR><TR><TD CLASS="l">239</TD><TD>        * List of sessions that will automatically trigger</TD></TR><TR><TD CLASS="l">240</TD><TD>        * product state changes if the underlying product</TD></TR><TR><TD CLASS="l">241</TD><TD>        * changes its state to HALT. Loaded from configuration.</TD></TR><TR><TD CLASS="l">242</TD><TD>        */</TD></TR><TR><TD CLASS="l">243</TD><TD>    private String[] underlyingStateHaltTriggeredSessions;</TD></TR><TR><TD CLASS="l">244</TD><TD> </TD></TR><TR><TD CLASS="l">245</TD><TD>    /**</TD></TR><TR><TD CLASS="l">246</TD><TD>     * List of sessions that will automatically trigger</TD></TR><TR><TD CLASS="l">247</TD><TD>     * product state change OPEN if the underlying product</TD></TR><TR><TD CLASS="l">248</TD><TD>     * changes its state. Loaded from configuration.</TD></TR><TR><TD CLASS="l">249</TD><TD>     */</TD></TR><TR><TD CLASS="l">250</TD><TD>     private String[] underlyingStateOpenTriggeredSessions;</TD></TR><TR><TD CLASS="l">251</TD><TD>     </TD></TR><TR><TD CLASS="l">252</TD><TD>     /**</TD></TR><TR><TD CLASS="l">253</TD><TD>      * List of STOCK sessions that will automatically trigger</TD></TR><TR><TD CLASS="l">254</TD><TD>      * product state change HALT if the underlying product</TD></TR><TR><TD CLASS="l">255</TD><TD>      * changes its state. Loaded from configuration.</TD></TR><TR><TD CLASS="l">256</TD><TD>      */</TD></TR><TR><TD CLASS="l">257</TD><TD>      private String[] underlyingStateHaltTriggeredSTOCKSessions;</TD></TR><TR><TD CLASS="l">258</TD><TD>     </TD></TR><TR><TD CLASS="l">259</TD><TD>   /**</TD></TR><TR><TD CLASS="l">260</TD><TD>        * Assume's the whole system is running in one process.</TD></TR><TR><TD CLASS="l">261</TD><TD>        */</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>        private boolean useAsLocalImpl = false;</TD></TR><TR><TD CLASS="l">263</TD><TD> </TD></TR><TR><TD CLASS="l">264</TD><TD>   /**</TD></TR><TR><TD CLASS="l">265</TD><TD>        * Timer for AMI.</TD></TR><TR><TD CLASS="l">266</TD><TD>        */</TD></TR><TR><TD CLASS="l">267</TD><TD>        private int amiCallbackTimerValue;</TD></TR><TR><TD CLASS="l">268</TD><TD> </TD></TR><TR><TD CLASS="l">269</TD><TD>   /**</TD></TR><TR><TD CLASS="l">270</TD><TD>        * The event channel for publishing event states.</TD></TR><TR><TD CLASS="l">271</TD><TD>        */</TD></TR><TR><TD CLASS="l">272</TD><TD>        protected TradingSessionConsumer tradingSessionPublisher;</TD></TR><TR><TD CLASS="l">273</TD><TD> </TD></TR><TR><TD CLASS="l">274</TD><TD>   /**</TD></TR><TR><TD CLASS="l">275</TD><TD>        * The event channel for publishing event state changes.</TD></TR><TR><TD CLASS="l">276</TD><TD>        */</TD></TR><TR><TD CLASS="l">277</TD><TD>        protected TradingSessionEventStateConsumer tradingSessionEventStatePublisher;</TD></TR><TR><TD CLASS="l">278</TD><TD> </TD></TR><TR><TD CLASS="l">279</TD><TD>   /**</TD></TR><TR><TD CLASS="l">280</TD><TD>        * The object which will manage lost services</TD></TR><TR><TD CLASS="l">281</TD><TD>        */</TD></TR><TR><TD CLASS="l">282</TD><TD>        protected ServiceRecoveryManager serviceRecoveryManager;</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR><TD CLASS="l">284</TD><TD>    /**</TD></TR><TR><TD CLASS="l">285</TD><TD>     * Cached reference to the ProductQueryService</TD></TR><TR><TD CLASS="l">286</TD><TD>     */</TD></TR><TR><TD CLASS="l">287</TD><TD>    private ProductQueryService productQueryService;</TD></TR><TR><TD CLASS="l">288</TD><TD> </TD></TR><TR><TD CLASS="l">289</TD><TD>    /**</TD></TR><TR><TD CLASS="l">290</TD><TD>     * Cached reference to the ProductConfigurationService</TD></TR><TR><TD CLASS="l">291</TD><TD>     */</TD></TR><TR><TD CLASS="l">292</TD><TD>    private ProductConfigurationService productConfigurationService;</TD></TR><TR><TD CLASS="l">293</TD><TD> </TD></TR><TR><TD CLASS="l">294</TD><TD> </TD></TR><TR><TD CLASS="l">295</TD><TD>   /**</TD></TR><TR><TD CLASS="l">296</TD><TD>        * The object which will manage trading session templates.</TD></TR><TR><TD CLASS="l">297</TD><TD>        */</TD></TR><TR><TD CLASS="l">298</TD><TD>        protected TradingSessionElementTemplateHome templateHome;</TD></TR><TR><TD CLASS="l">299</TD><TD> </TD></TR><TR><TD CLASS="l">300</TD><TD>   /**</TD></TR><TR><TD CLASS="l">301</TD><TD>        * The object which will manage template class assignments.</TD></TR><TR><TD CLASS="l">302</TD><TD>        */</TD></TR><TR><TD CLASS="l">303</TD><TD>        protected TemplateClassHome templateClassHome;</TD></TR><TR><TD CLASS="l">304</TD><TD> </TD></TR><TR><TD CLASS="l">305</TD><TD>   /**</TD></TR><TR><TD CLASS="l">306</TD><TD>        * The object which will manage</TD></TR><TR><TD CLASS="l">307</TD><TD>        */</TD></TR><TR><TD CLASS="l">308</TD><TD>        protected TradingSessionElementHome elementHome;</TD></TR><TR><TD CLASS="l">309</TD><TD> </TD></TR><TR><TD CLASS="l">310</TD><TD>   /**</TD></TR><TR><TD CLASS="l">311</TD><TD>        * The object which will manage session element class assignments.</TD></TR><TR><TD CLASS="l">312</TD><TD>        */</TD></TR><TR><TD CLASS="l">313</TD><TD>        protected SessionElementClassHome elementClassHome;</TD></TR><TR><TD CLASS="l">314</TD><TD> </TD></TR><TR><TD CLASS="l">315</TD><TD>   /**</TD></TR><TR><TD CLASS="l">316</TD><TD>        * The local TradingSessionService client. All listeners</TD></TR><TR><TD CLASS="l">317</TD><TD>        * register with this local client.</TD></TR><TR><TD CLASS="l">318</TD><TD>        */</TD></TR><TR><TD CLASS="l">319</TD><TD>        protected TradingSessionClientImpl localClientInstance;</TD></TR><TR><TD CLASS="l">320</TD><TD> </TD></TR><TR><TD CLASS="l">321</TD><TD>   /**</TD></TR><TR><TD CLASS="l">322</TD><TD>        * End of business daya strategy impl (singleton).</TD></TR><TR><TD CLASS="l">323</TD><TD>        */</TD></TR><TR><TD CLASS="l">324</TD><TD>        protected TradingSessionEOBDStrategy eobdStrategy;</TD></TR><TR><TD CLASS="l">325</TD><TD> </TD></TR><TR><TD CLASS="l">326</TD><TD>   /**</TD></TR><TR><TD CLASS="l">327</TD><TD>        * The POA tie'd object.</TD></TR><TR><TD CLASS="l">328</TD><TD>        */</TD></TR><TR><TD CLASS="l">329</TD><TD>        protected org.omg.PortableServer.Servant tie;</TD></TR><TR><TD CLASS="l">330</TD><TD> </TD></TR><TR><TD CLASS="l">331</TD><TD>   /**</TD></TR><TR><TD CLASS="l">332</TD><TD>        * Service used for queuing timers.</TD></TR><TR><TD CLASS="l">333</TD><TD>        */</TD></TR><TR><TD CLASS="l">334</TD><TD>        protected TimeService timerService;</TD></TR><TR><TD CLASS="l">335</TD><TD> </TD></TR><TR><TD CLASS="l">336</TD><TD>   /**</TD></TR><TR><TD CLASS="l">337</TD><TD>        * End of day strategy factory.</TD></TR><TR><TD CLASS="l">338</TD><TD>        */</TD></TR><TR><TD CLASS="l">339</TD><TD>        protected TradingSessionStrategyFactory strategyFactory;</TD></TR><TR><TD CLASS="l">340</TD><TD> </TD></TR><TR><TD CLASS="l">341</TD><TD>   /**</TD></TR><TR><TD CLASS="l">342</TD><TD>        * Business day home home.</TD></TR><TR><TD CLASS="l">343</TD><TD>        */</TD></TR><TR><TD CLASS="l">344</TD><TD>        protected BusinessDayHome businessDayHome;</TD></TR><TR><TD CLASS="l">345</TD><TD> </TD></TR><TR><TD CLASS="l">346</TD><TD>   /**</TD></TR><TR><TD CLASS="l">347</TD><TD>        * Trading Session group home.</TD></TR><TR><TD CLASS="l">348</TD><TD>        */</TD></TR><TR><TD CLASS="l">349</TD><TD>        protected TradingSessionHome sessionHome;</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR><TD CLASS="l">351</TD><TD>    /**</TD></TR><TR><TD CLASS="l">352</TD><TD>     * Event history entry home</TD></TR><TR><TD CLASS="l">353</TD><TD>     */</TD></TR><TR><TD CLASS="l">354</TD><TD>    protected TradingSessionEventHistoryHome eventHistoryHome;</TD></TR><TR><TD CLASS="l">355</TD><TD> </TD></TR><TR><TD CLASS="l">356</TD><TD>    /**</TD></TR><TR><TD CLASS="l">357</TD><TD>     * Maintain Mutex-like locks for registered clients and for the service in general.</TD></TR><TR><TD CLASS="l">358</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>    protected LockManager lockManager = new LockManager(&#34;TSSLockMgr&#34;);</TD></TR><TR><TD CLASS="l">360</TD><TD> </TD></TR><TR><TD CLASS="l">361</TD><TD>    /**</TD></TR><TR><TD CLASS="l">362</TD><TD>     *  Property groupTypeForProductState set into XML configuration (Currently, as 2 == Trade Server)</TD></TR><TR><TD CLASS="l">363</TD><TD>     *  Useful to filter out TRADE SERVERS only out of all PCS Groups</TD></TR><TR><TD CLASS="l">364</TD><TD>     */</TD></TR><TR><TD CLASS="l">365</TD><TD>    private int groupTypeForProductState;</TD></TR><TR><TD CLASS="l">366</TD><TD> </TD></TR><TR><TD CLASS="l">367</TD><TD>    /**</TD></TR><TR><TD CLASS="l">368</TD><TD>     *  instance of product class home</TD></TR><TR><TD CLASS="l">369</TD><TD>     */</TD></TR><TR><TD CLASS="l">370</TD><TD>    private static ProductClassHome productClassHome;</TD></TR><TR><TD CLASS="l"><A NAME="1">371</A></TD><TD> </TD></TR><TR><TD CLASS="l">372</TD><TD>    /**</TD></TR><TR><TD CLASS="l">373</TD><TD>     *  Empty Array of GroupErrorCodeResultStruct</TD></TR><TR><TD CLASS="l">374</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>    private final static GroupErrorCodeResultStruct[] EMPTY_GroupErrorCodeResultStruct = new GroupErrorCodeResultStruct[0];</TD></TR><TR><TD CLASS="l">376</TD><TD> </TD></TR><TR><TD CLASS="l">377</TD><TD>    /**</TD></TR><TR><TD CLASS="l">378</TD><TD>     *  To avoid initializationEveryTime (as before), this instance been created</TD></TR><TR><TD CLASS="l">379</TD><TD>     *  Admin service uses different implementation</TD></TR><TR><TD CLASS="l">380</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>    private ProductStateChangeStrategy nonAdminProductStateImplementation = null;</TD></TR><TR><TD CLASS="l">382</TD><TD> </TD></TR><TR><TD CLASS="l">383</TD><TD>    protected String productStateImpl;</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>    protected final String PRODUCT_STATE_CHANGE_IMPL = &#34;productStateChangeStrategy&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>    protected final String ORIGINAL_PRODUCT_STATE_CHANGE_IMPL =&#34;com.cboe.businessServices.tradingSessionService.OriginalProductStateChangeStrategyImpl&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>    protected final String NEW_PRODUCT_STATE_CHANGE_IMPL =&#34;com.cboe.businessServices.tradingSessionService.NewProductStateChangeStrategyImpl&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>    protected final String DOUBLE_PUBLISH_HISTORY_EVENT = &#34;doublePublishHistoryEvent&#34;;</TD></TR><TR><TD CLASS="l">388</TD><TD>    protected TradingSessionRegistrationMapHome registrationMapHome;</TD></TR><TR><TD CLASS="l">389</TD><TD> </TD></TR><TR><TD CLASS="l">390</TD><TD>    //boolean to indicate whether double publish for trading session event history is needed.</TD></TR><TR><TD CLASS="l">391</TD><TD>    protected boolean doublePublishSessionEventHistory;</TD></TR><TR><TD CLASS="l">392</TD><TD>    protected boolean includeReportingClassesInBusinessDayStruct;</TD></TR><TR><TD CLASS="l">393</TD><TD>    protected boolean startSessionAbortOnError;</TD></TR><TR><TD CLASS="l">394</TD><TD>    protected boolean endOfDayPurgeAbortOnError;</TD></TR><TR><TD CLASS="l">395</TD><TD> </TD></TR><TR><TD CLASS="l">396</TD><TD>    /**</TD></TR><TR><TD CLASS="l">397</TD><TD>     * A reference to the home for products.</TD></TR><TR><TD CLASS="l">398</TD><TD>     */</TD></TR><TR><TD CLASS="l">399</TD><TD>    private ProductHome productHome;</TD></TR><TR><TD CLASS="l">400</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>    private final Object cachedBusinessDaySessionsSynchObj = new Object();</TD></TR><TR><TD CLASS="l">402</TD><TD>    private BusinessDaySessionStruct[] cachedBusinessDaySessions;</TD></TR><TR><TD CLASS="l">403</TD><TD>    private Map sessionsByClass; // Map&lt;Integer,List&lt;String&gt;&gt;</TD></TR><TR><TD CLASS="l">404</TD><TD>    private Map derivativesByUnderlying; // Map&lt;Integer,List&lt;ClassStruct&gt;&gt;</TD></TR><TR><TD CLASS="l">405</TD><TD> </TD></TR><TR><TD CLASS="l">406</TD><TD>    /**</TD></TR><TR><TD CLASS="l">407</TD><TD>     * Used to check the status of all the sessions.</TD></TR><TR><TD CLASS="l">408</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>    private static volatile Boolean sessionClosedFlag = null;</TD></TR><TR><TD CLASS="l">410</TD><TD> </TD></TR><TR><TD CLASS="l">411</TD><TD>    /**</TD></TR><TR><TD CLASS="l">412</TD><TD>     * A reference to the Market Data Summary Home</TD></TR><TR><TD CLASS="l">413</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">414</TD><TD>    private MarketDataSummaryHome marketDataSummaryHome = null;</TD></TR><TR><TD CLASS="l">415</TD><TD>    </TD></TR><TR><TD CLASS="l">416</TD><TD>    private OrderHandlingService orderHandlingService;</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR><TD CLASS="l">418</TD><TD>    private ProductMaintenanceService productMaintenanceService;</TD></TR><TR><TD CLASS="l">419</TD><TD> </TD></TR><TR><TD CLASS="l">420</TD><TD>    private static final int DAYS_TO_SETTLEMENT = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>    private static int[] DAY_TYPE_MASK = new int[]{ com.cboe.infraUtil.DayTypesOperations.WEEKEND,</TD></TR><TR><TD CLASS="l">422</TD><TD>                                                    com.cboe.infraUtil.DayTypesOperations.NONSETTLEMENTDAY,</TD></TR><TR><TD CLASS="l">423</TD><TD>                                                    com.cboe.infraUtil.DayTypesOperations.HOLIDAY </TD></TR><TR><TD CLASS="l">424</TD><TD>                                                  };</TD></TR><TR><TD CLASS="l">425</TD><TD>    </TD></TR><TR><TD CLASS="l">426</TD><TD>    private PendingAdjustedmentOrdersLogger adjustedOrdersLogger;</TD></TR><TR><TD CLASS="l">427</TD><TD> </TD></TR><TR><TD CLASS="l">428</TD><TD>    /* */</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>        private ConcurrentHashMap&lt;String, Object&gt; sessionLockMap = new ConcurrentHashMap&lt;String, Object&gt;();</TD></TR><TR><TD CLASS="l">430</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>        private ConcurrentHashMap&lt;String,HashMap&lt;TradingSessionElementInfoStruct,IntHashMap&lt;SessionClassDetailStruct&gt;&gt;&gt; sessionClassCache = new ConcurrentHashMap&lt;String,HashMap&lt;TradingSessionElementInfoStruct,IntHashMap&lt;SessionClassDetailStruct&gt;&gt;&gt;();</TD></TR><TR><TD CLASS="l">432</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>        private ConcurrentIntHashMap&lt;SessionClassDetailStruct[]&gt; elementCache = new ConcurrentIntHashMap&lt;SessionClassDetailStruct[]&gt; ();</TD></TR><TR><TD CLASS="l">434</TD><TD>        </TD></TR><TR><TD CLASS="l">435</TD><TD>        private static final String ENABLE_ORDER_CANCELLING_AT_CLASSLEVEL = &#34;enableOrderCancellingAtClassLevel&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>        private static boolean enabledOrderCancelling = false;</TD></TR><TR><TD CLASS="l">437</TD><TD>        </TD></TR><TR><TD CLASS="l">438</TD><TD>        private static final String QUICK_START_SESSION_FLAG = &#34;startSessionQuickFlag&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>        private static boolean startSessionQuickFlag = false;</TD></TR><TR><TD CLASS="l">440</TD><TD> </TD></TR><TR><TD CLASS="l">441</TD><TD>        private static final String PARALLEL_CREATE_BUS_DAY = &#34;parallelCreateBusDayFlag&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">442</TD><TD>        private static boolean parallelCreateBusDayFlag = false;</TD></TR><TR><TD CLASS="l">443</TD><TD>        </TD></TR><TR><TD CLASS="l">444</TD><TD>        static</TD></TR><TR><TD CLASS="l">445</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>        String toCnclOrder = System.getProperty(ENABLE_ORDER_CANCELLING_AT_CLASSLEVEL);</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>        if(toCnclOrder !=null &amp;&amp; toCnclOrder.equalsIgnoreCase(&#34;true&#34;))</TD></TR><TR><TD CLASS="l">448</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>            enabledOrderCancelling = true;</TD></TR><TR><TD CLASS="l">450</TD><TD>        }</TD></TR><TR><TD CLASS="l">451</TD><TD>        else</TD></TR><TR><TD CLASS="l">452</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>            enabledOrderCancelling = false;</TD></TR><TR><TD CLASS="l">454</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>        Log.information(&#34;enableOrderCancellingAtClassLevel configured: &#34; + enabledOrderCancelling);</TD></TR><TR><TD CLASS="l">456</TD><TD>    }        </TD></TR><TR><TD CLASS="l">457</TD><TD>        </TD></TR><TR><TD CLASS="l">458</TD><TD>         static</TD></TR><TR><TD CLASS="l">459</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                String toQuickStartSession = System.getProperty(QUICK_START_SESSION_FLAG);</TD></TR><TR CLASS="z"><TD CLASS="l">461</TD><TD>                Log.information(&#34;toQuickStartSession Value: &#34; + toQuickStartSession);</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                if(toQuickStartSession !=null &amp;&amp; toQuickStartSession.equalsIgnoreCase(&#34;true&#34;))</TD></TR><TR><TD CLASS="l">463</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                    startSessionQuickFlag = true;</TD></TR><TR><TD CLASS="l">465</TD><TD>                }</TD></TR><TR><TD CLASS="l">466</TD><TD>                else</TD></TR><TR><TD CLASS="l">467</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                    startSessionQuickFlag = false;</TD></TR><TR><TD CLASS="l">469</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>                Log.information(&#34;startSessionQuickFlag configured: &#34; + startSessionQuickFlag);</TD></TR><TR><TD CLASS="l">471</TD><TD>      }</TD></TR><TR><TD CLASS="l">472</TD><TD>        </TD></TR><TR><TD CLASS="l">473</TD><TD>         static</TD></TR><TR><TD CLASS="l">474</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>                String parallelCreateBusDay = System.getProperty(PARALLEL_CREATE_BUS_DAY);</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                Log.information(&#34;Parallel create bus day flag: &#34; + parallelCreateBusDay);</TD></TR><TR CLASS="z"><TD CLASS="l">477</TD><TD>                if(parallelCreateBusDay !=null &amp;&amp; parallelCreateBusDay.equalsIgnoreCase(&#34;true&#34;))</TD></TR><TR><TD CLASS="l">478</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>                    parallelCreateBusDayFlag = true;</TD></TR><TR><TD CLASS="l">480</TD><TD>                }</TD></TR><TR><TD CLASS="l">481</TD><TD>                else</TD></TR><TR><TD CLASS="l">482</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                    parallelCreateBusDayFlag = false;</TD></TR><TR><TD CLASS="l">484</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                Log.information(&#34;Parallel create bus day flag configured: &#34; + parallelCreateBusDayFlag);</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>      }</TD></TR><TR><TD CLASS="l"><A NAME="7d">487</A></TD><TD>        </TD></TR><TR><TD CLASS="l">488</TD><TD>         </TD></TR><TR><TD CLASS="l">489</TD><TD>    public boolean isBusinessDayStarted()</TD></TR><TR><TD CLASS="l">490</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>        return getBusinessDayHome().findCurrent().getState() == BusinessDayStates.STARTED;</TD></TR><TR><TD CLASS="l">492</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="7c">493</A></TD><TD> </TD></TR><TR><TD CLASS="l">494</TD><TD>    public boolean isBusinessDayCurrent(DateStruct dateIn)</TD></TR><TR><TD CLASS="l">495</TD><TD>            throws CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">496</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>        DateStruct currentDay = DateWrapper.convertToDate(getBusinessDayHome().findCurrent().getDate().getTime());</TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>        return currentDay.day == dateIn.day &amp;&amp; currentDay.month == dateIn.month &amp;&amp; currentDay.year == dateIn.year;</TD></TR><TR><TD CLASS="l">499</TD><TD>    }</TD></TR><TR><TD CLASS="l">500</TD><TD> </TD></TR><TR><TD CLASS="l">501</TD><TD>    /**</TD></TR><TR><TD CLASS="l">502</TD><TD>     * &#34;Throw away&#34; the cached business day information.</TD></TR><TR><TD CLASS="l"><A NAME="a1">503</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">504</TD><TD>     */</TD></TR><TR><TD CLASS="l">505</TD><TD>    public void resetBusinessDayCache()</TD></TR><TR><TD CLASS="l">506</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>        synchronized (cachedBusinessDaySessionsSynchObj)</TD></TR><TR><TD CLASS="l">508</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>            this.cachedBusinessDaySessions = null;</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>    }</TD></TR><TR><TD CLASS="l">512</TD><TD> </TD></TR><TR><TD CLASS="l">513</TD><TD>    /**</TD></TR><TR><TD CLASS="l">514</TD><TD>     * Initialize the quick-lookup maps needed for faster opening processing.</TD></TR><TR><TD CLASS="l">515</TD><TD>     *</TD></TR><TR><TD CLASS="l">516</TD><TD>     * @throws UserException</TD></TR><TR><TD CLASS="l">517</TD><TD>     */</TD></TR><TR><TD CLASS="l">518</TD><TD>    public void initializeCachesForOpening() throws UserException</TD></TR><TR><TD CLASS="l">519</TD><TD>    {</TD></TR><TR><TD CLASS="l">520</TD><TD>        // Implementation notes:</TD></TR><TR><TD CLASS="l">521</TD><TD>        //</TD></TR><TR><TD CLASS="l">522</TD><TD>        // We build temporary maps and assign to the class variables at the end of the method</TD></TR><TR><TD CLASS="l">523</TD><TD>        // so that any exception in the building of the caches will cause the caches to remain null.</TD></TR><TR><TD CLASS="l">524</TD><TD>        // We do not want to start the system with a partially-built map.</TD></TR><TR><TD CLASS="l">525</TD><TD>        //</TD></TR><TR><TD CLASS="l">526</TD><TD>        // The tmpClassByUndlyMap is being build with a Map&lt;classKey,ClassStruct&gt; which is then</TD></TR><TR><TD CLASS="l"><A NAME="7a">527</A></TD><TD>        // translated to a List&lt;ClassStruct&gt;.  This is avoid adding duplicate classes to the list</TD></TR><TR><TD CLASS="l">528</TD><TD>        // (as in the case of strategy (type 11) classes, which are listed in multiple sessions).</TD></TR><TR><TD CLASS="l">529</TD><TD>        //</TD></TR><TR><TD CLASS="l">530</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>        Log.information(this, &#34;Initializing the sessionsByClass and classesByUnderlying cache maps...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>        Map tmpSessByClassMap = new HashMap(10000);</TD></TR><TR CLASS="z"><TD CLASS="l">533</TD><TD>        Map tmpClassByUndlyMap = new HashMap(10000);</TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>        TradingSession[] sessions = sessionHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">535</TD><TD>        for (int i = 0; i &lt; sessions.length; i++)</TD></TR><TR><TD CLASS="l">536</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>            final String sessName = sessions[i].getSessionName();</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>            final ProductClassStruct[] prodClasses = getProductClassesForSession(sessName, false, true);</TD></TR><TR><TD CLASS="l">539</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>            for (int j = 0; j &lt; prodClasses.length; j++)</TD></TR><TR><TD CLASS="l">541</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                final Integer classKey = new Integer(prodClasses[j].info.classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>                ArrayList sessClassList = (ArrayList) tmpSessByClassMap.get(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>                if (sessClassList == null)</TD></TR><TR><TD CLASS="l">545</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                    tmpSessByClassMap.put(classKey, sessClassList = new ArrayList(5));</TD></TR><TR><TD CLASS="l">547</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                sessClassList.add(sessName);</TD></TR><TR><TD CLASS="l">549</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>                final Integer undlyProdKey = new Integer(prodClasses[j].info.underlyingProduct.productKeys.productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>                Map derivativeClasses = (HashMap) tmpClassByUndlyMap.get(undlyProdKey);</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                if (derivativeClasses == null)</TD></TR><TR><TD CLASS="l">553</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                    tmpClassByUndlyMap.put(undlyProdKey, derivativeClasses = new HashMap(10));</TD></TR><TR><TD CLASS="l">555</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                derivativeClasses.put(new Integer(prodClasses[j].info.classKey), prodClasses[j].info);</TD></TR><TR><TD CLASS="l">557</TD><TD>            }</TD></TR><TR><TD CLASS="l">558</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>            Log.information(this, &#34;Cached &#34; + prodClasses.length + &#34; prod class keys for session '&#34; + sessName + &#34;'&#34;);</TD></TR><TR><TD CLASS="l">560</TD><TD>        }</TD></TR><TR><TD CLASS="l">561</TD><TD> </TD></TR><TR><TD CLASS="l">562</TD><TD>        // Convert the Map&lt;undlyProdKey,Map&lt;classKey,ClassStruct&gt;&gt; to Map&lt;undlyProdKey,List&lt;ClassStruct&gt;&gt;</TD></TR><TR><TD CLASS="l">563</TD><TD>        //</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>        Iterator iter = tmpClassByUndlyMap.keySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>        while (iter.hasNext())</TD></TR><TR><TD CLASS="l">566</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">567</TD><TD>            Object key = iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>            Map map = (Map)tmpClassByUndlyMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">569</TD><TD>            List list = new ArrayList(map.values());</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>            tmpClassByUndlyMap.put(key, list);  // replace the key's value in the map</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>        }</TD></TR><TR><TD CLASS="l">572</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>        this.sessionsByClass = Collections.synchronizedMap(tmpSessByClassMap);</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>        this.derivativesByUnderlying = Collections.synchronizedMap(tmpClassByUndlyMap);</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>        Log.information(this, &#34;Done initializing the sessionsByClass and classesByUnderlying cache maps.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>    }</TD></TR><TR><TD CLASS="l">577</TD><TD> </TD></TR><TR><TD CLASS="l">578</TD><TD> /**</TD></TR><TR><TD CLASS="l">579</TD><TD> * Create the service, assigning default values to the data members.  Initialize the timers.</TD></TR><TR><TD CLASS="l">580</TD><TD> *</TD></TR><TR><TD CLASS="l">581</TD><TD> * @param String name of this object.</TD></TR><TR><TD CLASS="l"><A NAME="2">582</A></TD><TD> * @param localClientInstance - a reference to the local TradingSessionClientImpl.\</TD></TR><TR><TD CLASS="l">583</TD><TD> * @param boolean true if there are no TSS clients.</TD></TR><TR><TD CLASS="l">584</TD><TD> */</TD></TR><TR><TD CLASS="l">585</TD><TD>public TradingSessionServiceLocalImpl(String name, TradingSessionClientImpl localClientInstance, boolean useLocalImpl)</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>        setName(name);</TD></TR><TR><TD CLASS="l">588</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>        useAsLocalImpl = useLocalImpl;</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>        this.localClientInstance = localClientInstance;</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>    this.commands = new TradingSessionServiceCommands(this);</TD></TR><TR CLASS="z"><TD CLASS="l">592</TD><TD>}</TD></TR><TR><TD CLASS="l">593</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="50">594</A></TD><TD> * Event history home accessor</TD></TR><TR><TD CLASS="l">595</TD><TD> */</TD></TR><TR><TD CLASS="l">596</TD><TD>public synchronized TradingSessionEventHistoryHome getEventHistoryHome()</TD></TR><TR><TD CLASS="l">597</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">598</TD><TD>    if (eventHistoryHome == null)</TD></TR><TR><TD CLASS="l">599</TD><TD>    {</TD></TR><TR><TD CLASS="l">600</TD><TD>        try</TD></TR><TR><TD CLASS="l">601</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">602</TD><TD>            BOHome aHome = HomeFactory.getInstance().findHome(TradingSessionEventHistoryHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">603</TD><TD>            eventHistoryHome = (TradingSessionEventHistoryHome)aHome;</TD></TR><TR><TD CLASS="l">604</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>        catch (CBOELoggableException e)</TD></TR><TR><TD CLASS="l">606</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">607</TD><TD>            Log.exception(this, &#34;Could not find trading sesion event home&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>        }</TD></TR><TR><TD CLASS="l">609</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>    return eventHistoryHome;</TD></TR><TR><TD CLASS="l">611</TD><TD>}</TD></TR><TR><TD CLASS="l">612</TD><TD>/**</TD></TR><TR><TD CLASS="l">613</TD><TD> * Accept strategy definition/retrieval request. Verifies that products are valid for session and then passes</TD></TR><TR><TD CLASS="l">614</TD><TD> * request on to the ProductQueryService.</TD></TR><TR><TD CLASS="l"><A NAME="5">615</A></TD><TD> */</TD></TR><TR><TD CLASS="l">616</TD><TD>public SessionStrategyStruct acceptStrategy(String sessionName, StrategyRequestStruct strategyRequest)</TD></TR><TR><TD CLASS="l">617</TD><TD>    throws DataValidationException, AuthorizationException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">618</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>        SessionStrategyStruct returnValue = null;</TD></TR><TR><TD CLASS="l">620</TD><TD>        try {</TD></TR><TR><TD CLASS="l">621</TD><TD>//                validateStrategyLegs(sessionName, strategyRequest);</TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>                if (!isValidStrategyLegCount(strategyRequest)) {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>                    throw ExceptionBuilder.dataValidationException(&#34;Invalid strategy with more 4 legs is not allowed.&#34;, DataValidationCodes.INVALID_STRATEGY);</TD></TR><TR><TD CLASS="l">624</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>                validateStrategy(sessionName, strategyRequest);</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                StrategyStruct aStrategyStruct = getProductQueryService().acceptStrategy(strategyRequest);</TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>                addStrategyProductToSessions(aStrategyStruct);</TD></TR><TR CLASS="z"><TD CLASS="l">628</TD><TD>                returnValue = buildSessionStrategyStruct(aStrategyStruct, sessionName);</TD></TR><TR><TD CLASS="l">629</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">630</TD><TD>        catch (DataValidationException de){</TD></TR><TR CLASS="z"><TD CLASS="l">631</TD><TD>                String message = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">632</TD><TD>                StrategyLegStruct[] legs = strategyRequest.strategyLegs;</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>                for (int i = 0; i &lt; legs.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>                        message = message + &#34;Leg product &#34; + i + &#34; is (key/ratio/side)&#34; + legs[i].product +&#34;/&#34; + legs[i].ratioQuantity + &#34;/&#34; + legs[i].side + &#34;\n&#34;;</TD></TR><TR><TD CLASS="l">635</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">636</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">637</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">638</TD><TD>                    Log.debug(&#34;Accept strategy failed &#34; + message + de.details.message);</TD></TR><TR><TD CLASS="l">639</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>                Log.exception(&#34;Accept strategy failed&#34; +  message + de.details.message, de);</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>                throw de;</TD></TR><TR><TD CLASS="l">642</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>        catch (NotFoundException ne)</TD></TR><TR><TD CLASS="l">644</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                String message = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                StrategyLegStruct[] legs = strategyRequest.strategyLegs;</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                for (int i = 0; i &lt; legs.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                        message = message + &#34;Leg product &#34; + i + &#34; is (key/ratio/side)&#34; + legs[i].product +&#34;/&#34; + legs[i].ratioQuantity + &#34;/&#34; + legs[i].side + &#34;\n&#34;;</TD></TR><TR><TD CLASS="l">649</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">650</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">651</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>                    Log.debug(&#34;Accept strategy failed, this strategy trading product is NOT added into this session &#34; + sessionName + &#34; Due to &#34; + message + ne.details.message);</TD></TR><TR><TD CLASS="l">653</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">654</TD><TD>                Log.exception(&#34;Accept strategy failed&#34; +  message + ne.details.message, ne);</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Failed to buinding  session strategy. this strategy trading product is NOT added into this session &#34; + sessionName + &#34; Due to &#34; + message + ne.details.message, 0);</TD></TR><TR><TD CLASS="l">656</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">657</TD><TD>        catch(Exception e){</TD></TR><TR CLASS="z"><TD CLASS="l">658</TD><TD>                String message = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                StrategyLegStruct[] legs = strategyRequest.strategyLegs;</TD></TR><TR CLASS="z"><TD CLASS="l">660</TD><TD>                for (int i = 0; i &lt; legs.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>                        message = message + &#34;Leg product &#34; + i + &#34; is (key/ratio/side)&#34; + legs[i].product +&#34;/&#34; + legs[i].ratioQuantity + &#34;/&#34; + legs[i].side + &#34;\n&#34;;</TD></TR><TR><TD CLASS="l">662</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">664</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>                    Log.debug(&#34;Accept strategy failed &#34; + message + e.getMessage() );</TD></TR><TR><TD CLASS="l">666</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                Log.exception(&#34;Accept strategy failed, due to &#34; + message + e.getMessage(), e);</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;System exception while building session strategy. Due to &#34; + message + e.getMessage(), 0);</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>        return returnValue;</TD></TR><TR><TD CLASS="l">671</TD><TD>}</TD></TR><TR><TD CLASS="l">672</TD><TD> </TD></TR><TR><TD CLASS="l">673</TD><TD>        /**</TD></TR><TR><TD CLASS="l">674</TD><TD>         * Create new Flex Strategy from given leg information.</TD></TR><TR><TD CLASS="l"><A NAME="4">675</A></TD><TD>         * </TD></TR><TR><TD CLASS="l">676</TD><TD>         * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">677</TD><TD>         */</TD></TR><TR><TD CLASS="l">678</TD><TD>        public StrategyStruct acceptFlexStrategy(StrategyLegDefinitionStruct[] strategyLegs) throws SystemException, CommunicationException, AuthorizationException, DataValidationException, AlreadyExistsException {</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>                createStrategyLegsForFlex(strategyLegs);</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>                StrategyRequestStruct strategyRequestStruct = ProductStrategyStructBuilder.buildStrategyRequestStruct(strategyLegs);</TD></TR><TR CLASS="z"><TD CLASS="l">681</TD><TD>                StrategyStruct aStrategyStruct = getProductQueryService().acceptStrategy(strategyRequestStruct);</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>        addStrategyProductToSessions(aStrategyStruct);</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>        return aStrategyStruct;</TD></TR><TR><TD CLASS="l">684</TD><TD>        }</TD></TR><TR><TD CLASS="l">685</TD><TD>        </TD></TR><TR><TD CLASS="l">686</TD><TD>        /**</TD></TR><TR><TD CLASS="l">687</TD><TD>         * Create leg products for strategy if doesn't exist.</TD></TR><TR><TD CLASS="l">688</TD><TD>         * </TD></TR><TR><TD CLASS="l">689</TD><TD>         * @param strategyLegs</TD></TR><TR><TD CLASS="l">690</TD><TD>         * @throws DataValidationException</TD></TR><TR><TD CLASS="l">691</TD><TD>         * @throws SystemException</TD></TR><TR><TD CLASS="l">692</TD><TD>         * @throws CommunicationException</TD></TR><TR><TD CLASS="l">693</TD><TD>         * @throws AuthorizationException</TD></TR><TR><TD CLASS="l">694</TD><TD>         * </TD></TR><TR><TD CLASS="l"><A NAME="22">695</A></TD><TD>         * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">696</TD><TD>         */</TD></TR><TR><TD CLASS="l">697</TD><TD>        private void createStrategyLegsForFlex(StrategyLegDefinitionStruct[] strategyLegs) throws SystemException, DataValidationException, SystemException, CommunicationException, AuthorizationException{</TD></TR><TR><TD CLASS="l">698</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>        ArrayList&lt;ProductStruct&gt; productList = new ArrayList&lt;ProductStruct&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>        Map&lt;Integer,Integer&gt; legProductMap = new HashMap&lt;Integer, Integer&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>        int index = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">702</TD><TD>                for(int i=0;i &lt; strategyLegs.length;i++){</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>            if(strategyLegs[i].legProduct.productKeys.productType == ProductTypes.EQUITY || strategyLegs[i].legProduct.productKeys.productType == ProductTypes.INDEX){</TD></TR><TR CLASS="z"><TD CLASS="l">704</TD><TD>                int[] productKeys = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>                productKeys[0]= strategyLegs[i].legProduct.productKeys.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">706</TD><TD>                ProductStruct[]  equityProducts = getProductQueryService().getProductsByKey(productKeys);</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>                if(equityProducts[0] == null){</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>                    throw ExceptionBuilder.dataValidationException(&#34;Unable to fetch equity product for key  : &#34; + strategyLegs[i].legProduct.productKeys.productKey , DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">709</TD><TD>                }                </TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>            }else {</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                productList.add(strategyLegs[i].legProduct);</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                legProductMap.put(index++,i);</TD></TR><TR><TD CLASS="l">713</TD><TD>            }</TD></TR><TR><TD CLASS="l">714</TD><TD>                }</TD></TR><TR><TD CLASS="l">715</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>        ProductStruct[] products = new ProductStruct[productList.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>        products = productList.toArray(products);</TD></TR><TR><TD CLASS="l">718</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                ProductStruct[] newProducts = null;</TD></TR><TR><TD CLASS="l">720</TD><TD>                try </TD></TR><TR><TD CLASS="l">721</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                        newProducts = getProductMaintenanceService().addProducts(products);</TD></TR><TR><TD CLASS="l">723</TD><TD>                } </TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                catch (TransactionFailedException e) </TD></TR><TR><TD CLASS="l">725</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                        ExceptionBuilder.systemException(&#34;Exception occured while creating strategy legs :&#34;, 0);</TD></TR><TR><TD CLASS="l">727</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>                catch (AlreadyExistsException e) </TD></TR><TR><TD CLASS="l">729</TD><TD>                {</TD></TR><TR><TD CLASS="l">730</TD><TD>                        </TD></TR><TR CLASS="z"><TD CLASS="l">731</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">732</TD><TD>                if(newProducts != null){</TD></TR><TR CLASS="z"><TD CLASS="l">733</TD><TD>                        for(int i=0;i&lt; newProducts.length;i++){</TD></TR><TR CLASS="z"><TD CLASS="l">734</TD><TD>                int legIndex = legProductMap.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">735</TD><TD>                                strategyLegs[legIndex].legProduct = newProducts[i];</TD></TR><TR><TD CLASS="l">736</TD><TD>                        }</TD></TR><TR><TD CLASS="l">737</TD><TD>                }                </TD></TR><TR CLASS="z"><TD CLASS="l">738</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="83">739</A></TD><TD> </TD></TR><TR><TD CLASS="l">740</TD><TD> </TD></TR><TR><TD CLASS="l">741</TD><TD>private boolean isValidStrategyLegCount(StrategyRequestStruct strategyRequest)</TD></TR><TR><TD CLASS="l">742</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>    return (strategyRequest.strategyLegs.length &lt;= 4);</TD></TR><TR><TD CLASS="l">744</TD><TD>}</TD></TR><TR><TD CLASS="l">745</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="f">746</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">747</TD><TD> * add the newly created strategy to configured sessions</TD></TR><TR><TD CLASS="l">748</TD><TD> */</TD></TR><TR><TD CLASS="l">749</TD><TD>private void addStrategyProductToSessions(StrategyStruct newStrategy){</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>        boolean success = false;</TD></TR><TR><TD CLASS="l">751</TD><TD>        TradingSession session;</TD></TR><TR CLASS="z"><TD CLASS="l">752</TD><TD>        boolean isProductAddedTosession = false;</TD></TR><TR><TD CLASS="l">753</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>                Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">755</TD><TD>                TemplateClass[] templateClasses = templateClassHome.findByClass(newStrategy.product.productKeys.classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">756</TD><TD>                for (int i = 0; i &lt; templateClasses.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>                        if (!templateClasses[i].isSelected(newStrategy)){</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">759</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>                        session = templateClasses[i].getTemplate().getSession();</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>                        addStrategyProductToSession(session,newStrategy);</TD></TR><TR CLASS="z"><TD CLASS="l">762</TD><TD>                        isProductAddedTosession = true;</TD></TR><TR><TD CLASS="l">763</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                if(!isProductAddedTosession) {</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                          Product product =  getProductHome().findByKey(newStrategy.product.productKeys.productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">766</TD><TD>                   product.setListingState(ListingStates.INACTIVE);</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>                   Log.information(this,&#34;Strategy product (&#34; + newStrategy.product.productKeys.productKey + &#34;) Listing State is changed to INACTIVE, becaus the strategy product could not be added to any session!&#34;);</TD></TR><TR><TD CLASS="l">768</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>                success = Transaction.commit();</TD></TR><TR><TD CLASS="l">770</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>        catch (NotFoundException nfe){</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>              Log.exception (this,&#34;Strategy product Key = &#34; + newStrategy.product.productKeys.productKey + &#34; is not found&#34; , nfe);</TD></TR><TR><TD CLASS="l">773</TD><TD>        }</TD></TR><TR><TD CLASS="l">774</TD><TD>        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">775</TD><TD>                if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">776</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">777</TD><TD>                }</TD></TR><TR><TD CLASS="l">778</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">779</TD><TD>}</TD></TR><TR><TD CLASS="l">780</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="e">781</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">782</TD><TD> * Add the newly created strategy to a session</TD></TR><TR><TD CLASS="l">783</TD><TD> */</TD></TR><TR><TD CLASS="l">784</TD><TD>private void addStrategyProductToSession(TradingSession session, StrategyStruct newStrategy){</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>        SessionStrategyStruct sessionStrategy = null;</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>        SessionElementProduct elementProduct = session.getProductByKey(newStrategy.product.productKeys.productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>        if (elementProduct == null &amp;&amp; session.getSessionState() == TradingSessionStates.OPEN ) {</TD></TR><TR><TD CLASS="l">788</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                        elementProduct = session.addProduct(newStrategy.product);</TD></TR><TR><TD CLASS="l">790</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">791</TD><TD>                catch (Exception e){</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>                        Log.exception(&#34;Add strategy to session &#34; + session.getSessionName() + &#34; failed&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                }</TD></TR><TR><TD CLASS="l">794</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">795</TD><TD>        if (elementProduct != null) { //addition to session sucessful</TD></TR><TR CLASS="z"><TD CLASS="l">796</TD><TD>                SessionProductStruct sessionProductStruct = elementProduct.toSessionProductStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">797</TD><TD>                sessionStrategy = SessionStrategyStructHelper.buildSessionStrategyStruct(newStrategy, sessionProductStruct, session.getSessionName());</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>                getTradingSessionPublisher().updateProductStrategy(sessionStrategy);</TD></TR><TR><TD CLASS="l">799</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>                clearSessionProdCache(session.getSessionName(), true);</TD></TR><TR><TD CLASS="l">801</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>}</TD></TR><TR><TD CLASS="l">803</TD><TD> </TD></TR><TR><TD CLASS="l">804</TD><TD>/**</TD></TR><TR><TD CLASS="l">805</TD><TD> * buildSessionStrategyStruct - Method to build a SessionStrategyStruct for a particular session.</TD></TR><TR><TD CLASS="l">806</TD><TD> *</TD></TR><TR><TD CLASS="l">807</TD><TD> * @param aSessionProductStruct</TD></TR><TR><TD CLASS="l">808</TD><TD> * @param sessionName</TD></TR><TR><TD CLASS="l">809</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="18">810</A></TD><TD>private SessionStrategyStruct buildSessionStrategyStruct(SessionProductStruct aSessionProductStruct, String sessionName)</TD></TR><TR><TD CLASS="l">811</TD><TD>    throws SystemException, NotFoundException, DataValidationException, AuthorizationException, CommunicationException</TD></TR><TR><TD CLASS="l">812</TD><TD>{</TD></TR><TR><TD CLASS="l">813</TD><TD>    // Get the strategy struct</TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>    StrategyStruct aStrategyStruct = getProductQueryService().getStrategyByKey(</TD></TR><TR><TD CLASS="l">815</TD><TD>        aSessionProductStruct.productStruct.productKeys.productKey);</TD></TR><TR><TD CLASS="l">816</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">817</TD><TD>    return SessionStrategyStructHelper.buildSessionStrategyStruct(aStrategyStruct, aSessionProductStruct, sessionName);</TD></TR><TR><TD CLASS="l">818</TD><TD>}</TD></TR><TR><TD CLASS="l">819</TD><TD> </TD></TR><TR><TD CLASS="l">820</TD><TD>/**</TD></TR><TR><TD CLASS="l">821</TD><TD> * buildSessionStrategyStruct - Method to build a SessionStrategyStruct for a particular session.</TD></TR><TR><TD CLASS="l">822</TD><TD> *</TD></TR><TR><TD CLASS="l">823</TD><TD> * @param aStrategyStruct</TD></TR><TR><TD CLASS="l">824</TD><TD> * @param sessionName</TD></TR><TR><TD CLASS="l">825</TD><TD> */</TD></TR><TR><TD CLASS="l">826</TD><TD>private SessionStrategyStruct buildSessionStrategyStruct(StrategyStruct aStrategyStruct, String sessionName)</TD></TR><TR><TD CLASS="l"><A NAME="19">827</A></TD><TD>    throws NotFoundException, DataValidationException</TD></TR><TR><TD CLASS="l">828</TD><TD>{</TD></TR><TR><TD CLASS="l">829</TD><TD> </TD></TR><TR><TD CLASS="l">830</TD><TD>    // Get the session product struct</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>    SessionProductStruct sessionProductStruct = getProductBySessionForKey(</TD></TR><TR><TD CLASS="l">832</TD><TD>        sessionName, aStrategyStruct.product.productKeys.productKey);</TD></TR><TR><TD CLASS="l">833</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>    return SessionStrategyStructHelper.buildSessionStrategyStruct(aStrategyStruct, sessionProductStruct, sessionName);</TD></TR><TR><TD CLASS="l">835</TD><TD>}</TD></TR><TR><TD CLASS="l">836</TD><TD> </TD></TR><TR><TD CLASS="l">837</TD><TD>/**</TD></TR><TR><TD CLASS="l">838</TD><TD> *        Add a listener to the service.  A listener may be added multiple times with different types.  If a listener</TD></TR><TR><TD CLASS="l">839</TD><TD> *  registers more than once for a single event (without unregistering first) then it will be called more than once</TD></TR><TR><TD CLASS="l">840</TD><TD> *  for a given event.</TD></TR><TR><TD CLASS="l">841</TD><TD> *</TD></TR><TR><TD CLASS="l">842</TD><TD> *  @param type - a TradingSessionEventType (enumerated type implementation) to specify what event this listener is registered for.</TD></TR><TR><TD CLASS="l">843</TD><TD> *  @param priority - an integer used to determine the order in which these things are called.  When an event occurs,</TD></TR><TR><TD CLASS="l">844</TD><TD> *       the process will notify the registered listeners, ordered by their priority values, smallest to highest.</TD></TR><TR><TD CLASS="l"><A NAME="d">845</A></TD><TD> *  @param listener - the TradingSessionListener to remove.</TD></TR><TR><TD CLASS="l">846</TD><TD> */</TD></TR><TR><TD CLASS="l">847</TD><TD>public synchronized void addListener(TradingSessionEventType type, int priority, TradingSessionListener listener)</TD></TR><TR><TD CLASS="l">848</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">849</TD><TD>        localClientInstance.addListener(type, priority, listener);</TD></TR><TR CLASS="z"><TD CLASS="l">850</TD><TD>}</TD></TR><TR><TD CLASS="l">851</TD><TD>/**</TD></TR><TR><TD CLASS="l">852</TD><TD> * Add a new trading session group.</TD></TR><TR><TD CLASS="l">853</TD><TD> * @param newSession com.cboe.idl.session.TradingSessionStruct</TD></TR><TR><TD CLASS="l">854</TD><TD> * @exception DataValiadationException if the strategy s not found.</TD></TR><TR><TD CLASS="l">855</TD><TD> * @exception SystemException id errors commiting transaction.</TD></TR><TR><TD CLASS="l">856</TD><TD> */</TD></TR><TR><TD CLASS="l">857</TD><TD>public void addTradingSession(TradingSessionStruct newSession) throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l"><A NAME="10">858</A></TD><TD>{</TD></TR><TR><TD CLASS="l">859</TD><TD>        // If the group already exists then error out.</TD></TR><TR><TD CLASS="l">860</TD><TD>        try</TD></TR><TR><TD CLASS="l">861</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">862</TD><TD>                sessionHome.find(newSession.sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Group already exists: &#34; + newSession.sessionName,DataValidationCodes.DUPLICATE_ID);</TD></TR><TR><TD CLASS="l">864</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">866</TD><TD>        {</TD></TR><TR><TD CLASS="l">867</TD><TD>                // Ok to add the group.</TD></TR><TR><TD CLASS="l">868</TD><TD>        }</TD></TR><TR><TD CLASS="l">869</TD><TD> </TD></TR><TR><TD CLASS="l">870</TD><TD>        // Validated the strategy name</TD></TR><TR><TD CLASS="l">871</TD><TD>        try</TD></TR><TR><TD CLASS="l">872</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">873</TD><TD>                strategyFactory.getEndOfSessionStrategy(newSession.endOfSessionStrategy);</TD></TR><TR><TD CLASS="l">874</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">876</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">877</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Unable to add session group, startegy does not exist: &#34; + newSession.endOfSessionStrategy,0);</TD></TR><TR CLASS="z"><TD CLASS="l">878</TD><TD>        }</TD></TR><TR><TD CLASS="l">879</TD><TD> </TD></TR><TR><TD CLASS="l">880</TD><TD>        // Now add.</TD></TR><TR CLASS="z"><TD CLASS="l">881</TD><TD>        boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">882</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">883</TD><TD>        try</TD></TR><TR><TD CLASS="l">884</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">885</TD><TD>                sessionHome.create(newSession);</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>                success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">887</TD><TD>                if (!success)</TD></TR><TR><TD CLASS="l">888</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>                        throw ExceptionBuilder.systemException(&#34;Error commiting create transaction for session: &#34; + newSession.sessionName,0);</TD></TR><TR><TD CLASS="l">890</TD><TD>                }</TD></TR><TR><TD CLASS="l">891</TD><TD>        }</TD></TR><TR><TD CLASS="l">892</TD><TD>        finally</TD></TR><TR><TD CLASS="l">893</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">894</TD><TD>                if (!success) // Commit failed or validation error</TD></TR><TR><TD CLASS="l">895</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">896</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">897</TD><TD>                }</TD></TR><TR><TD CLASS="l">898</TD><TD>        }</TD></TR><TR><TD CLASS="l">899</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">900</TD><TD>        Log.information(this,&#34;New session added: &#34; + newSession.sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">901</TD><TD>}</TD></TR><TR><TD CLASS="l">902</TD><TD>/**</TD></TR><TR><TD CLASS="l">903</TD><TD> *</TD></TR><TR><TD CLASS="l">904</TD><TD> * @param templateStruct com.cboe.idl.cmiSession.TradingSessionStruct</TD></TR><TR><TD CLASS="l">905</TD><TD> */</TD></TR><TR><TD CLASS="l">906</TD><TD>public void addTradingSessionTemplate(TradingSessionElementTemplateStruct templateStruct)</TD></TR><TR><TD CLASS="l">907</TD><TD>        throws AlreadyExistsException, DataValidationException, TransactionFailedException,</TD></TR><TR><TD CLASS="l"><A NAME="11">908</A></TD><TD>               CommunicationException, SystemException, AuthorizationException</TD></TR><TR><TD CLASS="l">909</TD><TD>{</TD></TR><TR><TD CLASS="l">910</TD><TD>    TradingSession parentSession;</TD></TR><TR><TD CLASS="l">911</TD><TD>        // Validate and make sure session exists.</TD></TR><TR CLASS="z"><TD CLASS="l">912</TD><TD>        parentSession = verifySessionName(templateStruct.sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">913</TD><TD>    boolean isTimeCorrect =</TD></TR><TR><TD CLASS="l">914</TD><TD>        ( TimeHelper.toMillisSinceMidnight(templateStruct.productPreOpenTime) &gt;= parentSession.getStartTime()) &amp;&amp;</TD></TR><TR><TD CLASS="l">915</TD><TD>        ( TimeHelper.toMillisSinceMidnight(templateStruct.productOpenTime) &gt;= parentSession.getStartTime() ) &amp;&amp;</TD></TR><TR><TD CLASS="l">916</TD><TD>        ( TimeHelper.toMillisSinceMidnight(templateStruct.productCloseTime) &lt;= parentSession.getEndTime());</TD></TR><TR CLASS="z"><TD CLASS="l">917</TD><TD>        if (! isTimeCorrect)</TD></TR><TR><TD CLASS="l">918</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">919</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Product Open and Close Time must be within the session start and end time&#34;, DataValidationCodes.INVALID_TIME);</TD></TR><TR><TD CLASS="l">920</TD><TD>        }</TD></TR><TR><TD CLASS="l">921</TD><TD> </TD></TR><TR><TD CLASS="l">922</TD><TD>        // Start the add in a transaction.</TD></TR><TR CLASS="z"><TD CLASS="l">923</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">924</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">926</TD><TD>        try</TD></TR><TR><TD CLASS="l">927</TD><TD>        {</TD></TR><TR><TD CLASS="l">928</TD><TD>                // Create the template and validate it.</TD></TR><TR CLASS="z"><TD CLASS="l">929</TD><TD>                templateHome.create(parentSession, templateStruct);</TD></TR><TR><TD CLASS="l">930</TD><TD> </TD></TR><TR><TD CLASS="l">931</TD><TD>                // Add to database</TD></TR><TR CLASS="z"><TD CLASS="l">932</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">934</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">935</TD><TD>                        throw ExceptionBuilder.transactionFailedException(&#34;Error committing transaction for template&#34; , 0);</TD></TR><TR><TD CLASS="l">936</TD><TD>                }</TD></TR><TR><TD CLASS="l">937</TD><TD>        }</TD></TR><TR><TD CLASS="l">938</TD><TD>        finally</TD></TR><TR><TD CLASS="l">939</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">940</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">941</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">942</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">943</TD><TD>                }</TD></TR><TR><TD CLASS="l">944</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">945</TD><TD>}</TD></TR><TR><TD CLASS="l">946</TD><TD>/**</TD></TR><TR><TD CLASS="l">947</TD><TD> * Adds a class to a template.</TD></TR><TR><TD CLASS="l">948</TD><TD> *</TD></TR><TR><TD CLASS="l">949</TD><TD> * @param templateName template of new class</TD></TR><TR><TD CLASS="l"><A NAME="c">950</A></TD><TD> * @param addedClass struct for class being added</TD></TR><TR><TD CLASS="l">951</TD><TD> */</TD></TR><TR><TD CLASS="l">952</TD><TD>public void addClassToTemplate(String templateName, TemplateClassStruct addedClass)</TD></TR><TR><TD CLASS="l">953</TD><TD>    throws DataValidationException, TransactionFailedException {</TD></TR><TR CLASS="z"><TD CLASS="l">954</TD><TD>    boolean success = false;</TD></TR><TR><TD CLASS="l">955</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">956</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">957</TD><TD>        TradingSessionElementTemplate template = verifyTemplateName(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">958</TD><TD>        template.addClass(addedClass);</TD></TR><TR CLASS="z"><TD CLASS="l">959</TD><TD>        success = Transaction.commit();</TD></TR><TR><TD CLASS="l">960</TD><TD>    }</TD></TR><TR><TD CLASS="l">961</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">962</TD><TD>        if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>            Transaction.rollback();</TD></TR><TR><TD CLASS="l">964</TD><TD>        }</TD></TR><TR><TD CLASS="l">965</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="13">967</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">968</TD><TD> * Determines if all sessions are closed.</TD></TR><TR><TD CLASS="l">969</TD><TD> */</TD></TR><TR><TD CLASS="l">970</TD><TD>private boolean areAllSessionsClosed() {</TD></TR><TR CLASS="z"><TD CLASS="l">971</TD><TD>    TradingSession[] sessions = sessionHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">972</TD><TD>    for (int i = 0; i &lt; sessions.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">973</TD><TD>        if (sessions[i].getSessionState() == TradingSessionStates.OPEN) {</TD></TR><TR CLASS="z"><TD CLASS="l">974</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">975</TD><TD>        }</TD></TR><TR><TD CLASS="l">976</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">977</TD><TD>    return true;</TD></TR><TR><TD CLASS="l">978</TD><TD>}</TD></TR><TR><TD CLASS="l">979</TD><TD>/**</TD></TR><TR><TD CLASS="l">980</TD><TD> *  Using the &#34;template name to session code&#34; mapping defined in the</TD></TR><TR><TD CLASS="l">981</TD><TD> *  service configuration, build the key list for the templates.</TD></TR><TR><TD CLASS="l">982</TD><TD> *</TD></TR><TR><TD CLASS="l">983</TD><TD> * Although there are many iterations in this method, the arrays</TD></TR><TR><TD CLASS="l">984</TD><TD> * themselves should be quite small (ie, there will be a small</TD></TR><TR><TD CLASS="l">985</TD><TD> * number of templates configured).</TD></TR><TR><TD CLASS="l">986</TD><TD> * Mapping of template to one or more sessions codes.  This mapping is</TD></TR><TR><TD CLASS="l">987</TD><TD> * generated by TradingSessionService configuration information, and is used to</TD></TR><TR><TD CLASS="l">988</TD><TD> * map product classes to pre-defined templates.</TD></TR><TR><TD CLASS="l">989</TD><TD> * The key is sessionCode.productDescriptionName and the objects are Vector of</TD></TR><TR><TD CLASS="l">990</TD><TD> * template names.</TD></TR><TR><TD CLASS="l">991</TD><TD> * The values of sessionCode + productDescriptionName are provided by TPF and stored</TD></TR><TR><TD CLASS="l">992</TD><TD> * in Product service.</TD></TR><TR><TD CLASS="l">993</TD><TD> *</TD></TR><TR><TD CLASS="l">994</TD><TD> * NOTE: the configuration file must contains values that exactly match the</TD></TR><TR><TD CLASS="l">995</TD><TD> *                  values probvided by TPF, otherwise product will not be assigned to sessions.</TD></TR><TR><TD CLASS="l"><A NAME="1a">996</A></TD><TD> */</TD></TR><TR><TD CLASS="l">997</TD><TD>public String buildTemplateClassMapping()</TD></TR><TR><TD CLASS="l">998</TD><TD>    throws AuthorizationException, CommunicationException, SystemException, TransactionFailedException</TD></TR><TR><TD CLASS="l">999</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>    boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>    lockServiceForUpdates(&#34;Building template class mapping&#34;);</TD></TR><TR><TD CLASS="l">1002</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">1003</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1004</TD><TD>        Log.information(this,&#34;Starting build of class mapping to sessions. Now querying for all product classes.&#34;);</TD></TR><TR><TD CLASS="l">1005</TD><TD>        // get active classes without reporting classes or products</TD></TR><TR CLASS="z"><TD CLASS="l">1006</TD><TD>        ProductClassStruct[] productClasses = getProductQueryService().getProductClasses(true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1007</TD><TD>        Log.information(this,&#34;Found (&#34; + productClasses.length + &#34;) classes that may potentially be configured in sessions.&#34;);</TD></TR><TR><TD CLASS="l">1008</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>        templateHome.buildClassMapping(productClasses);</TD></TR><TR CLASS="z"><TD CLASS="l">1010</TD><TD>        success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>        if (success) {</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>            Log.information(this,&#34;Completed build of class mapping to sessions.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1013</TD><TD>            return &#34;\n----------------------------------\n&#34; + &#34;Class mapping complete.&#34;+ &#34;\n----------------------------------\n&#34;;</TD></TR><TR><TD CLASS="l">1014</TD><TD>        }</TD></TR><TR><TD CLASS="l">1015</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1016</TD><TD>            throw ExceptionBuilder.systemException(&#34;Unable to commit transaction to complete class mapping&#34;, 0);</TD></TR><TR><TD CLASS="l">1017</TD><TD>        }</TD></TR><TR><TD CLASS="l">1018</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1019</TD><TD>    catch (DataValidationException e) {</TD></TR><TR><TD CLASS="l">1020</TD><TD>        // this exception should be removed from PQS</TD></TR><TR CLASS="z"><TD CLASS="l">1021</TD><TD>        throw new SystemException(e.details);</TD></TR><TR><TD CLASS="l">1022</TD><TD>    }</TD></TR><TR><TD CLASS="l">1023</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>        if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>            Transaction.rollback();</TD></TR><TR><TD CLASS="l">1026</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>        releaseUpdateLock();</TD></TR><TR><TD CLASS="l">1028</TD><TD>    }</TD></TR><TR><TD CLASS="l">1029</TD><TD>}</TD></TR><TR><TD CLASS="l">1030</TD><TD>/**</TD></TR><TR><TD CLASS="l">1031</TD><TD> * Creates the current business day.</TD></TR><TR><TD CLASS="l"><A NAME="20">1032</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1033</TD><TD>public String createCurrentBusinessDay() throws TransactionFailedException {</TD></TR><TR><TD CLASS="l">1034</TD><TD> </TD></TR><TR><TD CLASS="l">1035</TD><TD>    // Get current day as time in millis with time truncated off</TD></TR><TR CLASS="z"><TD CLASS="l">1036</TD><TD>    long currentDayInMillis = DateWrapper.convertToMillis(DateWrapper.convertToDate(System.currentTimeMillis()));</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>    String returnMessage = &#34;Create current day processing failed&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1038</TD><TD>    BusinessDay activeDay = getBusinessDayHome().findCurrent();</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>    long activeDayInMillis = activeDay.getDate().getTime();</TD></TR><TR CLASS="z"><TD CLASS="l">1040</TD><TD>    if (activeDay.getState() == BusinessDayStates.STARTED) {</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>        returnMessage = &#34;Current business day (&#34; + TimeHelper.toDateString(activeDayInMillis) + &#34;) is already started&#34;;</TD></TR><TR><TD CLASS="l">1042</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1043</TD><TD>    else if (activeDayInMillis == currentDayInMillis &amp;&amp; activeDay.getState() == BusinessDayStates.ENDED) {</TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>        returnMessage = &#34;Current business day (&#34; + TimeHelper.toDateString(activeDayInMillis) + &#34;) has ended - day not restarted&#34;;</TD></TR><TR><TD CLASS="l">1045</TD><TD>    }</TD></TR><TR><TD CLASS="l">1046</TD><TD>    else {</TD></TR><TR CLASS="z"><TD CLASS="l">1047</TD><TD>        boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1048</TD><TD>        lockServiceForUpdates(&#34;Create current business day&#34;);</TD></TR><TR><TD CLASS="l">1049</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1050</TD><TD>            Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1051</TD><TD>            BusinessDay newDay = getBusinessDayHome().createCurrentDay();</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>            sessionHome.initializeSessionsForNewDay(parallelCreateBusDayFlag);</TD></TR><TR><TD CLASS="l">1053</TD><TD>            // set state so timers will be created for sessions</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>            newDay.setState(BusinessDayStates.STARTED);</TD></TR><TR CLASS="z"><TD CLASS="l">1055</TD><TD>            sessionHome.recoverTimers();</TD></TR><TR CLASS="z"><TD CLASS="l">1056</TD><TD>            elementHome.recoverTimers();</TD></TR><TR CLASS="z"><TD CLASS="l">1057</TD><TD>            success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>            if (success)</TD></TR><TR><TD CLASS="l">1059</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1060</TD><TD>                publishCurrentDay(); // this happens to call getCurrentBusinessDay, which will init the bus day sess cache.</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>                returnMessage = &#34;Current business day (&#34; + TimeHelper.toDateString(newDay.getDate().getTime()) + &#34;) has been created&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>                initializeCachesForOpening();</TD></TR><TR><TD CLASS="l">1063</TD><TD>            }</TD></TR><TR><TD CLASS="l">1064</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>        catch (TransactionFailedException ex)</TD></TR><TR><TD CLASS="l">1066</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1067</TD><TD>            throw ex;</TD></TR><TR><TD CLASS="l">1068</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>        catch (UserException ex)</TD></TR><TR><TD CLASS="l">1070</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>            Log.exception(&#34;Error initializing caches after business day creation&#34;, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>            returnMessage += &#34;\n  NOTE: Error initializing caches after business day creation.&#34;</TD></TR><TR><TD CLASS="l">1073</TD><TD>                + &#34;\n        \&#34;Opening by underlying product state\&#34; will still work, but will not be optimized&#34;;</TD></TR><TR><TD CLASS="l">1074</TD><TD>        }</TD></TR><TR><TD CLASS="l">1075</TD><TD>        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1076</TD><TD>            if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">1077</TD><TD>                Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">1078</TD><TD>                returnMessage = &#34;Current day could not be started due to transaction failure&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1079</TD><TD>                Log.alarm(this, returnMessage);</TD></TR><TR><TD CLASS="l">1080</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>            releaseUpdateLock();</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>        }</TD></TR><TR><TD CLASS="l">1083</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>    Log.information(this, returnMessage);</TD></TR><TR CLASS="z"><TD CLASS="l">1085</TD><TD>    returnMessage = &#34;\n--------------------------------------------------------------------------------------------\n&#34; + returnMessage;</TD></TR><TR CLASS="z"><TD CLASS="l">1086</TD><TD>    returnMessage += &#34;\n--------------------------------------------------------------------------------------------\n&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1087</TD><TD>    return returnMessage;</TD></TR><TR><TD CLASS="l">1088</TD><TD>}</TD></TR><TR><TD CLASS="l">1089</TD><TD>/**</TD></TR><TR><TD CLASS="l">1090</TD><TD> * Creates all the elements for a session for a new business day.</TD></TR><TR><TD CLASS="l">1091</TD><TD> *</TD></TR><TR><TD CLASS="l">1092</TD><TD> * @param sessionName session elements are being created for</TD></TR><TR><TD CLASS="l">1093</TD><TD> * @param businessDay day that elements are for</TD></TR><TR><TD CLASS="l"><A NAME="21">1094</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1095</TD><TD>public TradingSessionElementStruct[] createElementsForSession(String sessionName, DateStruct businessDay)</TD></TR><TR><TD CLASS="l">1096</TD><TD>    throws DataValidationException, TransactionFailedException {</TD></TR><TR><TD CLASS="l">1097</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>    boolean success = false;</TD></TR><TR><TD CLASS="l">1100</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">1101</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1102</TD><TD>        TradingSessionElementTemplate[] templates = templateHome.findActiveBySession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>        TradingSessionElementStruct[] elementStructs = new TradingSessionElementStruct[templates.length];</TD></TR><TR><TD CLASS="l">1104</TD><TD>        TradingSessionElement element;</TD></TR><TR CLASS="z"><TD CLASS="l">1105</TD><TD>        for (int i = 0; i &lt; templates.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1106</TD><TD>            element = elementHome.createFromTemplate(templates[i], businessDay);</TD></TR><TR CLASS="z"><TD CLASS="l">1107</TD><TD>            elementStructs[i] = elementHome.toStruct(element, true);</TD></TR><TR><TD CLASS="l">1108</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1109</TD><TD>        success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">1110</TD><TD>        return elementStructs;</TD></TR><TR><TD CLASS="l">1111</TD><TD>    }</TD></TR><TR><TD CLASS="l">1112</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1113</TD><TD>        if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">1114</TD><TD>            Transaction.rollback();</TD></TR><TR><TD CLASS="l">1115</TD><TD>        }</TD></TR><TR><TD CLASS="l">1116</TD><TD>    }</TD></TR><TR><TD CLASS="l">1117</TD><TD>}</TD></TR><TR><TD CLASS="l">1118</TD><TD>/**</TD></TR><TR><TD CLASS="l">1119</TD><TD> * A helper method for this class.  Many methods require the invocation of a method on all</TD></TR><TR><TD CLASS="l">1120</TD><TD> * TradingSessionClient instances.  The code which accomplishes that is contained herein: the</TD></TR><TR><TD CLASS="l">1121</TD><TD> * caller need only supply an instance of the protected inner class ClientAction to define what</TD></TR><TR><TD CLASS="l">1122</TD><TD> * should be done with each TradingSessionClient.</TD></TR><TR><TD CLASS="l">1123</TD><TD> *</TD></TR><TR><TD CLASS="l">1124</TD><TD> * @param clients TradingSessionClient[] - the list of clients.</TD></TR><TR><TD CLASS="l">1125</TD><TD> * @param action ClientAction - the action to invoke on the clients</TD></TR><TR><TD CLASS="l">1126</TD><TD> * @param waitForCompletion - if true, then this method will not return until all clients have returned.</TD></TR><TR><TD CLASS="l">1127</TD><TD> * @param activeRemoteClients - map of activeClientName-&gt; TradingSessionClient</TD></TR><TR><TD CLASS="l">1128</TD><TD> * @param inactiveRemoteClients - inactive remote client names</TD></TR><TR><TD CLASS="l"><A NAME="24">1129</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1130</TD><TD>private void execute(boolean waitForCompletion, ClientAction action, Map activeRemoteClients, String[] inactiveRemoteClients)</TD></TR><TR><TD CLASS="l">1131</TD><TD>{</TD></TR><TR><TD CLASS="l">1132</TD><TD>        // Log information that we are sending a event.</TD></TR><TR CLASS="z"><TD CLASS="l">1133</TD><TD>        action.logBeforeSend(&#34;Local listeners first.&#34;);</TD></TR><TR><TD CLASS="l">1134</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1135</TD><TD>    if(Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1136</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>        Log.debug(this, &#34;Size of active/inactive clients:&#34; + activeRemoteClients.size() + &#34;/&#34; + inactiveRemoteClients.length);</TD></TR><TR><TD CLASS="l">1138</TD><TD>    }</TD></TR><TR><TD CLASS="l">1139</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1140</TD><TD>    int totalRemoteClients = activeRemoteClients.size() + inactiveRemoteClients.length;</TD></TR><TR><TD CLASS="l">1141</TD><TD> </TD></TR><TR><TD CLASS="l">1142</TD><TD>        // Create callback object and set it up.</TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>        TradingSessionClientAMICallback callback = TradingSessionClientAMICallback.get( totalRemoteClients, getBOHome());</TD></TR><TR CLASS="z"><TD CLASS="l">1144</TD><TD>    callback.setCompletionCallback(action);</TD></TR><TR><TD CLASS="l">1145</TD><TD> </TD></TR><TR><TD CLASS="l">1146</TD><TD>        try</TD></TR><TR><TD CLASS="l">1147</TD><TD>        {</TD></TR><TR><TD CLASS="l">1148</TD><TD>                // Execute for local listeners first. If this fails we abort.</TD></TR><TR CLASS="z"><TD CLASS="l">1149</TD><TD>                action.localAction(localClientInstance);</TD></TR><TR><TD CLASS="l">1150</TD><TD> </TD></TR><TR><TD CLASS="l">1151</TD><TD>                // Execute for remote listeners.</TD></TR><TR CLASS="z"><TD CLASS="l">1152</TD><TD>                if (totalRemoteClients == 0)</TD></TR><TR><TD CLASS="l">1153</TD><TD>                {</TD></TR><TR><TD CLASS="l">1154</TD><TD>                         // 1 call made, 1 completed, 0 exceptions, 0 negative results, 0 not available.</TD></TR><TR CLASS="z"><TD CLASS="l">1155</TD><TD>                        action.allClientsComplete(1, 1, 0, 0,0);</TD></TR><TR CLASS="z"><TD CLASS="l">1156</TD><TD>                        action.logAfterCompletion(&#34;No remote calls were made (all servers are down).&#34;);</TD></TR><TR><TD CLASS="l">1157</TD><TD>                }</TD></TR><TR><TD CLASS="l">1158</TD><TD>                else</TD></TR><TR><TD CLASS="l">1159</TD><TD>                {</TD></TR><TR><TD CLASS="l">1160</TD><TD>            //First process active remote servers and then inactive remote servers.</TD></TR><TR CLASS="z"><TD CLASS="l">1161</TD><TD>            action.logBeforeSend(&#34;(&#34; + activeRemoteClients.size() + &#34;) Remote servers.&#34;);</TD></TR><TR><TD CLASS="l">1162</TD><TD> </TD></TR><TR><TD CLASS="l">1163</TD><TD>            // Log &amp; publish an &#34;event fired&#34; notification</TD></TR><TR><TD CLASS="l">1164</TD><TD>            //</TD></TR><TR CLASS="z"><TD CLASS="l">1165</TD><TD>            action.publishEventState(TradingSessionEventStates.FIRED);</TD></TR><TR><TD CLASS="l">1166</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                        Iterator activeIter = activeRemoteClients.keySet().iterator();</TD></TR><TR><TD CLASS="l">1168</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1169</TD><TD>            TradingSessionClient client = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1170</TD><TD>            String clientId = null;</TD></TR><TR><TD CLASS="l">1171</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1172</TD><TD>            while (activeIter.hasNext())</TD></TR><TR><TD CLASS="l">1173</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1174</TD><TD>                clientId = (String) activeIter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1175</TD><TD>                                client = (TradingSessionClient) activeRemoteClients.get(clientId);</TD></TR><TR><TD CLASS="l">1176</TD><TD> </TD></TR><TR><TD CLASS="l">1177</TD><TD>                                // System exceptions can be thrown here, for some bizarre reason.</TD></TR><TR><TD CLASS="l">1178</TD><TD>                                try</TD></TR><TR><TD CLASS="l">1179</TD><TD>                                {</TD></TR><TR><TD CLASS="l">1180</TD><TD>                                // Get the handler from he orb.</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>                                AMI_TradingSessionClientHandler handler = callback.getHandler(clientId);</TD></TR><TR><TD CLASS="l">1182</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1183</TD><TD>                                        action.action(client, handler);</TD></TR><TR><TD CLASS="l">1184</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                    Log.information(this, &#34;Event has been send to :&#34; + clientId);</TD></TR><TR><TD CLASS="l">1186</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1187</TD><TD>                    catch (com.cboe.infrastructureServices.orbService.NoSuchPOAException ex)</TD></TR><TR><TD CLASS="l">1188</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                            Log.exception(this, &#34;SERIOUS ERROR (NO SUCH POA) CONNECTING TO ORB. WHILE EXECUTING ACTION &#34; + action + &#34;, EVENT FLOW WAS ABORTED.&#34;, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">1190</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1191</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1192</TD><TD>                                catch (Exception ex) // Error invoking, we will not get a callback on this.</TD></TR><TR><TD CLASS="l">1193</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>                                        callback.unknownException(&#34;Error sending event to TSS Client: &#34; + clientId, ex, clientId);</TD></TR><TR CLASS="z"><TD CLASS="l">1195</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1196</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1197</TD><TD> </TD></TR><TR><TD CLASS="l">1198</TD><TD>            //Now process for Inactive clients, if there are any</TD></TR><TR CLASS="z"><TD CLASS="l">1199</TD><TD>            if(inactiveRemoteClients.length &gt; 0)</TD></TR><TR><TD CLASS="l">1200</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1201</TD><TD>                action.logBeforeSend(&#34;(&#34; + inactiveRemoteClients.length + &#34;) Inactive Remote servers.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1202</TD><TD>                for(int k=0; k &lt; inactiveRemoteClients.length; k++)</TD></TR><TR><TD CLASS="l">1203</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>                    clientId = inactiveRemoteClients[k];</TD></TR><TR><TD CLASS="l">1205</TD><TD>                    try</TD></TR><TR><TD CLASS="l">1206</TD><TD>                    {</TD></TR><TR><TD CLASS="l">1207</TD><TD>                        //generate the failure response from the client</TD></TR><TR CLASS="z"><TD CLASS="l">1208</TD><TD>                        callback.propogateEventForInactiveOrDisabledClient(clientId);</TD></TR><TR CLASS="z"><TD CLASS="l">1209</TD><TD>                        Log.information(this, &#34;Unavailable server has been processed :&#34; + clientId );</TD></TR><TR><TD CLASS="l">1210</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>                    catch (Exception ex) // Error invoking, we will not get a callback on this.</TD></TR><TR><TD CLASS="l">1212</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1213</TD><TD>                        callback.unknownException(&#34;Error sending event to TSS Client: &#34; + clientId, ex, clientId);</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1215</TD><TD>                }</TD></TR><TR><TD CLASS="l">1216</TD><TD>            }</TD></TR><TR><TD CLASS="l">1217</TD><TD> </TD></TR><TR><TD CLASS="l">1218</TD><TD>                        // If the caller wants to wait for complettion then wait.</TD></TR><TR CLASS="z"><TD CLASS="l">1219</TD><TD>                        if (waitForCompletion)</TD></TR><TR><TD CLASS="l">1220</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1221</TD><TD>                                callback.waitForAllInvocations(amiCallbackTimerValue);</TD></TR><TR><TD CLASS="l">1222</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1223</TD><TD>                }</TD></TR><TR><TD CLASS="l">1224</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1225</TD><TD>        catch (DataValidationException ex)</TD></TR><TR><TD CLASS="l">1226</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1227</TD><TD>                Log.exception(this, &#34;SERIOUS ERROR EXECUTING LOCAL ACTION &#34; + action + &#34;. EVENT FLOW WAS ABORTED.&#34;, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">1228</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1229</TD><TD>}</TD></TR><TR><TD CLASS="l">1230</TD><TD>/**</TD></TR><TR><TD CLASS="l">1231</TD><TD> * This method is invoked when price adjustments have been completed. It will not</TD></TR><TR><TD CLASS="l">1232</TD><TD> * propagate this call to the TradingSessionClients, but will instead influence the</TD></TR><TR><TD CLASS="l">1233</TD><TD> * flow of the &#34;end of session&#34; functionality.</TD></TR><TR><TD CLASS="l">1234</TD><TD> *</TD></TR><TR><TD CLASS="l">1235</TD><TD> * @param action ClientActiona</TD></TR><TR><TD CLASS="l"><A NAME="23">1236</A></TD><TD> * @param waitForCompletion boolean</TD></TR><TR><TD CLASS="l">1237</TD><TD> */</TD></TR><TR><TD CLASS="l">1238</TD><TD>public void execute(boolean waitForCompletion, ClientAction action)</TD></TR><TR><TD CLASS="l">1239</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>    execute(waitForCompletion, action, action.getClients(ClientAction.CLIENT_STATE_TYPE_ACTIVE),</TD></TR><TR><TD CLASS="l">1241</TD><TD>             action.getClients(ClientAction.CLIENT_STATE_TYPE_INACTIVE));</TD></TR><TR CLASS="z"><TD CLASS="l">1242</TD><TD>}</TD></TR><TR><TD CLASS="l">1243</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1244</TD><TD>     * Find the trading session client for each active client and execute the event.</TD></TR><TR><TD CLASS="l">1245</TD><TD>     * @param waitForCompletion</TD></TR><TR><TD CLASS="l">1246</TD><TD>     * @param action</TD></TR><TR><TD CLASS="l">1247</TD><TD>     * @param actives</TD></TR><TR><TD CLASS="l"><A NAME="25">1248</A></TD><TD>     * @param inactives</TD></TR><TR><TD CLASS="l">1249</TD><TD>     */</TD></TR><TR><TD CLASS="l">1250</TD><TD>    private void execute(boolean waitForCompletion, ClientAction action, String[] actives, String[] inactives)</TD></TR><TR><TD CLASS="l">1251</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>        HashMap activeClients = new HashMap(actives.length);</TD></TR><TR><TD CLASS="l">1253</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1254</TD><TD>        String sessionName = action.sessionStruct.sessionName;</TD></TR><TR CLASS="z"><TD CLASS="l">1255</TD><TD>        TradingSessionClient sessionClient=null;</TD></TR><TR><TD CLASS="l">1256</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>        for(int i=0; i &lt; actives.length; i++)</TD></TR><TR><TD CLASS="l">1258</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1259</TD><TD>            sessionClient = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1260</TD><TD>            sessionClient = registrationMapHome.getTradingSessionClientForClient(sessionName, actives[i]);</TD></TR><TR><TD CLASS="l">1261</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>            if(sessionClient != null)</TD></TR><TR><TD CLASS="l">1263</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1264</TD><TD>                activeClients.put(actives[i], sessionClient);</TD></TR><TR><TD CLASS="l">1265</TD><TD>            }</TD></TR><TR><TD CLASS="l">1266</TD><TD>            else</TD></TR><TR><TD CLASS="l">1267</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1268</TD><TD>                Log.alarm(this, &#34;Could not find Trading session client, Will not send the event &#34; + action + &#34; to client/session:&#34; + actives[i] + &#34;/&#34; + sessionName);</TD></TR><TR><TD CLASS="l">1269</TD><TD>            }</TD></TR><TR><TD CLASS="l">1270</TD><TD>        }</TD></TR><TR><TD CLASS="l">1271</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1272</TD><TD>        execute(waitForCompletion, action, activeClients, inactives);</TD></TR><TR CLASS="z"><TD CLASS="l">1273</TD><TD>    }</TD></TR><TR><TD CLASS="l">1274</TD><TD> </TD></TR><TR><TD CLASS="l">1275</TD><TD>/**</TD></TR><TR><TD CLASS="l">1276</TD><TD> * This method is invoked when price adjustments have been completed. It will not</TD></TR><TR><TD CLASS="l">1277</TD><TD> * propagate this call to the TradingSessionClients, but will instead influence the</TD></TR><TR><TD CLASS="l">1278</TD><TD> * flow of the &#34;end of session&#34; functionality.</TD></TR><TR><TD CLASS="l">1279</TD><TD> *</TD></TR><TR><TD CLASS="l">1280</TD><TD> * @param action ClientActiona</TD></TR><TR><TD CLASS="l"><A NAME="26">1281</A></TD><TD> * @param waitForCompletion boolean</TD></TR><TR><TD CLASS="l">1282</TD><TD> */</TD></TR><TR><TD CLASS="l">1283</TD><TD>private void execute(boolean waitForCompletion, TradingSessionEventType eventType, TradingSessionStruct sessionStruct, String contextString)</TD></TR><TR><TD CLASS="l">1284</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1285</TD><TD>        TradingSessionClientAction action = new TradingSessionClientAction(this, eventType, sessionStruct, contextString,</TD></TR><TR><TD CLASS="l">1286</TD><TD>            registrationMapHome.getActiveClientsForSession(sessionStruct.sessionName), registrationMapHome.getInactiveClientsForSession(sessionStruct.sessionName));</TD></TR><TR CLASS="z"><TD CLASS="l">1287</TD><TD>        execute(waitForCompletion, action);</TD></TR><TR CLASS="z"><TD CLASS="l">1288</TD><TD>}</TD></TR><TR><TD CLASS="l">1289</TD><TD>/**</TD></TR><TR><TD CLASS="l">1290</TD><TD> *  Force the firing of any of the events types from TradingSessionEventType.</TD></TR><TR><TD CLASS="l">1291</TD><TD> *</TD></TR><TR><TD CLASS="l">1292</TD><TD> *  @param eventType: the enumerated value associated with the given</TD></TR><TR><TD CLASS="l">1293</TD><TD> *    TradingSessionEventType, accessed via the getEnumValue() method.</TD></TR><TR><TD CLASS="l">1294</TD><TD> *    For example, TradingSessionEventType.CLOSE_SESSION.getEnumValue()</TD></TR><TR><TD CLASS="l">1295</TD><TD> *</TD></TR><TR><TD CLASS="l">1296</TD><TD> *  @param sessionKey: the key associated with the trading session that this</TD></TR><TR><TD CLASS="l">1297</TD><TD> *    event is being fired for.</TD></TR><TR><TD CLASS="l">1298</TD><TD> *</TD></TR><TR><TD CLASS="l">1299</TD><TD> *  @param contextString: some events require a context string (for example,</TD></TR><TR><TD CLASS="l">1300</TD><TD> *    SESSION_LOST requires the session name).</TD></TR><TR><TD CLASS="l">1301</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="29">1302</A></TD><TD> *  @return boolean the value is pretty useless. AMI calls may not complete.</TD></TR><TR><TD CLASS="l">1303</TD><TD> */</TD></TR><TR><TD CLASS="l">1304</TD><TD>public boolean fireEvent(int eventType, String sessionName, String contextString) throws TransactionFailedException,DataValidationException</TD></TR><TR><TD CLASS="l">1305</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1306</TD><TD>        return fireEvent(eventType, sessionName, contextString, false, false); // don't wait and not vetoable</TD></TR><TR><TD CLASS="l">1307</TD><TD>}</TD></TR><TR><TD CLASS="l">1308</TD><TD> </TD></TR><TR><TD CLASS="l">1309</TD><TD>/**</TD></TR><TR><TD CLASS="l">1310</TD><TD> * Locks service for session and business day updates.</TD></TR><TR><TD CLASS="l">1311</TD><TD> *</TD></TR><TR><TD CLASS="l">1312</TD><TD> * @exception TransactionFailedException if lock cannot be obtained</TD></TR><TR><TD CLASS="l">1313</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="85">1314</A></TD><TD>private void lockServiceForUpdates(String lockReason) throws TransactionFailedException</TD></TR><TR><TD CLASS="l">1315</TD><TD>{</TD></TR><TR><TD CLASS="l">1316</TD><TD>    try</TD></TR><TR><TD CLASS="l">1317</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>        lockManager.obtainGlobalLock(0/*nowait*/, lockReason);</TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>        Log.information(this, &#34;Universal update lock acquired for: &#34; + lockReason);</TD></TR><TR><TD CLASS="l">1320</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>    catch (LockManagerException ex)</TD></TR><TR><TD CLASS="l">1322</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1323</TD><TD>        throw ExceptionBuilder.transactionFailedException(&#34;Operation cannot be done: &#34; + ex.getMessage(), 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1325</TD><TD>}</TD></TR><TR><TD CLASS="l">1326</TD><TD> </TD></TR><TR><TD CLASS="l">1327</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="84">1328</A></TD><TD>     *  Obtain a specific lock.</TD></TR><TR><TD CLASS="l">1329</TD><TD>     */</TD></TR><TR><TD CLASS="l">1330</TD><TD>    private void lockServiceForUpdates(String[] clients, String lockReason) throws TransactionFailedException</TD></TR><TR><TD CLASS="l">1331</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1332</TD><TD>        for (int i=0; i &lt; clients.length; i++)</TD></TR><TR><TD CLASS="l">1333</TD><TD>        {</TD></TR><TR><TD CLASS="l">1334</TD><TD>            try</TD></TR><TR><TD CLASS="l">1335</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1336</TD><TD>                lockManager.obtainLock(clients[i], 0/*noWait*/, lockReason);</TD></TR><TR><TD CLASS="l">1337</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1338</TD><TD>            catch (LockManagerException ex)</TD></TR><TR><TD CLASS="l">1339</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>                Log.alarm(this, ex.getMessage());</TD></TR><TR CLASS="z"><TD CLASS="l">1341</TD><TD>                for (int j=0; j &lt; i; j++)</TD></TR><TR><TD CLASS="l">1342</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>                    Log.alarm(this, &#34;  Releasing lock '&#34; + clients[j] + &#34;' due to failure to obtain lock '&#34; + clients[i] + &#34;'&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1344</TD><TD>                    lockManager.releaseLock(clients[j]);</TD></TR><TR><TD CLASS="l">1345</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1346</TD><TD>                throw ExceptionBuilder.transactionFailedException(&#34;Operation cannot be done: &#34; + ex.getMessage(), 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1347</TD><TD>            }</TD></TR><TR><TD CLASS="l">1348</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1349</TD><TD>        Log.information(this, &#34;Obtained lock for reason '&#34; + lockReason + &#34;' for clients &#34; + Arrays.asList(clients));</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="89">1351</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1352</TD><TD> * match the trading session event type with the event type number</TD></TR><TR><TD CLASS="l">1353</TD><TD> */</TD></TR><TR><TD CLASS="l">1354</TD><TD> private TradingSessionEventType matchTradingSessionEventTypeByNumber(int eventType){</TD></TR><TR CLASS="z"><TD CLASS="l">1355</TD><TD>        TradingSessionEventType type=null;</TD></TR><TR CLASS="z"><TD CLASS="l">1356</TD><TD>        Enumeration enum1 = TradingSessionEventType.elements();</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>        while (enum1.hasMoreElements())</TD></TR><TR><TD CLASS="l">1358</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1359</TD><TD>                TradingSessionEventType t = (TradingSessionEventType)enum1.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>                if (t.getEnumValue() == eventType)</TD></TR><TR><TD CLASS="l">1361</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>                        type = t;</TD></TR><TR CLASS="z"><TD CLASS="l">1363</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">1364</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1365</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1366</TD><TD>    return type;</TD></TR><TR><TD CLASS="l">1367</TD><TD> }</TD></TR><TR><TD CLASS="l">1368</TD><TD> </TD></TR><TR><TD CLASS="l">1369</TD><TD>/**</TD></TR><TR><TD CLASS="l">1370</TD><TD> *  Force the firing of any of the events types from TradingSessionEventType.</TD></TR><TR><TD CLASS="l">1371</TD><TD> *</TD></TR><TR><TD CLASS="l">1372</TD><TD> *  @param eventType: the enumerated value associated with the given</TD></TR><TR><TD CLASS="l">1373</TD><TD> *    TradingSessionEventType, accessed via the getEnumValue() method.</TD></TR><TR><TD CLASS="l">1374</TD><TD> *    For example, TradingSessionEventType.CLOSE_SESSION.getEnumValue()</TD></TR><TR><TD CLASS="l">1375</TD><TD> *</TD></TR><TR><TD CLASS="l">1376</TD><TD> *  @param sessionKey: the key associated with the trading session that this</TD></TR><TR><TD CLASS="l">1377</TD><TD> *    event is being fired for.</TD></TR><TR><TD CLASS="l">1378</TD><TD> *</TD></TR><TR><TD CLASS="l">1379</TD><TD> *  @param contextString: some events require a context string (for example,</TD></TR><TR><TD CLASS="l">1380</TD><TD> *    SESSION_LOST requires the session name).</TD></TR><TR><TD CLASS="l">1381</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="2a">1382</A></TD><TD> *  @return boolean the value is pretty useless. AMI calls may not complete.</TD></TR><TR><TD CLASS="l">1383</TD><TD> */</TD></TR><TR><TD CLASS="l">1384</TD><TD>public boolean fireEvent(int eventType, String sessionName, String contextString, boolean waitForCompletion, boolean vetoable) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">1385</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1386</TD><TD>    return fireEvent(eventType, sessionName, contextString, waitForCompletion, vetoable,</TD></TR><TR><TD CLASS="l">1387</TD><TD>            registrationMapHome.getActiveClientsForSession(sessionName), registrationMapHome.getInactiveClientsForSession(sessionName));</TD></TR><TR><TD CLASS="l"><A NAME="2b">1388</A></TD><TD>}</TD></TR><TR><TD CLASS="l">1389</TD><TD> </TD></TR><TR><TD CLASS="l">1390</TD><TD>private boolean fireEvent(int eventType, String sessionName, String contextString, boolean waitForCompletion, boolean vetoable, String[] activeClients, String[] inactiveClients) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">1391</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1392</TD><TD>    TradingSessionEventType type = matchTradingSessionEventTypeByNumber(eventType);</TD></TR><TR CLASS="z"><TD CLASS="l">1393</TD><TD>        if (type == null){</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Error firing event of type (&#34; + eventType + &#34;). Event type not found.&#34;,0);</TD></TR><TR><TD CLASS="l">1395</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1396</TD><TD>    TradingSessionStruct sessionStruct = getEventTradingSesssion(sessionName);</TD></TR><TR><TD CLASS="l">1397</TD><TD>        // create the appropriate action to deal with the event.</TD></TR><TR><TD CLASS="l">1398</TD><TD>        TradingSessionClientAction action;</TD></TR><TR CLASS="z"><TD CLASS="l">1399</TD><TD>        if (vetoable){</TD></TR><TR CLASS="z"><TD CLASS="l">1400</TD><TD>                action = new TradingSessionVetoableClientAction(this, type, sessionStruct ,contextString, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">1401</TD><TD>        }</TD></TR><TR><TD CLASS="l">1402</TD><TD>         else{</TD></TR><TR CLASS="z"><TD CLASS="l">1403</TD><TD>                action = new TradingSessionClientAction(this, type, sessionStruct,contextString, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">1404</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1405</TD><TD>        execute(waitForCompletion, action);</TD></TR><TR CLASS="z"><TD CLASS="l">1406</TD><TD>        if (!waitForCompletion || action.allClientsComplete()){</TD></TR><TR CLASS="z"><TD CLASS="l">1407</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">1408</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1409</TD><TD>        String errMsg = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1410</TD><TD>        if (action.getNbrCompleted() != action.getNbrCalled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1411</TD><TD>                errMsg = &#34;Not all clients completed, Nbr called/completed: &#34; + action.getNbrCalled() + &#34;/&#34; + action.getNbrCompleted();</TD></TR><TR><TD CLASS="l">1412</TD><TD>        }</TD></TR><TR><TD CLASS="l">1413</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1414</TD><TD>                if (action.getNbrExceptions() != 0)</TD></TR><TR><TD CLASS="l">1415</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1416</TD><TD>                        errMsg = action.getNbrExceptions() + &#34; clients had errors.&#34;;</TD></TR><TR><TD CLASS="l">1417</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1418</TD><TD>                else if (action.getNbrNegativeResults() != 0)</TD></TR><TR><TD CLASS="l">1419</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1420</TD><TD>                        errMsg = action.getNbrNegativeResults() + &#34; vetoed the action.&#34;;</TD></TR><TR><TD CLASS="l">1421</TD><TD>                }</TD></TR><TR><TD CLASS="l">1422</TD><TD>                else</TD></TR><TR><TD CLASS="l">1423</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1424</TD><TD>                        errMsg = &#34;Unknown internal error, all clients completed without exceptions/vetos yet the program says the action did not complete.&#34;;</TD></TR><TR><TD CLASS="l">1425</TD><TD>                }</TD></TR><TR><TD CLASS="l">1426</TD><TD>        }</TD></TR><TR><TD CLASS="l">1427</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1428</TD><TD>    Log.information(&#34;Action&#34; + action + &#34;. Not completed successfully. &#34; + errMsg);</TD></TR><TR CLASS="z"><TD CLASS="l">1429</TD><TD>    throw ExceptionBuilder.transactionFailedException(&#34;Action&#34; + action + &#34;. Not completed successfully. &#34; + errMsg,0);</TD></TR><TR><TD CLASS="l">1430</TD><TD>}</TD></TR><TR><TD CLASS="l">1431</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="94">1432</A></TD><TD> * Log &amp; publish an &#34;event fired&#34; notification</TD></TR><TR><TD CLASS="l">1433</TD><TD> */</TD></TR><TR><TD CLASS="l">1434</TD><TD>public TradingSessionEventHistoryEntry publishEventState(String sessionName, short eventType, String contextString, short eventState, Map clientStates)</TD></TR><TR><TD CLASS="l">1435</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>    boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1437</TD><TD>    TradingSessionEventHistoryEntry entry=null;</TD></TR><TR><TD CLASS="l">1438</TD><TD>    try</TD></TR><TR><TD CLASS="l">1439</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">1441</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1442</TD><TD>        long now = FoundationFramework.getInstance().getTimeService().getCurrentDateTime();</TD></TR><TR CLASS="z"><TD CLASS="l">1443</TD><TD>        entry = getEventHistoryHome().create(sessionName, now, eventType, eventState, contextString, clientStates);</TD></TR><TR><TD CLASS="l">1444</TD><TD> </TD></TR><TR><TD CLASS="l">1445</TD><TD>        // set the event group for the history event.</TD></TR><TR CLASS="z"><TD CLASS="l">1446</TD><TD>        entry.setEventGroup(getEventGroup(sessionName, eventType).toString());</TD></TR><TR><TD CLASS="l">1447</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1448</TD><TD>        Iterator historyDetails = entry.getHistoryDetails().iterator();</TD></TR><TR><TD CLASS="l">1449</TD><TD>        TradingSessionEventHistoryDetail  historyDetail;</TD></TR><TR CLASS="z"><TD CLASS="l">1450</TD><TD>        while(historyDetails.hasNext())</TD></TR><TR><TD CLASS="l">1451</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1452</TD><TD>            historyDetail = (TradingSessionEventHistoryDetail) historyDetails.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1453</TD><TD>            registrationMapHome.updateHistoryDetailForClient(sessionName, historyDetail.getClientName(), historyDetail);</TD></TR><TR><TD CLASS="l">1454</TD><TD>        }</TD></TR><TR><TD CLASS="l">1455</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1456</TD><TD>            TradingSessionEventStateConsumer channel = getTradingSessionEventStatePublisher();</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>        if (channel != null)</TD></TR><TR><TD CLASS="l">1458</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1459</TD><TD>            channel.acceptTradingSessionEventStateV2(getEventHistoryHome().convertToV2Struct(entry), true/*allServers*/);</TD></TR><TR CLASS="z"><TD CLASS="l">1460</TD><TD>            if(doublePublishSessionEventHistory)</TD></TR><TR><TD CLASS="l">1461</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1462</TD><TD>                channel.acceptTradingSessionEventState(getEventHistoryHome().convertToStruct(entry));</TD></TR><TR><TD CLASS="l">1463</TD><TD>            }</TD></TR><TR><TD CLASS="l">1464</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1465</TD><TD>            if(Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1466</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1467</TD><TD>                Log.debug(this, &#34;Published TradingSessionEventHistory for event/state/session&#34; + eventType + &#34;/&#34; + eventState + &#34;/&#34; + sessionName);</TD></TR><TR><TD CLASS="l">1468</TD><TD>            }</TD></TR><TR><TD CLASS="l">1469</TD><TD>        }</TD></TR><TR><TD CLASS="l">1470</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1471</TD><TD>        success = Transaction.commit();</TD></TR><TR><TD CLASS="l">1472</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1473</TD><TD>    catch (Exception ex)</TD></TR><TR><TD CLASS="l">1474</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1475</TD><TD>        Log.exception(&#34;Unknown error creating event log entry&#34;, ex);</TD></TR><TR><TD CLASS="l">1476</TD><TD>    }</TD></TR><TR><TD CLASS="l">1477</TD><TD>    finally</TD></TR><TR><TD CLASS="l">1478</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1479</TD><TD>        if (!success)</TD></TR><TR><TD CLASS="l">1480</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1481</TD><TD>            Log.information(this, &#34;Rolling back transaction for event state change log.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1482</TD><TD>            Transaction.rollback();</TD></TR><TR><TD CLASS="l">1483</TD><TD>        }</TD></TR><TR><TD CLASS="l">1484</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1485</TD><TD>    return entry;</TD></TR><TR><TD CLASS="l"><A NAME="95">1486</A></TD><TD>}</TD></TR><TR><TD CLASS="l">1487</TD><TD> </TD></TR><TR><TD CLASS="l">1488</TD><TD>    public void publishIncrementalEventState(TradingSessionEventHistoryEntry baseHistoryEntry, String clientName, short state)</TD></TR><TR><TD CLASS="l">1489</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1490</TD><TD>        TradingSessionEventStateConsumer channel = getTradingSessionEventStatePublisher();</TD></TR><TR CLASS="z"><TD CLASS="l">1491</TD><TD>        boolean success = false;</TD></TR><TR><TD CLASS="l">1492</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1493</TD><TD>        TradingSessionEventHistoryEntry incrementalHistory = null;</TD></TR><TR><TD CLASS="l">1494</TD><TD>        try</TD></TR><TR><TD CLASS="l">1495</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1496</TD><TD>            Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1497</TD><TD>            incrementalHistory = getEventHistoryHome().updateStateForHistoryDetail(baseHistoryEntry, clientName, state);</TD></TR><TR><TD CLASS="l">1498</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1499</TD><TD>            Iterator iter = incrementalHistory.getHistoryDetails().iterator();</TD></TR><TR><TD CLASS="l">1500</TD><TD>            TradingSessionEventHistoryDetail detail;</TD></TR><TR CLASS="z"><TD CLASS="l">1501</TD><TD>            while(iter.hasNext())</TD></TR><TR><TD CLASS="l">1502</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1503</TD><TD>                detail = (TradingSessionEventHistoryDetail) iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1504</TD><TD>                registrationMapHome.updateHistoryDetailForClient(incrementalHistory.getSessionName(), clientName, detail);</TD></TR><TR><TD CLASS="l">1505</TD><TD>            }</TD></TR><TR><TD CLASS="l">1506</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1507</TD><TD>            if (channel != null)</TD></TR><TR><TD CLASS="l">1508</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1509</TD><TD>                channel.acceptTradingSessionEventStateV2(getEventHistoryHome().convertToV2Struct(incrementalHistory), false/*allServers*/);</TD></TR><TR><TD CLASS="l">1510</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1511</TD><TD>                if(Log.isDebugOn())</TD></TR><TR><TD CLASS="l">1512</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1513</TD><TD>                    Log.debug(this, &#34;Published incremental TradingSessionEventHistory for event/state/session&#34; + incrementalHistory.getEventType()+ &#34;/&#34; + incrementalHistory.getEventState() + &#34;/&#34; + incrementalHistory.getSessionName());</TD></TR><TR><TD CLASS="l">1514</TD><TD>                }</TD></TR><TR><TD CLASS="l">1515</TD><TD>            }</TD></TR><TR><TD CLASS="l">1516</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1517</TD><TD>            success = Transaction.commit();</TD></TR><TR><TD CLASS="l">1518</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1519</TD><TD>        catch (Exception ex)</TD></TR><TR><TD CLASS="l">1520</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1521</TD><TD>            Log.exception(&#34;Unknown error creating event log entry&#34;, ex);</TD></TR><TR><TD CLASS="l">1522</TD><TD>        }</TD></TR><TR><TD CLASS="l">1523</TD><TD>        finally</TD></TR><TR><TD CLASS="l">1524</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1525</TD><TD>            if (!success)</TD></TR><TR><TD CLASS="l">1526</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1527</TD><TD>                Log.information(this, &#34;Rolling back transaction for event state change log.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1528</TD><TD>                Transaction.rollback();</TD></TR><TR><TD CLASS="l">1529</TD><TD>            }</TD></TR><TR><TD CLASS="l">1530</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1531</TD><TD>    }</TD></TR><TR><TD CLASS="l">1532</TD><TD> </TD></TR><TR><TD CLASS="l">1533</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1534</TD><TD>     * From the given session and even type find out the event group in which the passed event belongs.</TD></TR><TR><TD CLASS="l">1535</TD><TD>     * This will use various strategies configured for eos,eod etc.</TD></TR><TR><TD CLASS="l">1536</TD><TD>     * NOTE - This code assumes that order of the code will not be changed, Please be carefull before changing the order of code.</TD></TR><TR><TD CLASS="l">1537</TD><TD>     * @param sessionName</TD></TR><TR><TD CLASS="l">1538</TD><TD>     * @param event</TD></TR><TR><TD CLASS="l">1539</TD><TD>     * @return</TD></TR><TR><TD CLASS="l"><A NAME="4e">1540</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1541</TD><TD> </TD></TR><TR><TD CLASS="l">1542</TD><TD>    private TradingSessionEventGroupType getEventGroup(String sessionName, int event)</TD></TR><TR><TD CLASS="l">1543</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1544</TD><TD>        return strategyFactory.getEventGroup(sessionName, event);</TD></TR><TR><TD CLASS="l">1545</TD><TD>    }</TD></TR><TR><TD CLASS="l">1546</TD><TD> </TD></TR><TR><TD CLASS="l">1547</TD><TD> </TD></TR><TR><TD CLASS="l">1548</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="6d">1549</A></TD><TD> * Return all templates belonging to the given group.</TD></TR><TR><TD CLASS="l">1550</TD><TD> */</TD></TR><TR><TD CLASS="l">1551</TD><TD>public TradingSessionElementTemplateStruct[] getTemplatesForSession(String sessionName) throws SystemException, CommunicationException, AuthorizationException</TD></TR><TR><TD CLASS="l">1552</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1553</TD><TD>        TradingSessionElementTemplate[] sessionTemplates = templateHome.findBySession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1554</TD><TD>    return templateHome.toStructs(sessionTemplates);</TD></TR><TR><TD CLASS="l">1555</TD><TD>}</TD></TR><TR><TD CLASS="l">1556</TD><TD>/**</TD></TR><TR><TD CLASS="l">1557</TD><TD> * Gets trading sessions that class may participate in.</TD></TR><TR><TD CLASS="l"><A NAME="77">1558</A></TD><TD> *</TD></TR><TR><TD CLASS="l">1559</TD><TD> * @param classKey key of class</TD></TR><TR><TD CLASS="l">1560</TD><TD> */</TD></TR><TR><TD CLASS="l">1561</TD><TD>public TradingSessionStruct[] getTradingSessionsForClass(int classKey) throws DataValidationException {</TD></TR><TR CLASS="z"><TD CLASS="l">1562</TD><TD>    if (classKey == 0)</TD></TR><TR><TD CLASS="l">1563</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1564</TD><TD>        throw ExceptionBuilder.dataValidationException(&#34;Class key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">1565</TD><TD>    }</TD></TR><TR><TD CLASS="l">1566</TD><TD>    // Find sessions based on class assignments to templates</TD></TR><TR CLASS="z"><TD CLASS="l">1567</TD><TD>    TemplateClass[] assignments = templateClassHome.findByClass(classKey);</TD></TR><TR><TD CLASS="l">1568</TD><TD>    // since class can only be assigned once in a session, we can</TD></TR><TR><TD CLASS="l">1569</TD><TD>    // create the result directly from the assignments</TD></TR><TR CLASS="z"><TD CLASS="l">1570</TD><TD>    TradingSessionStruct[] result = new TradingSessionStruct[assignments.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1571</TD><TD>    for (int i = 0; i &lt; assignments.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1572</TD><TD>        result[i] = sessionHome.toStruct(assignments[i].getTemplate().getSession());</TD></TR><TR><TD CLASS="l">1573</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1574</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1575</TD><TD>}</TD></TR><TR><TD CLASS="l">1576</TD><TD>/**</TD></TR><TR><TD CLASS="l">1577</TD><TD> * Return all known templates to the caller.</TD></TR><TR><TD CLASS="l"><A NAME="2f">1578</A></TD><TD> * @param TradingSessionElementTemplateStruct[] the structures.</TD></TR><TR><TD CLASS="l">1579</TD><TD> */</TD></TR><TR><TD CLASS="l">1580</TD><TD>public TradingSessionElementTemplateStruct[] getAllTemplates()</TD></TR><TR><TD CLASS="l">1581</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1582</TD><TD>    TradingSessionElementTemplate[] templates = templateHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1583</TD><TD>    return templateHome.toStructs(templates);</TD></TR><TR><TD CLASS="l">1584</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="30">1585</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1586</TD><TD> * Gets home for session element classes.</TD></TR><TR><TD CLASS="l">1587</TD><TD> */</TD></TR><TR><TD CLASS="l">1588</TD><TD>private BusinessDayHome getBusinessDayHome() {</TD></TR><TR CLASS="z"><TD CLASS="l">1589</TD><TD>    if (businessDayHome == null) {</TD></TR><TR><TD CLASS="l">1590</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1591</TD><TD>            businessDayHome = (BusinessDayHome) HomeFactory.getInstance().findHome(BusinessDayHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">1592</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1593</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1594</TD><TD>            throw new NullPointerException(&#34;Cannot get business day home&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1595</TD><TD>        }</TD></TR><TR><TD CLASS="l">1596</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>    return businessDayHome;</TD></TR><TR><TD CLASS="l">1598</TD><TD>}</TD></TR><TR><TD CLASS="l">1599</TD><TD>/**</TD></TR><TR><TD CLASS="l">1600</TD><TD> * Return the ClassStruct array for the given sessionKey.</TD></TR><TR><TD CLASS="l">1601</TD><TD> *</TD></TR><TR><TD CLASS="l">1602</TD><TD> * @param sessionKey - the session key to get the classes for.  The session need not be &#34;OPEN&#34;.</TD></TR><TR><TD CLASS="l">1603</TD><TD> * @return ClassStruct[] - the array of classes associated with the session.</TD></TR><TR><TD CLASS="l">1604</TD><TD> * @exception NotFoundException - thrown if the given sessionKey is not found in the current business day.</TD></TR><TR><TD CLASS="l"><A NAME="3d">1605</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1606</TD><TD>public SessionClassDetailStruct[] getClassesForElement(int elementKey)</TD></TR><TR><TD CLASS="l">1607</TD><TD>         throws DataValidationException</TD></TR><TR><TD CLASS="l">1608</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1609</TD><TD>        return this.getCachedElementClasses(elementKey);</TD></TR><TR><TD CLASS="l">1610</TD><TD>}</TD></TR><TR><TD CLASS="l">1611</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3e">1612</A></TD><TD>private SessionClassDetailStruct[] getClassesForElementPrivate(int elementKey)</TD></TR><TR><TD CLASS="l">1613</TD><TD>throws DataValidationException</TD></TR><TR><TD CLASS="l">1614</TD><TD>{</TD></TR><TR><TD CLASS="l">1615</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">1616</TD><TD>        TradingSessionElement element = elementHome.findByKey(elementKey);</TD></TR><TR CLASS="z"><TD CLASS="l">1617</TD><TD>        SessionElementClass[] classes = element.getClasses();</TD></TR><TR CLASS="z"><TD CLASS="l">1618</TD><TD>        return elementClassHome.toStructs(classes);</TD></TR><TR><TD CLASS="l">1619</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1620</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1621</TD><TD>        throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">1622</TD><TD>    }</TD></TR><TR><TD CLASS="l">1623</TD><TD>}</TD></TR><TR><TD CLASS="l">1624</TD><TD>/**</TD></TR><TR><TD CLASS="l">1625</TD><TD> * Gets all classes for the session.</TD></TR><TR><TD CLASS="l">1626</TD><TD> *</TD></TR><TR><TD CLASS="l">1627</TD><TD> * @param sessionName name of the session</TD></TR><TR><TD CLASS="l"><A NAME="3f">1628</A></TD><TD> * @return classes defined for the session elements of the session</TD></TR><TR><TD CLASS="l">1629</TD><TD> */</TD></TR><TR><TD CLASS="l">1630</TD><TD>public SessionClassDetailStruct[] getClassesForSession(String sessionName)</TD></TR><TR><TD CLASS="l">1631</TD><TD>    throws DataValidationException {</TD></TR><TR CLASS="z"><TD CLASS="l">1632</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1633</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1634</TD><TD>    ArrayList classDetail = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1635</TD><TD>    for (int i = 0; i &lt; elements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1636</TD><TD>        classDetail.addAll(Arrays.asList(getClassesForElement(elements[i].getElementKey())));</TD></TR><TR><TD CLASS="l">1637</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1638</TD><TD>    SessionClassDetailStruct[] result = new SessionClassDetailStruct[classDetail.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1639</TD><TD>    classDetail.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1640</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1641</TD><TD>}</TD></TR><TR><TD CLASS="l">1642</TD><TD> </TD></TR><TR><TD CLASS="l">1643</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1644</TD><TD>     * Get all classes for the given session name and group name</TD></TR><TR><TD CLASS="l">1645</TD><TD>     * @param sessionName</TD></TR><TR><TD CLASS="l">1646</TD><TD>     * @param groupName</TD></TR><TR><TD CLASS="l">1647</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">1648</TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l">1649</TD><TD>     * @throws CommunicationException</TD></TR><TR><TD CLASS="l">1650</TD><TD>     * @throws AuthorizationException</TD></TR><TR><TD CLASS="l">1651</TD><TD>     * @throws DataValidationException</TD></TR><TR><TD CLASS="l"><A NAME="40">1652</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1653</TD><TD>    public SessionClassDetailStruct[] getClassesForSessionByGroup(String sessionName, String groupName)</TD></TR><TR><TD CLASS="l">1654</TD><TD>            throws SystemException, CommunicationException, AuthorizationException, DataValidationException</TD></TR><TR><TD CLASS="l">1655</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1656</TD><TD>        verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1657</TD><TD>        int[] classesInGroup = getProductConfigurationService().getProductClassesForGroup(groupName);</TD></TR><TR><TD CLASS="l">1658</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1659</TD><TD>        TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1660</TD><TD>        IntHashMap sessionClassHash = new IntHashMap();</TD></TR><TR CLASS="z"><TD CLASS="l">1661</TD><TD>        ArrayList classDetail = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1662</TD><TD>        for (int i = 0; i &lt; elements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1663</TD><TD>            SessionClassDetailStruct[] sessionElementClasses = getClassesForElement(elements[i].getElementKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1664</TD><TD>            for(int k = 0; k &lt; sessionElementClasses.length; k++){</TD></TR><TR CLASS="z"><TD CLASS="l">1665</TD><TD>                sessionClassHash.put(sessionElementClasses[k].classDetail.classStruct.classKey, sessionElementClasses[k]);</TD></TR><TR><TD CLASS="l">1666</TD><TD>            }</TD></TR><TR><TD CLASS="l">1667</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1668</TD><TD>        for(int m = 0; m &lt; classesInGroup.length; m++){</TD></TR><TR CLASS="z"><TD CLASS="l">1669</TD><TD>            Object classDetailStruct = sessionClassHash.get(classesInGroup[m]);</TD></TR><TR CLASS="z"><TD CLASS="l">1670</TD><TD>            if(classDetailStruct != null){</TD></TR><TR CLASS="z"><TD CLASS="l">1671</TD><TD>                classDetail.add(classDetailStruct);</TD></TR><TR><TD CLASS="l">1672</TD><TD>            }</TD></TR><TR><TD CLASS="l">1673</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1674</TD><TD>        SessionClassDetailStruct[] result = new SessionClassDetailStruct[classDetail.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1675</TD><TD>        classDetail.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1676</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1677</TD><TD>    }</TD></TR><TR><TD CLASS="l">1678</TD><TD> </TD></TR><TR><TD CLASS="l">1679</TD><TD> </TD></TR><TR><TD CLASS="l">1680</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1681</TD><TD> * Gets all classes simple information for the session</TD></TR><TR><TD CLASS="l">1682</TD><TD> *</TD></TR><TR><TD CLASS="l">1683</TD><TD> * @param sessionName name of the session</TD></TR><TR><TD CLASS="l">1684</TD><TD> * @return com.cboe.idl.cmiSession.SessionClassStruct[] all classes defined for the session elements of the session</TD></TR><TR><TD CLASS="l">1685</TD><TD> * It is different from getClassesForSession which returns SessionClassdetailStruct</TD></TR><TR><TD CLASS="l"><A NAME="39">1686</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1687</TD><TD> public SessionClassStruct[] getClassesBySession(String sessionName)</TD></TR><TR><TD CLASS="l">1688</TD><TD>    throws DataValidationException</TD></TR><TR><TD CLASS="l">1689</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1690</TD><TD>     return getClassesBySession(sessionName, true);</TD></TR><TR><TD CLASS="l">1691</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="3a">1692</A></TD><TD> </TD></TR><TR><TD CLASS="l">1693</TD><TD> protected final SessionClassStruct[] getClassesBySession(String sessionName, boolean includeReportingClasses)</TD></TR><TR><TD CLASS="l">1694</TD><TD> throws DataValidationException</TD></TR><TR><TD CLASS="l">1695</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1696</TD><TD>verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1697</TD><TD>TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1698</TD><TD>ArrayList sessionClassesList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1699</TD><TD>for (int i = 0; i &lt; elements.length; i++)</TD></TR><TR><TD CLASS="l">1700</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1701</TD><TD>    TradingSessionElementStruct elementStruct = elementHome.toStruct(elements[i], includeReportingClasses);</TD></TR><TR><TD CLASS="l">1702</TD><TD>    //obtain the simple class structs from the detail class structs</TD></TR><TR CLASS="z"><TD CLASS="l">1703</TD><TD>    SessionClassStruct[] simpleClasses = new SessionClassStruct[elementStruct.elementClasses.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1704</TD><TD>    for ( int j =0; j&lt; elementStruct.elementClasses.length; j++)</TD></TR><TR><TD CLASS="l">1705</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1706</TD><TD>        simpleClasses[j] = elementStruct.elementClasses[j];</TD></TR><TR><TD CLASS="l">1707</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1708</TD><TD>    sessionClassesList.addAll(Arrays.asList(simpleClasses));</TD></TR><TR><TD CLASS="l">1709</TD><TD>}</TD></TR><TR><TD CLASS="l">1710</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1711</TD><TD>  SessionClassStruct[] result = new SessionClassStruct[sessionClassesList.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1712</TD><TD>  sessionClassesList.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1713</TD><TD>  return result;</TD></TR><TR><TD CLASS="l">1714</TD><TD>}</TD></TR><TR><TD CLASS="l">1715</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3c">1716</A></TD><TD> </TD></TR><TR><TD CLASS="l">1717</TD><TD>protected final SessionClassStruct[] getClassesBySessionWithParallelThreads(String sessionName, final boolean includeReportingClasses)</TD></TR><TR><TD CLASS="l">1718</TD><TD>throws DataValidationException</TD></TR><TR><TD CLASS="l">1719</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1720</TD><TD>        Log.information(&#34;getClassesBySessionWithParallelThreads start&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>        verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1722</TD><TD>        final TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR><TD CLASS="l">1723</TD><TD>        </TD></TR><TR><TD CLASS="l">1724</TD><TD>        TradingSessionThreadPoolHome threadPoolHome;</TD></TR><TR><TD CLASS="l">1725</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1726</TD><TD>                 threadPoolHome = (TradingSessionThreadPoolHome) HomeFactory.getInstance().findHome(TradingSessionThreadPoolHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">1727</TD><TD>        } catch (CBOELoggableException e1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1728</TD><TD>                threadPoolHome = new TradingSessionThreadPoolHomeImpl();</TD></TR><TR CLASS="z"><TD CLASS="l">1729</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1730</TD><TD>        ThreadPoolExecutor threadPool = threadPoolHome.findSessionTemplateThreadPool();</TD></TR><TR><TD CLASS="l">1731</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1732</TD><TD>        final ArrayList sessionClassesList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1733</TD><TD>        Runnable[] workers = new Runnable[elements.length];</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c9">1734</A></TD><TD>        for (int idx = 0; idx &lt; elements.length; idx++)</TD></TR><TR><TD CLASS="l">1735</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1736</TD><TD>                final int i=idx;</TD></TR><TR CLASS="z"><TD CLASS="l">1737</TD><TD>                workers[i] = new Runnable()</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="cb">1738</A></TD><TD>                {</TD></TR><TR><TD CLASS="l">1739</TD><TD>                        </TD></TR><TR><TD CLASS="l">1740</TD><TD>                        public void run()</TD></TR><TR><TD CLASS="l">1741</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1742</TD><TD>                                Log.information(&#34;START getClassBySession for template:&#34;+elements[i].getElementName());</TD></TR><TR CLASS="z"><TD CLASS="l">1743</TD><TD>                        TradingSessionElementStruct elementStruct = elementHome.toStruct(elements[i], includeReportingClasses);</TD></TR><TR><TD CLASS="l">1744</TD><TD>                        //obtain the simple class structs from the detail class structs</TD></TR><TR CLASS="z"><TD CLASS="l">1745</TD><TD>                        SessionClassStruct[] simpleClasses = new SessionClassStruct[elementStruct.elementClasses.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1746</TD><TD>                        for ( int j =0; j&lt; elementStruct.elementClasses.length; j++)</TD></TR><TR><TD CLASS="l">1747</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1748</TD><TD>                            simpleClasses[j] = elementStruct.elementClasses[j];</TD></TR><TR><TD CLASS="l">1749</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1750</TD><TD>                        synchronized (sessionClassesList)</TD></TR><TR><TD CLASS="l">1751</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1752</TD><TD>                                sessionClassesList.addAll(Arrays.asList(simpleClasses));</TD></TR><TR CLASS="z"><TD CLASS="l">1753</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1754</TD><TD>                                Log.information(&#34;END getClassBySession for template:&#34;+elements[i].getElementName());</TD></TR><TR><TD CLASS="l">1755</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">1756</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1757</TD><TD>                };</TD></TR><TR><TD CLASS="l">1758</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">1759</TD><TD>                threadPool.execute(workers[i]);</TD></TR><TR><TD CLASS="l">1760</TD><TD>         }</TD></TR><TR><TD CLASS="l">1761</TD><TD>         </TD></TR><TR CLASS="z"><TD CLASS="l">1762</TD><TD>        threadPool.shutdown();</TD></TR><TR><TD CLASS="l">1763</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1764</TD><TD>                threadPool.awaitTermination(3600, TimeUnit.SECONDS);</TD></TR><TR CLASS="z"><TD CLASS="l">1765</TD><TD>                Log.information(&#34;getClassesBySessionWithParallelThreads finished&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1766</TD><TD>        } catch (InterruptedException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1767</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;getClassBySession FAILED with InteruptedException &#34;+e, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1768</TD><TD>        }</TD></TR><TR><TD CLASS="l">1769</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1770</TD><TD>        SessionClassStruct[] result = new SessionClassStruct[sessionClassesList.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1771</TD><TD>        sessionClassesList.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1772</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1773</TD><TD>}</TD></TR><TR><TD CLASS="l">1774</TD><TD> </TD></TR><TR><TD CLASS="l">1775</TD><TD> </TD></TR><TR><TD CLASS="l">1776</TD><TD>/**</TD></TR><TR><TD CLASS="l">1777</TD><TD> * Gets all classes simple information for the session and the prodcut type</TD></TR><TR><TD CLASS="l">1778</TD><TD> * @param sessionName name of the session</TD></TR><TR><TD CLASS="l">1779</TD><TD> * @param productType</TD></TR><TR><TD CLASS="l">1780</TD><TD> * @return com.cboe.idl.cmiSession.SessionClassStruct[] simple classes defined for the session elements of the session, with the specified</TD></TR><TR><TD CLASS="l">1781</TD><TD> * product type</TD></TR><TR><TD CLASS="l"><A NAME="3b">1782</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1783</TD><TD> public SessionClassStruct[] getClassesBySessionForType(java.lang.String sessionName, short productType)</TD></TR><TR><TD CLASS="l">1784</TD><TD>    throws DataValidationException</TD></TR><TR><TD CLASS="l">1785</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1786</TD><TD>     SessionClassStruct[] simpleClasses = getClassesBySession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1787</TD><TD>     ArrayList classesList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1788</TD><TD>     for (int i = 0; i &lt; simpleClasses.length; i++)</TD></TR><TR><TD CLASS="l">1789</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">1790</TD><TD>         if ( simpleClasses[i].classStruct.productType == productType)</TD></TR><TR CLASS="z"><TD CLASS="l">1791</TD><TD>               classesList.add(simpleClasses[i]);</TD></TR><TR><TD CLASS="l">1792</TD><TD>     }</TD></TR><TR><TD CLASS="l">1793</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1794</TD><TD>     SessionClassStruct[] result = new SessionClassStruct[classesList.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1795</TD><TD>     classesList.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1796</TD><TD>     return result;</TD></TR><TR><TD CLASS="l">1797</TD><TD>}</TD></TR><TR><TD CLASS="l">1798</TD><TD> </TD></TR><TR><TD CLASS="l">1799</TD><TD> </TD></TR><TR><TD CLASS="l">1800</TD><TD>/**</TD></TR><TR><TD CLASS="l">1801</TD><TD> * Return all classes controlled by a given template.</TD></TR><TR><TD CLASS="l">1802</TD><TD> * @param sessionKey - the session key to get the classes for.  The session need not be &#34;OPEN&#34;.</TD></TR><TR><TD CLASS="l">1803</TD><TD> * @return ClassStruct[] - the array of classes associated with the session.</TD></TR><TR><TD CLASS="l">1804</TD><TD> * @exception NotFoundException - thrown if the given sessionKey is not found in the current business day.</TD></TR><TR><TD CLASS="l"><A NAME="41">1805</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1806</TD><TD>public TemplateClassStruct[] getClassesForTemplate(String templateName)</TD></TR><TR><TD CLASS="l">1807</TD><TD>         throws DataValidationException</TD></TR><TR><TD CLASS="l">1808</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1809</TD><TD>    TradingSessionElementTemplate template = verifyTemplateName(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">1810</TD><TD>    TemplateClass[] classes = template.getClasses();</TD></TR><TR CLASS="z"><TD CLASS="l">1811</TD><TD>    return templateClassHome.toStructs(classes);</TD></TR><TR><TD CLASS="l">1812</TD><TD>}</TD></TR><TR><TD CLASS="l">1813</TD><TD>/**</TD></TR><TR><TD CLASS="l">1814</TD><TD> * Get class states for session element.</TD></TR><TR><TD CLASS="l"><A NAME="36">1815</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1816</TD><TD>public ClassStateDetailStruct[] getClassStatesForElement(int elementKey)</TD></TR><TR><TD CLASS="l">1817</TD><TD>    throws DataValidationException {</TD></TR><TR><TD CLASS="l">1818</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">1819</TD><TD>        TradingSessionElement element = elementHome.findByKey(elementKey);</TD></TR><TR CLASS="z"><TD CLASS="l">1820</TD><TD>        SessionElementClass[] classes = element.getClasses();</TD></TR><TR CLASS="z"><TD CLASS="l">1821</TD><TD>        ClassStateDetailStruct[] result = new ClassStateDetailStruct[classes.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1822</TD><TD>        for (int i = 0; i &lt; classes.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1823</TD><TD>            result[i] = elementClassHome.toDetailStateStruct(classes[i]);</TD></TR><TR><TD CLASS="l">1824</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1826</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1827</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1828</TD><TD>        throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">1829</TD><TD>    }</TD></TR><TR><TD CLASS="l">1830</TD><TD>}</TD></TR><TR><TD CLASS="l">1831</TD><TD>/**</TD></TR><TR><TD CLASS="l">1832</TD><TD> * Get class states for session.</TD></TR><TR><TD CLASS="l"><A NAME="37">1833</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1834</TD><TD>public ClassStateDetailStruct[] getClassStatesForSession(String sessionName)</TD></TR><TR><TD CLASS="l">1835</TD><TD>    throws DataValidationException {</TD></TR><TR><TD CLASS="l">1836</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1837</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1838</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">1839</TD><TD>    ArrayList combinedStructs = new ArrayList();</TD></TR><TR><TD CLASS="l">1840</TD><TD>    ClassStateDetailStruct[] detailsForElement;</TD></TR><TR CLASS="z"><TD CLASS="l">1841</TD><TD>    for (int i = 0; i &lt; elements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1842</TD><TD>        detailsForElement = getClassStatesForElement(elements[i].getElementKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1843</TD><TD>        combinedStructs.addAll(Arrays.asList(detailsForElement));</TD></TR><TR><TD CLASS="l">1844</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1845</TD><TD>    ClassStateDetailStruct[] result = new ClassStateDetailStruct[combinedStructs.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">1846</TD><TD>    combinedStructs.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">1847</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1848</TD><TD>}</TD></TR><TR><TD CLASS="l">1849</TD><TD>/**</TD></TR><TR><TD CLASS="l">1850</TD><TD> * Gets the current business day.</TD></TR><TR><TD CLASS="l">1851</TD><TD> *</TD></TR><TR><TD CLASS="l">1852</TD><TD> * &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The business day may include prod classes that do not include all reporting</TD></TR><TR><TD CLASS="l">1853</TD><TD> * classes (in the case of an intra-day reporting class add).  Client of this method should not</TD></TR><TR><TD CLASS="l">1854</TD><TD> * depend on the accuracy of the report classes listed by the result.</TD></TR><TR><TD CLASS="l">1855</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="42">1856</A></TD><TD> * @return business day struct.  If day is open, session values will be included.</TD></TR><TR><TD CLASS="l">1857</TD><TD> */</TD></TR><TR><TD CLASS="l">1858</TD><TD>public BusinessDayStruct getCurrentBusinessDay() throws SystemException</TD></TR><TR><TD CLASS="l">1859</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">1860</TD><TD>        Log.information(this, &#34;getCurrentBusinessDay - Creating 'business day' struct...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1861</TD><TD>    BusinessDay currentDay = getBusinessDayHome().findCurrent();</TD></TR><TR CLASS="z"><TD CLASS="l">1862</TD><TD>    BusinessDayStruct result = new BusinessDayStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">1863</TD><TD>    result.currentDay = DateWrapper.convertToDate(currentDay.getDate().getTime());</TD></TR><TR CLASS="z"><TD CLASS="l">1864</TD><TD>    result.dayState = currentDay.getState();</TD></TR><TR CLASS="z"><TD CLASS="l">1865</TD><TD>    if (result.dayState == BusinessDayStates.STARTED)</TD></TR><TR><TD CLASS="l">1866</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1867</TD><TD>        result.activeSessions = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1868</TD><TD>        synchronized (cachedBusinessDaySessionsSynchObj)</TD></TR><TR><TD CLASS="l">1869</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1870</TD><TD>            if (cachedBusinessDaySessions != null)</TD></TR><TR><TD CLASS="l">1871</TD><TD>            {</TD></TR><TR><TD CLASS="l">1872</TD><TD>                // We will be careful to call getCurrentBusinessDay at the end of createCurrentBusinessDay</TD></TR><TR><TD CLASS="l">1873</TD><TD>                // to make sure this cached struct array is always up-to-date.</TD></TR><TR><TD CLASS="l">1874</TD><TD>                //</TD></TR><TR CLASS="z"><TD CLASS="l">1875</TD><TD>                result.activeSessions = cachedBusinessDaySessions;</TD></TR><TR CLASS="z"><TD CLASS="l">1876</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Using cached 'active sessions' struct array.&#34;);</TD></TR><TR><TD CLASS="l">1877</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1878</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1879</TD><TD>        if (result.activeSessions == null)</TD></TR><TR><TD CLASS="l">1880</TD><TD>        {</TD></TR><TR><TD CLASS="l">1881</TD><TD>            try</TD></TR><TR><TD CLASS="l">1882</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1883</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Creating 'active sessions' struct array...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1884</TD><TD>                TradingSession[] sessions = sessionHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1885</TD><TD>                result.activeSessions = new BusinessDaySessionStruct[sessions.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1886</TD><TD>                for (int i = 0; i &lt; sessions.length; i++)</TD></TR><TR><TD CLASS="l">1887</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1888</TD><TD>                    result.activeSessions[i] = new BusinessDaySessionStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">1889</TD><TD>                    result.activeSessions[i].session = sessionHome.toStruct(sessions[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1890</TD><TD>                    result.activeSessions[i].sessionProductTypes = getProductTypesForSession(sessions[i].getSessionName());</TD></TR><TR CLASS="z"><TD CLASS="l">1891</TD><TD>                    result.activeSessions[i].sessionClasses = getClassesBySession(sessions[i].getSessionName(), includeReportingClassesInBusinessDayStruct);</TD></TR><TR><TD CLASS="l">1892</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1893</TD><TD>                synchronized (cachedBusinessDaySessionsSynchObj)</TD></TR><TR><TD CLASS="l">1894</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1895</TD><TD>                    this.cachedBusinessDaySessions = result.activeSessions;</TD></TR><TR CLASS="z"><TD CLASS="l">1896</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1897</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Created 'active sessions' struct array...&#34;);</TD></TR><TR><TD CLASS="l">1898</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1899</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">1900</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1901</TD><TD>                Log.exception(this, &#34;Unable to get session information for current day&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">1902</TD><TD>                throw ExceptionBuilder.systemException(&#34;Unable to get session information for current day: &#34; + e, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>            }</TD></TR><TR><TD CLASS="l">1904</TD><TD>        }</TD></TR><TR><TD CLASS="l">1905</TD><TD>    }</TD></TR><TR><TD CLASS="l">1906</TD><TD>    else</TD></TR><TR><TD CLASS="l">1907</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1908</TD><TD>        Log.information(this, &#34;getCurrentBusinessDay - Using empty session struct since day is not 'STARTED'.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>        result.activeSessions = new BusinessDaySessionStruct[0];</TD></TR><TR><TD CLASS="l">1910</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">1911</TD><TD>    Log.information(this, &#34;getCurrentBusinessDay - Done creating 'business day' struct.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1912</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">1913</TD><TD>}</TD></TR><TR><TD CLASS="l">1914</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="43">1915</A></TD><TD>public BusinessDayStruct getCurrentBusinessDayWithParallelThread() throws SystemException</TD></TR><TR><TD CLASS="l">1916</TD><TD>{</TD></TR><TR><TD CLASS="l">1917</TD><TD>        TradingSessionThreadPoolHome threadPoolHome;</TD></TR><TR><TD CLASS="l">1918</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1919</TD><TD>                 threadPoolHome = (TradingSessionThreadPoolHome) HomeFactory.getInstance().findHome(TradingSessionThreadPoolHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">1920</TD><TD>        } catch (CBOELoggableException e1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1921</TD><TD>                threadPoolHome = new TradingSessionThreadPoolHomeImpl();</TD></TR><TR CLASS="z"><TD CLASS="l">1922</TD><TD>                e1.printStackTrace();</TD></TR><TR CLASS="z"><TD CLASS="l">1923</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1924</TD><TD>        if (threadPoolHome == null)</TD></TR><TR><TD CLASS="l">1925</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1926</TD><TD>                threadPoolHome = new TradingSessionThreadPoolHomeImpl();</TD></TR><TR><TD CLASS="l">1927</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1928</TD><TD>        ThreadPoolExecutor threadPool = threadPoolHome.findTradingSessionThreadPool();</TD></TR><TR CLASS="z"><TD CLASS="l">1929</TD><TD>    Log.information(this, &#34;getCurrentBusinessDayWithParallelThread() - Creating 'business day' struct...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1930</TD><TD>    BusinessDay currentDay = getBusinessDayHome().findCurrent();</TD></TR><TR CLASS="z"><TD CLASS="l">1931</TD><TD>    final BusinessDayStruct result = new BusinessDayStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">1932</TD><TD>    result.currentDay = DateWrapper.convertToDate(currentDay.getDate().getTime());</TD></TR><TR CLASS="z"><TD CLASS="l">1933</TD><TD>    result.dayState = currentDay.getState();</TD></TR><TR CLASS="z"><TD CLASS="l">1934</TD><TD>    if (result.dayState == BusinessDayStates.STARTED)</TD></TR><TR><TD CLASS="l">1935</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>        result.activeSessions = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1937</TD><TD>        synchronized (cachedBusinessDaySessionsSynchObj)</TD></TR><TR><TD CLASS="l">1938</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1939</TD><TD>            if (cachedBusinessDaySessions != null)</TD></TR><TR><TD CLASS="l">1940</TD><TD>            {</TD></TR><TR><TD CLASS="l">1941</TD><TD>                // We will be careful to call getCurrentBusinessDay at the end of createCurrentBusinessDay</TD></TR><TR><TD CLASS="l">1942</TD><TD>                // to make sure this cached struct array is always up-to-date.</TD></TR><TR><TD CLASS="l">1943</TD><TD>                //</TD></TR><TR CLASS="z"><TD CLASS="l">1944</TD><TD>                result.activeSessions = cachedBusinessDaySessions;</TD></TR><TR CLASS="z"><TD CLASS="l">1945</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Using cached 'active sessions' struct array.&#34;);</TD></TR><TR><TD CLASS="l">1946</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1947</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1948</TD><TD>        if (result.activeSessions == null)</TD></TR><TR><TD CLASS="l">1949</TD><TD>        {</TD></TR><TR><TD CLASS="l">1950</TD><TD>            try</TD></TR><TR><TD CLASS="l">1951</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1952</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Creating 'active sessions' struct array...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1953</TD><TD>                final TradingSession[] sessions = sessionHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">1954</TD><TD>                result.activeSessions = new BusinessDaySessionStruct[sessions.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1955</TD><TD>                Runnable[] workers = new Runnable[sessions.length];</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="db">1956</A></TD><TD>                for ( int idx = 0; idx &lt; sessions.length; idx++)</TD></TR><TR><TD CLASS="l">1957</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1958</TD><TD>                        final int i = idx;</TD></TR><TR CLASS="z"><TD CLASS="l">1959</TD><TD>                        workers[i] = new Runnable()</TD></TR><TR CLASS="z"><TD CLASS="l">1960</TD><TD>                        {</TD></TR><TR><TD CLASS="l"><A NAME="dd">1961</A></TD><TD>                                public void run()</TD></TR><TR><TD CLASS="l">1962</TD><TD>                                {</TD></TR><TR><TD CLASS="l">1963</TD><TD>                                        try</TD></TR><TR><TD CLASS="l">1964</TD><TD>                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1965</TD><TD>                                    result.activeSessions[i] = new BusinessDaySessionStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">1966</TD><TD>                                    result.activeSessions[i].session = sessionHome.toStruct(sessions[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1967</TD><TD>                                    result.activeSessions[i].sessionProductTypes = getProductTypesForSession(sessions[i].getSessionName());</TD></TR><TR CLASS="z"><TD CLASS="l">1968</TD><TD>                                    result.activeSessions[i].sessionClasses = getClassesBySession(sessions[i].getSessionName(), includeReportingClassesInBusinessDayStruct);</TD></TR><TR><TD CLASS="l">1969</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1970</TD><TD>                                        catch (Exception e)</TD></TR><TR><TD CLASS="l">1971</TD><TD>                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1972</TD><TD>                                                Log.exception(e);</TD></TR><TR CLASS="z"><TD CLASS="l">1973</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1974</TD><TD>                                        </TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1976</TD><TD>                        };</TD></TR><TR CLASS="z"><TD CLASS="l">1977</TD><TD>                        threadPool.execute(workers[i]);</TD></TR><TR><TD CLASS="l">1978</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1979</TD><TD>                threadPool.shutdown();</TD></TR><TR CLASS="z"><TD CLASS="l">1980</TD><TD>                threadPool.awaitTermination(3600, TimeUnit.SECONDS);</TD></TR><TR CLASS="z"><TD CLASS="l">1981</TD><TD>                        Log.information(&#34;getCurrentBusinessDayWithParallelThread() finished&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1982</TD><TD>                        synchronized (cachedBusinessDaySessionsSynchObj)</TD></TR><TR><TD CLASS="l">1983</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1984</TD><TD>                    this.cachedBusinessDaySessions = result.activeSessions;</TD></TR><TR CLASS="z"><TD CLASS="l">1985</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1986</TD><TD>                Log.information(this, &#34;getCurrentBusinessDay - Created 'active sessions' struct array...&#34;);</TD></TR><TR><TD CLASS="l">1987</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1988</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">1989</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1990</TD><TD>                Log.exception(this, &#34;Unable to get session information for current day&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">1991</TD><TD>                throw ExceptionBuilder.systemException(&#34;Unable to get session information for current day: &#34; + e, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1992</TD><TD>            }</TD></TR><TR><TD CLASS="l">1993</TD><TD>        }</TD></TR><TR><TD CLASS="l">1994</TD><TD>    }</TD></TR><TR><TD CLASS="l">1995</TD><TD>    else</TD></TR><TR><TD CLASS="l">1996</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1997</TD><TD>        Log.information(this, &#34;getCurrentBusinessDay - Using empty session struct since day is not 'STARTED'.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1998</TD><TD>        result.activeSessions = new BusinessDaySessionStruct[0];</TD></TR><TR><TD CLASS="l">1999</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2000</TD><TD>    Log.information(this, &#34;getCurrentBusinessDay - Done creating 'business day' struct.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2001</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2002</TD><TD>        </TD></TR><TR><TD CLASS="l">2003</TD><TD>}</TD></TR><TR><TD CLASS="l">2004</TD><TD> </TD></TR><TR><TD CLASS="l">2005</TD><TD>/**</TD></TR><TR><TD CLASS="l">2006</TD><TD> * Return an array session structs describing the sessions in the current OPEN sessions in the current</TD></TR><TR><TD CLASS="l">2007</TD><TD> * business day.</TD></TR><TR><TD CLASS="l">2008</TD><TD> *</TD></TR><TR><TD CLASS="l">2009</TD><TD> * @return TradingSessionStruct[] - the returned array of structs for open sessions.  This method will</TD></TR><TR><TD CLASS="l"><A NAME="45">2010</A></TD><TD> *         never return null: if there are no open sessions then an empty array is returned.</TD></TR><TR><TD CLASS="l">2011</TD><TD> */</TD></TR><TR><TD CLASS="l">2012</TD><TD>public TradingSessionElementStruct[] getCurrentTradingSessionElements()</TD></TR><TR><TD CLASS="l">2013</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2014</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrent();</TD></TR><TR CLASS="z"><TD CLASS="l">2015</TD><TD>    return elementHome.toStructs(elements);</TD></TR><TR><TD CLASS="l">2016</TD><TD>}</TD></TR><TR><TD CLASS="l">2017</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="44">2018</A></TD><TD> * Gets current element for a trading session.</TD></TR><TR><TD CLASS="l">2019</TD><TD> */</TD></TR><TR><TD CLASS="l">2020</TD><TD>public TradingSessionElementStruct[] getCurrentElementsForSession(String sessionName)</TD></TR><TR><TD CLASS="l">2021</TD><TD>    throws DataValidationException {</TD></TR><TR CLASS="z"><TD CLASS="l">2022</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2023</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>    return elementHome.toStructs(elements);</TD></TR><TR><TD CLASS="l">2025</TD><TD>}</TD></TR><TR><TD CLASS="l">2026</TD><TD>/**</TD></TR><TR><TD CLASS="l">2027</TD><TD> * Return any open session which is trading at least one of the keys listed in the</TD></TR><TR><TD CLASS="l">2028</TD><TD> * given classKeys array.</TD></TR><TR><TD CLASS="l">2029</TD><TD> *</TD></TR><TR><TD CLASS="l">2030</TD><TD> * @param classKeys int[]</TD></TR><TR><TD CLASS="l"><A NAME="46">2031</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2032</TD><TD>public TradingSessionStruct[] getCurrentTradingSessionsForClasses(int[] classKeys)</TD></TR><TR><TD CLASS="l">2033</TD><TD>        throws CommunicationException, SystemException, AuthorizationException, DataValidationException</TD></TR><TR><TD CLASS="l">2034</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2035</TD><TD>    HashMap sessions = new HashMap();</TD></TR><TR><TD CLASS="l">2036</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2037</TD><TD>    for (int i = 0; i &lt; classKeys.length; i++) {</TD></TR><TR><TD CLASS="l">2038</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2039</TD><TD>            TradingSessionStruct[] classSessions = getTradingSessionsForClass(classKeys[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">2040</TD><TD>            for (int j = 0; j &lt; classSessions.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2041</TD><TD>                sessions.put(classSessions[j].sessionName, classSessions[j]);</TD></TR><TR><TD CLASS="l">2042</TD><TD>            }</TD></TR><TR><TD CLASS="l">2043</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2044</TD><TD>        catch (Exception e) {</TD></TR><TR><TD CLASS="l">2045</TD><TD>            // ignore exceptions, return what we can</TD></TR><TR CLASS="z"><TD CLASS="l">2046</TD><TD>        }</TD></TR><TR><TD CLASS="l">2047</TD><TD>    }</TD></TR><TR><TD CLASS="l">2048</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>    TradingSessionStruct[] result = new TradingSessionStruct[sessions.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2050</TD><TD>    sessions.values().toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2052</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="47">2053</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2054</TD><TD> * Gets session element by key.</TD></TR><TR><TD CLASS="l">2055</TD><TD> */</TD></TR><TR><TD CLASS="l">2056</TD><TD>public TradingSessionElementStruct getElementByKey(int elementKey) throws NotFoundException {</TD></TR><TR CLASS="z"><TD CLASS="l">2057</TD><TD>    TradingSessionElement element = elementHome.findByKey(elementKey);</TD></TR><TR CLASS="z"><TD CLASS="l">2058</TD><TD>    return elementHome.toStruct(element, true);</TD></TR><TR><TD CLASS="l">2059</TD><TD>}</TD></TR><TR><TD CLASS="l">2060</TD><TD>/**</TD></TR><TR><TD CLASS="l">2061</TD><TD> * Returns the supported end of day strategies.</TD></TR><TR><TD CLASS="l">2062</TD><TD> * @return TradingSessionStrategyDescriptionStruct[]</TD></TR><TR><TD CLASS="l">2063</TD><TD> */</TD></TR><TR><TD CLASS="l">2064</TD><TD>public TradingSessionStrategyDescriptionStruct[] getEndOfDayStrategies() throws SystemException, CommunicationException, AuthorizationException</TD></TR><TR><TD CLASS="l">2065</TD><TD>{</TD></TR><TR><TD CLASS="l">2066</TD><TD>        // Create the output structure and fil it in.</TD></TR><TR><TD CLASS="l"><A NAME="4c">2067</A></TD><TD>        TradingSessionStrategyDescriptionStruct[] structs;</TD></TR><TR><TD CLASS="l">2068</TD><TD> </TD></TR><TR><TD CLASS="l">2069</TD><TD>        try</TD></TR><TR><TD CLASS="l">2070</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2071</TD><TD>                structs = new TradingSessionStrategyDescriptionStruct[1];</TD></TR><TR CLASS="z"><TD CLASS="l">2072</TD><TD>                structs[0] = strategyFactory.getEndOfBusinessDayStrategy(null).toStruct();</TD></TR><TR><TD CLASS="l">2073</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2074</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2075</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2076</TD><TD>                structs = new TradingSessionStrategyDescriptionStruct[0];</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>        }</TD></TR><TR><TD CLASS="l">2078</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2079</TD><TD>        return structs;</TD></TR><TR><TD CLASS="l">2080</TD><TD>}</TD></TR><TR><TD CLASS="l">2081</TD><TD>/**</TD></TR><TR><TD CLASS="l">2082</TD><TD> * Returns the supported end of session group strategies.</TD></TR><TR><TD CLASS="l">2083</TD><TD> * @return TradingSessionStrategyDescriptionStruct[]</TD></TR><TR><TD CLASS="l"><A NAME="4d">2084</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2085</TD><TD>public TradingSessionStrategyDescriptionStruct[] getEndOfSessionStrategies() throws SystemException, CommunicationException, AuthorizationException</TD></TR><TR><TD CLASS="l">2086</TD><TD>{</TD></TR><TR><TD CLASS="l">2087</TD><TD>        // Get the names of the strategies first.</TD></TR><TR CLASS="z"><TD CLASS="l">2088</TD><TD>        String[] names = strategyFactory.getEndOfSessionStrategyNames();</TD></TR><TR><TD CLASS="l">2089</TD><TD> </TD></TR><TR><TD CLASS="l">2090</TD><TD>        // Create the output structure and fil it in.</TD></TR><TR CLASS="z"><TD CLASS="l">2091</TD><TD>        TradingSessionStrategyDescriptionStruct[] structs = new TradingSessionStrategyDescriptionStruct[names.length];</TD></TR><TR><TD CLASS="l">2092</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>        for (int i = 0; i &lt; names.length; i++)</TD></TR><TR><TD CLASS="l">2094</TD><TD>        {</TD></TR><TR><TD CLASS="l">2095</TD><TD>                try</TD></TR><TR><TD CLASS="l">2096</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2097</TD><TD>                        structs[i] = strategyFactory.getEndOfSessionStrategy(names[i]).toStruct();</TD></TR><TR><TD CLASS="l">2098</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2099</TD><TD>                catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2100</TD><TD>                {</TD></TR><TR><TD CLASS="l">2101</TD><TD>                        // So what. Ignore.</TD></TR><TR CLASS="z"><TD CLASS="l">2102</TD><TD>                }</TD></TR><TR><TD CLASS="l">2103</TD><TD>        }</TD></TR><TR><TD CLASS="l">2104</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2105</TD><TD>        return structs;</TD></TR><TR><TD CLASS="l">2106</TD><TD>}</TD></TR><TR><TD CLASS="l">2107</TD><TD>/**</TD></TR><TR><TD CLASS="l">2108</TD><TD> * Return a struct describing the next trading session that a given class will be in.  This method does</TD></TR><TR><TD CLASS="l">2109</TD><TD> * not consider template-generated sessions which have not been generated yet.</TD></TR><TR><TD CLASS="l">2110</TD><TD> *</TD></TR><TR><TD CLASS="l">2111</TD><TD> * @param classKey - the key to a class.</TD></TR><TR><TD CLASS="l">2112</TD><TD> * @return TradingSessionStruct - a struct describing the next trading session in the current business day</TD></TR><TR><TD CLASS="l">2113</TD><TD> *                that contains the given class</TD></TR><TR><TD CLASS="l">2114</TD><TD> * @exception NotFoundException - thrown if the classKey does not map to any &#34;next session&#34;.</TD></TR><TR><TD CLASS="l"><A NAME="54">2115</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2116</TD><TD>public TradingSessionStruct getNextSessionForClass(int classKey)</TD></TR><TR><TD CLASS="l">2117</TD><TD>        throws NotFoundException, DataValidationException, CommunicationException, SystemException, AuthorizationException</TD></TR><TR><TD CLASS="l">2118</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2119</TD><TD>    if (classKey == 0)</TD></TR><TR><TD CLASS="l">2120</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2121</TD><TD>        throw ExceptionBuilder.dataValidationException(&#34;Class key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">2122</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2123</TD><TD>        TemplateClass[] templateClasses = templateClassHome.findByClass(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">2124</TD><TD>        TradingSession nextSession = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2125</TD><TD>        long now = TimeHelper.toMillisSinceMidnight(new DateWrapper().toTimeStruct());</TD></TR><TR CLASS="z"><TD CLASS="l">2126</TD><TD>        long nextOpenTime = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2127</TD><TD>        for (int i = 0; i &lt; templateClasses.length; i++)</TD></TR><TR><TD CLASS="l">2128</TD><TD>        {</TD></TR><TR><TD CLASS="l">2129</TD><TD>                // Skip currently open sessions</TD></TR><TR CLASS="z"><TD CLASS="l">2130</TD><TD>                if (templateClasses[i].getTemplate().getSession().getSessionState() == TradingSessionStates.OPEN)</TD></TR><TR><TD CLASS="l">2131</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2132</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">2133</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2134</TD><TD>                long templateOpenTime = templateClasses[i].getTemplate().getProductOpenTime();</TD></TR><TR CLASS="z"><TD CLASS="l">2135</TD><TD>                if (nextSession == null || (templateOpenTime &gt; now &amp;&amp; nextOpenTime &gt; templateOpenTime))</TD></TR><TR><TD CLASS="l">2136</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2137</TD><TD>                        nextSession = templateClasses[i].getTemplate().getSession();</TD></TR><TR CLASS="z"><TD CLASS="l">2138</TD><TD>                        nextOpenTime = templateOpenTime;</TD></TR><TR><TD CLASS="l">2139</TD><TD>                }</TD></TR><TR><TD CLASS="l">2140</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2141</TD><TD>        if (nextSession == null)</TD></TR><TR><TD CLASS="l">2142</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2143</TD><TD>                throw ExceptionBuilder.notFoundException(&#34;No future session found.&#34;, 0);</TD></TR><TR><TD CLASS="l">2144</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2145</TD><TD>    return sessionHome.toStruct(nextSession);</TD></TR><TR><TD CLASS="l">2146</TD><TD>}</TD></TR><TR><TD CLASS="l">2147</TD><TD>/**</TD></TR><TR><TD CLASS="l">2148</TD><TD> * Gets the product classes for a session.</TD></TR><TR><TD CLASS="l"><A NAME="5b">2149</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2150</TD><TD>private ProductClassStruct[] getProductClassesForSession(String sessionName, boolean includeRpt, boolean activeOnly)</TD></TR><TR><TD CLASS="l">2151</TD><TD>throws DataValidationException, AuthorizationException, CommunicationException, SystemException {</TD></TR><TR><TD CLASS="l">2152</TD><TD>    // fixme - no efficient way seems to be available.  should this data be maintained?</TD></TR><TR CLASS="z"><TD CLASS="l">2153</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2154</TD><TD>    TradingSessionElementTemplate[] templates = templateHome.findBySession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2155</TD><TD>    ArrayList sessionClasses = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">2156</TD><TD>    for (int i = 0; i &lt; templates.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2157</TD><TD>        TemplateClass[] templateClasses = templates[i].getClasses();</TD></TR><TR CLASS="z"><TD CLASS="l">2158</TD><TD>        for (int j = 0; j &lt; templateClasses.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2159</TD><TD>            sessionClasses.add(new Integer(templateClasses[j].getClassKey()));</TD></TR><TR><TD CLASS="l">2160</TD><TD>        }</TD></TR><TR><TD CLASS="l">2161</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2162</TD><TD>    int[] classKeys = new int[sessionClasses.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2163</TD><TD>    for (int i = 0; i &lt; classKeys.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2164</TD><TD>        classKeys[i] = ((Integer) sessionClasses.get(i)).intValue();</TD></TR><TR><TD CLASS="l">2165</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2166</TD><TD>    ProductClassStruct[] classStructs = getProductQueryService().getProductClassesByKey(classKeys, includeRpt, false, activeOnly);</TD></TR><TR CLASS="z"><TD CLASS="l">2167</TD><TD>    return classStructs;</TD></TR><TR><TD CLASS="l">2168</TD><TD>}</TD></TR><TR><TD CLASS="l">2169</TD><TD> </TD></TR><TR><TD CLASS="l">2170</TD><TD> </TD></TR><TR><TD CLASS="l">2171</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="5f">2172</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2173</TD><TD> * Gets a reference to the ProductQueryService.</TD></TR><TR><TD CLASS="l">2174</TD><TD> */</TD></TR><TR><TD CLASS="l">2175</TD><TD>private ProductQueryService getProductQueryService() throws SystemException {</TD></TR><TR CLASS="z"><TD CLASS="l">2176</TD><TD>    if (productQueryService == null) {</TD></TR><TR><TD CLASS="l">2177</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2178</TD><TD>            ProductQueryServiceHome pqsHome = (ProductQueryServiceHome) HomeFactory.getInstance().findHome(ProductQueryServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2179</TD><TD>            productQueryService = pqsHome.find();</TD></TR><TR><TD CLASS="l">2180</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2181</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2182</TD><TD>            throw ExceptionBuilder.systemException(&#34;Unable to get ProductQueryService&#34;, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">2183</TD><TD>        }</TD></TR><TR><TD CLASS="l">2184</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>    return productQueryService;</TD></TR><TR><TD CLASS="l">2186</TD><TD>}</TD></TR><TR><TD CLASS="l">2187</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="5c">2188</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2189</TD><TD> * Gets a reference to the ProductConfigurationService.</TD></TR><TR><TD CLASS="l">2190</TD><TD> */</TD></TR><TR><TD CLASS="l">2191</TD><TD>private ProductConfigurationService getProductConfigurationService() throws SystemException {</TD></TR><TR CLASS="z"><TD CLASS="l">2192</TD><TD>    if (productConfigurationService == null) {</TD></TR><TR><TD CLASS="l">2193</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2194</TD><TD>            ProductConfigurationServiceHome pcsHome = (ProductConfigurationServiceHome) HomeFactory.getInstance().findHome(ProductConfigurationServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2195</TD><TD>            productConfigurationService = pcsHome.find();</TD></TR><TR><TD CLASS="l">2196</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2197</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2198</TD><TD>            throw ExceptionBuilder.systemException(&#34;Unable to get ProductConfigurationService&#34;, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>        }</TD></TR><TR><TD CLASS="l">2200</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>    return productConfigurationService;</TD></TR><TR><TD CLASS="l">2202</TD><TD>}</TD></TR><TR><TD CLASS="l">2203</TD><TD> </TD></TR><TR><TD CLASS="l">2204</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="61">2205</A></TD><TD> * Gets product types active for session.</TD></TR><TR><TD CLASS="l">2206</TD><TD> */</TD></TR><TR><TD CLASS="l">2207</TD><TD>public ProductTypeStruct[] getProductTypesForSession(String sessionName)</TD></TR><TR><TD CLASS="l">2208</TD><TD>    throws DataValidationException, AuthorizationException, SystemException, CommunicationException {</TD></TR><TR CLASS="z"><TD CLASS="l">2209</TD><TD>    ProductClassStruct[] classStructs = getProductClassesForSession(sessionName, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2210</TD><TD>    ProductTypeStruct[] allTypes = getProductQueryService().getProductTypes();</TD></TR><TR CLASS="z"><TD CLASS="l">2211</TD><TD>    ArrayList sessionTypes = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">2212</TD><TD>    for (int i = 0; i &lt; classStructs.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2213</TD><TD>        boolean found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2214</TD><TD>        for (int j = 0; j &lt; sessionTypes.size(); j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2215</TD><TD>            if (((ProductTypeStruct) sessionTypes.get(j)).type == classStructs[i].info.productType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2216</TD><TD>                found = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2217</TD><TD>                break;</TD></TR><TR><TD CLASS="l">2218</TD><TD>            }</TD></TR><TR><TD CLASS="l">2219</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2220</TD><TD>        if (!found) {</TD></TR><TR CLASS="z"><TD CLASS="l">2221</TD><TD>            for (int j = 0; j &lt; allTypes.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2222</TD><TD>                if (allTypes[j].type == classStructs[i].info.productType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2223</TD><TD>                    sessionTypes.add(allTypes[j]);</TD></TR><TR CLASS="z"><TD CLASS="l">2224</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2225</TD><TD>                }</TD></TR><TR><TD CLASS="l">2226</TD><TD>            }</TD></TR><TR><TD CLASS="l">2227</TD><TD>        }</TD></TR><TR><TD CLASS="l">2228</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2229</TD><TD>    ProductTypeStruct[] result = new ProductTypeStruct[sessionTypes.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2230</TD><TD>    sessionTypes.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">2231</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2232</TD><TD>}</TD></TR><TR><TD CLASS="l">2233</TD><TD>/**</TD></TR><TR><TD CLASS="l">2234</TD><TD> * Find the clients which are registered with the trading service. (ie, what TSC am I talking to?)</TD></TR><TR><TD CLASS="l">2235</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="65">2236</A></TD><TD> * @return TradingSessionClient[] - the clients that were found</TD></TR><TR><TD CLASS="l">2237</TD><TD> */</TD></TR><TR><TD CLASS="l">2238</TD><TD>protected synchronized Map getRemoteClients()</TD></TR><TR><TD CLASS="l">2239</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2240</TD><TD>        Map remoteClients = registrationMapHome.getActiveClientMapForSession(SessionNameValues.ALL_SESSION_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2241</TD><TD>    if (remoteClients.size() &lt; 1 )</TD></TR><TR><TD CLASS="l">2242</TD><TD>        {</TD></TR><TR><TD CLASS="l">2243</TD><TD> </TD></TR><TR><TD CLASS="l">2244</TD><TD>                // If we are setup as a server then only use the servers local impl</TD></TR><TR><TD CLASS="l">2245</TD><TD>                // do not try to locate the TSS clients</TD></TR><TR CLASS="z"><TD CLASS="l">2246</TD><TD>                if (useAsLocalImpl)</TD></TR><TR><TD CLASS="l">2247</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2248</TD><TD>                        return remoteClients;</TD></TR><TR><TD CLASS="l">2249</TD><TD>                }</TD></TR><TR><TD CLASS="l">2250</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2251</TD><TD>                TraderService ts = FoundationFramework.getInstance().getTraderService();</TD></TR><TR><TD CLASS="l">2252</TD><TD> </TD></TR><TR><TD CLASS="l">2253</TD><TD>                // &#34;Discover&#34; the clients via the TraderService</TD></TR><TR><TD CLASS="l">2254</TD><TD>                // Check the flag useRemoteRouteNameForClients because this flag if</TD></TR><TR><TD CLASS="l">2255</TD><TD>                // true helps us bring up multiple TSS's in different environments without</TD></TR><TR><TD CLASS="l">2256</TD><TD>                // one TSS interfering with the other.</TD></TR><TR CLASS="z"><TD CLASS="l">2257</TD><TD>                DirectoryQueryResult[] queryResult = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2258</TD><TD>                String constraint = useRemoteRouteNameForClients</TD></TR><TR><TD CLASS="l">2259</TD><TD>                                      ? &#34;routename==&#34; + RouteNameHelper.getRemoteRouteName()</TD></TR><TR><TD CLASS="l">2260</TD><TD>                                      : null;</TD></TR><TR><TD CLASS="l">2261</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2262</TD><TD>                String id = TradingSessionClientHelper.id();</TD></TR><TR><TD CLASS="l">2263</TD><TD>                // -MW extract the generic name of TradingSessionClient from id.</TD></TR><TR CLASS="z"><TD CLASS="l">2264</TD><TD>                String genericName =  com.cboe.domain.util.GenericName.getGenericName( id, ':');</TD></TR><TR CLASS="z"><TD CLASS="l">2265</TD><TD>                if ( null !=genericName )</TD></TR><TR><TD CLASS="l">2266</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>                   id = genericName;</TD></TR><TR><TD CLASS="l">2268</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2269</TD><TD>                Log.information(this,&#34;- Discovering TSS clients for id/constraint = &#34; + id + &#34;/&#34; + constraint);</TD></TR><TR><TD CLASS="l">2270</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2271</TD><TD>                queryResult = ts.queryDirectory(id, constraint);</TD></TR><TR><TD CLASS="l">2272</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2273</TD><TD>                if (queryResult == null || queryResult.length == 0)</TD></TR><TR><TD CLASS="l">2274</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2275</TD><TD>                        Log.information(this, &#34;No TradingSessionClient objects found for id/constraint = &#34; + id + &#34;/&#34; + constraint);</TD></TR><TR CLASS="z"><TD CLASS="l">2276</TD><TD>                        return remoteClients;</TD></TR><TR><TD CLASS="l">2277</TD><TD>                }</TD></TR><TR><TD CLASS="l">2278</TD><TD>                else</TD></TR><TR><TD CLASS="l">2279</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2280</TD><TD>                        Log.information(this,&#34;- Found &#34; + queryResult.length +</TD></TR><TR><TD CLASS="l">2281</TD><TD>                                                  &#34; Trading session clients for id/constraint = &#34; + id + &#34;/&#34; + constraint);</TD></TR><TR><TD CLASS="l">2282</TD><TD>                }</TD></TR><TR><TD CLASS="l">2283</TD><TD> </TD></TR><TR><TD CLASS="l">2284</TD><TD>                // Get the name of the client and put it in the internal hash table.</TD></TR><TR><TD CLASS="l">2285</TD><TD>                // Ignore all exceptions. Clients will re-register when they come back.</TD></TR><TR CLASS="z"><TD CLASS="l">2286</TD><TD>        boolean success=false;</TD></TR><TR><TD CLASS="l">2287</TD><TD>        TradingSessionClient client;</TD></TR><TR><TD CLASS="l">2288</TD><TD>        String clientName;</TD></TR><TR CLASS="z"><TD CLASS="l">2289</TD><TD>                for (int i=0; i &lt; queryResult.length; ++i)</TD></TR><TR><TD CLASS="l">2290</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2291</TD><TD>            success=false;</TD></TR><TR><TD CLASS="l">2292</TD><TD>                        try</TD></TR><TR><TD CLASS="l">2293</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2294</TD><TD>                client = (TradingSessionClient) ObjectResolver.resolveObject(queryResult[i].getObjectReference(), TradingSessionClientHelper.class.getName() );</TD></TR><TR CLASS="z"><TD CLASS="l">2295</TD><TD>                clientName = client.getClientId();</TD></TR><TR><TD CLASS="l">2296</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2297</TD><TD>            catch(Exception e)</TD></TR><TR><TD CLASS="l">2298</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2299</TD><TD>                java.util.Properties props = queryResult[i].getProperties();</TD></TR><TR CLASS="z"><TD CLASS="l">2300</TD><TD>                String logString = &#34;[RouteName(&#34; + props.get(&#34;routename&#34;) + &#34;)/ProcessName(&#34; + props.get(&#34;processname&#34;) + &#34;)&#34; ;</TD></TR><TR CLASS="z"><TD CLASS="l">2301</TD><TD>                Log.information(this,&#34;Error getting client name or narrowing remote reference for &#34; + logString + &#34;, when getting remote clients via trader. Exception - &#34; + e);</TD></TR><TR CLASS="z"><TD CLASS="l">2302</TD><TD>                continue;</TD></TR><TR CLASS="z"><TD CLASS="l">2303</TD><TD>            }</TD></TR><TR><TD CLASS="l">2304</TD><TD> </TD></TR><TR><TD CLASS="l">2305</TD><TD>            try</TD></TR><TR><TD CLASS="l">2306</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2307</TD><TD>                                Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">2308</TD><TD>                                registrationMapHome.updateClientState(clientName, client, true/*active*/);</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>                                 Log.information(this,&#34;Added remote client: &#34; + clientName);</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>                success = Transaction.commit();</TD></TR><TR><TD CLASS="l">2311</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2312</TD><TD>            catch(NotFoundException e)</TD></TR><TR><TD CLASS="l">2313</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2314</TD><TD>                java.util.Properties props = queryResult[i].getProperties();</TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>                String logString = &#34;[RouteName(&#34; + props.get(&#34;routename&#34;) + &#34;)/ProcessName(&#34; + props.get(&#34;processname&#34;) + &#34;)&#34; ;</TD></TR><TR CLASS="z"><TD CLASS="l">2316</TD><TD>                Log.information(this,&#34;Could not update the client state to be active because &#34; + logString + &#34; has never ever been registered.&#34;);</TD></TR><TR><TD CLASS="l">2317</TD><TD>            }</TD></TR><TR><TD CLASS="l">2318</TD><TD>            finally</TD></TR><TR><TD CLASS="l">2319</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">2320</TD><TD>                if(!success)</TD></TR><TR><TD CLASS="l">2321</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2322</TD><TD>                    Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">2323</TD><TD>                    java.util.Properties props = queryResult[i].getProperties();</TD></TR><TR CLASS="z"><TD CLASS="l">2324</TD><TD>                    String logString = &#34;[RouteName(&#34; + props.get(&#34;routename&#34;) + &#34;)/ProcessName(&#34; + props.get(&#34;processname&#34;) + &#34;)&#34; ;</TD></TR><TR CLASS="z"><TD CLASS="l">2325</TD><TD>                    Log.alarm(this, &#34;Could not commit the transaction  to update the client status of &#34; + logString);</TD></TR><TR CLASS="z"><TD CLASS="l">2326</TD><TD>                }</TD></TR><TR><TD CLASS="l">2327</TD><TD>            }</TD></TR><TR><TD CLASS="l">2328</TD><TD>                }</TD></TR><TR><TD CLASS="l">2329</TD><TD>        }</TD></TR><TR><TD CLASS="l">2330</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2331</TD><TD>        return registrationMapHome.getActiveClientMapForSession(SessionNameValues.ALL_SESSION_NAME);</TD></TR><TR><TD CLASS="l">2332</TD><TD>}</TD></TR><TR><TD CLASS="l">2333</TD><TD>/**</TD></TR><TR><TD CLASS="l">2334</TD><TD> *  Return the sessions currently accociated with a given template name.</TD></TR><TR><TD CLASS="l"><A NAME="4a">2335</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2336</TD><TD>public TradingSessionElementStruct[] getElementsForTemplate(String templateName)</TD></TR><TR><TD CLASS="l">2337</TD><TD>throws DataValidationException</TD></TR><TR><TD CLASS="l">2338</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2339</TD><TD>    verifyTemplateName(templateName);</TD></TR><TR><TD CLASS="l">2340</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">2341</TD><TD>        TradingSessionElement[] elements = elementHome.findAllForTemplate(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">2342</TD><TD>        TradingSessionElementStruct[] result = new TradingSessionElementStruct[elements.length];</TD></TR><TR CLASS="z"><TD CLASS="l">2343</TD><TD>        result = elementHome.toStructs(elements);</TD></TR><TR CLASS="z"><TD CLASS="l">2344</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">2345</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2346</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2347</TD><TD>        throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">2348</TD><TD>    }</TD></TR><TR><TD CLASS="l">2349</TD><TD>}</TD></TR><TR><TD CLASS="l">2350</TD><TD>/**</TD></TR><TR><TD CLASS="l">2351</TD><TD> *  Return the sessions currently accociated with a given session.</TD></TR><TR><TD CLASS="l"><A NAME="49">2352</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2353</TD><TD>public TradingSessionElementStruct[] getElementsForSession(String sessionName, DateStruct businessDay)</TD></TR><TR><TD CLASS="l">2354</TD><TD>throws DataValidationException</TD></TR><TR><TD CLASS="l">2355</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2356</TD><TD>    verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2357</TD><TD>    TradingSessionElement[] elements = elementHome.findForSession(sessionName, businessDay);</TD></TR><TR CLASS="z"><TD CLASS="l">2358</TD><TD>    return elementHome.toStructs(elements);</TD></TR><TR><TD CLASS="l">2359</TD><TD>}</TD></TR><TR><TD CLASS="l">2360</TD><TD>/**</TD></TR><TR><TD CLASS="l">2361</TD><TD> * Get all the strategies defined for a session.</TD></TR><TR><TD CLASS="l">2362</TD><TD> */</TD></TR><TR><TD CLASS="l">2363</TD><TD>public SessionStrategyStruct[] getStrategiesForSession(String sessionName)</TD></TR><TR><TD CLASS="l"><A NAME="6a">2364</A></TD><TD>    throws DataValidationException {</TD></TR><TR><TD CLASS="l">2365</TD><TD> </TD></TR><TR><TD CLASS="l">2366</TD><TD>    // fixme - this may be an inefficient way to get this, but don't see better way</TD></TR><TR><TD CLASS="l">2367</TD><TD>    // fixme - may want to use templates - this code relies on current elements existing</TD></TR><TR CLASS="z"><TD CLASS="l">2368</TD><TD>    SessionClassDetailStruct[] classes = getClassesForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2369</TD><TD>    ArrayList strategies = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">2370</TD><TD>    for (int i = 0; i &lt; classes.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2371</TD><TD>        if (classes[i].classDetail.classStruct.productType == ProductTypes.STRATEGY) {</TD></TR><TR CLASS="z"><TD CLASS="l">2372</TD><TD>            for (int j = 0; j &lt; classes[i].products.length; j++) {</TD></TR><TR><TD CLASS="l">2373</TD><TD> </TD></TR><TR><TD CLASS="l">2374</TD><TD>                try</TD></TR><TR><TD CLASS="l">2375</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2376</TD><TD>                    SessionStrategyStruct sessionStrategy =</TD></TR><TR><TD CLASS="l">2377</TD><TD>                        buildSessionStrategyStruct(classes[i].products[j], sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2378</TD><TD>                    strategies.add(sessionStrategy);</TD></TR><TR><TD CLASS="l">2379</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2380</TD><TD>                catch(Exception e)</TD></TR><TR><TD CLASS="l">2381</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2382</TD><TD>                    Log.alarm(this, &#34;Strategy not found in ProductQueryService: &#34; + classes[i].products[j].productStruct.productKeys);</TD></TR><TR CLASS="z"><TD CLASS="l">2383</TD><TD>                }</TD></TR><TR><TD CLASS="l">2384</TD><TD>            }</TD></TR><TR><TD CLASS="l">2385</TD><TD>        }</TD></TR><TR><TD CLASS="l">2386</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2387</TD><TD>    SessionStrategyStruct[] result = new SessionStrategyStruct[strategies.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2388</TD><TD>    strategies.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">2389</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2390</TD><TD>}</TD></TR><TR><TD CLASS="l">2391</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="6c">2392</A></TD><TD> * Get the template struct which corresponds to a given template name.</TD></TR><TR><TD CLASS="l">2393</TD><TD> */</TD></TR><TR><TD CLASS="l">2394</TD><TD>public TradingSessionElementTemplateStruct getTemplate(String templateName) throws NotFoundException</TD></TR><TR><TD CLASS="l">2395</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2396</TD><TD>        TradingSessionElementTemplate template = templateHome.findByName(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">2397</TD><TD>        return templateHome.toStruct(template);</TD></TR><TR><TD CLASS="l">2398</TD><TD>}</TD></TR><TR><TD CLASS="l">2399</TD><TD>/**</TD></TR><TR><TD CLASS="l">2400</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="71">2401</A></TD><TD> * @return publisher for trading session channel</TD></TR><TR><TD CLASS="l">2402</TD><TD> */</TD></TR><TR><TD CLASS="l">2403</TD><TD>public TradingSessionEventStateConsumer getTradingSessionEventStatePublisher()</TD></TR><TR><TD CLASS="l">2404</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2405</TD><TD>        if (tradingSessionEventStatePublisher == null)</TD></TR><TR><TD CLASS="l">2406</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2407</TD><TD>        tradingSessionEventStatePublisher = EventHomes.getTradingSessionEventStateConsumerHome().find();</TD></TR><TR><TD CLASS="l">2408</TD><TD>        }</TD></TR><TR><TD CLASS="l">2409</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2410</TD><TD>        return tradingSessionEventStatePublisher;</TD></TR><TR><TD CLASS="l">2411</TD><TD>}</TD></TR><TR><TD CLASS="l">2412</TD><TD>/**</TD></TR><TR><TD CLASS="l">2413</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="72">2414</A></TD><TD> * @return publisher for trading session channel</TD></TR><TR><TD CLASS="l">2415</TD><TD> */</TD></TR><TR><TD CLASS="l">2416</TD><TD>public TradingSessionConsumer getTradingSessionPublisher()</TD></TR><TR><TD CLASS="l">2417</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2418</TD><TD>        if (tradingSessionPublisher == null)</TD></TR><TR><TD CLASS="l">2419</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2420</TD><TD>        tradingSessionPublisher = EventHomes.getTradingSessionConsumerHome().find();</TD></TR><TR><TD CLASS="l">2421</TD><TD>        }</TD></TR><TR><TD CLASS="l">2422</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2423</TD><TD>        return tradingSessionPublisher;</TD></TR><TR><TD CLASS="l">2424</TD><TD>}</TD></TR><TR><TD CLASS="l">2425</TD><TD>/**</TD></TR><TR><TD CLASS="l">2426</TD><TD> * Returns the trading session group whose name matches the given parameter</TD></TR><TR><TD CLASS="l"><A NAME="70">2427</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2428</TD><TD>public TradingSessionStruct getTradingSessionByName(String sessionName)</TD></TR><TR><TD CLASS="l">2429</TD><TD>    throws NotFoundException</TD></TR><TR><TD CLASS="l">2430</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2431</TD><TD>        TradingSessionImpl session = (TradingSessionImpl)sessionHome.find(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2432</TD><TD>    return session.toStruct();</TD></TR><TR><TD CLASS="l">2433</TD><TD>}</TD></TR><TR><TD CLASS="l">2434</TD><TD>/**</TD></TR><TR><TD CLASS="l">2435</TD><TD> * Returns all the defined trading session.</TD></TR><TR><TD CLASS="l">2436</TD><TD> * @return TradingSessionStruct[]</TD></TR><TR><TD CLASS="l"><A NAME="75">2437</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2438</TD><TD>public TradingSessionStruct[] getTradingSessions()</TD></TR><TR><TD CLASS="l">2439</TD><TD>{</TD></TR><TR><TD CLASS="l">2440</TD><TD>        // find the groups</TD></TR><TR CLASS="z"><TD CLASS="l">2441</TD><TD>        TradingSession sessions[] = sessionHome.findAll();</TD></TR><TR><TD CLASS="l">2442</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2443</TD><TD>    return sessionHome.toStructs(sessions);</TD></TR><TR><TD CLASS="l">2444</TD><TD>}</TD></TR><TR><TD CLASS="l">2445</TD><TD>/**</TD></TR><TR><TD CLASS="l">2446</TD><TD> * Return an array session structs that are in the specified time range.</TD></TR><TR><TD CLASS="l">2447</TD><TD> * Always go the database for this.</TD></TR><TR><TD CLASS="l">2448</TD><TD> *</TD></TR><TR><TD CLASS="l">2449</TD><TD> * @param DateTimeStruct startTime</TD></TR><TR><TD CLASS="l">2450</TD><TD> * @param DateTimeStruct endTime;</TD></TR><TR><TD CLASS="l"><A NAME="76">2451</A></TD><TD> * @return TradingSessionStruct[]</TD></TR><TR><TD CLASS="l">2452</TD><TD> */</TD></TR><TR><TD CLASS="l">2453</TD><TD>public TradingSessionStruct[] getTradingSessionsByTime(TimeStruct startTime,TimeStruct endTime) throws CommunicationException, SystemException, AuthorizationException</TD></TR><TR><TD CLASS="l">2454</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2455</TD><TD>    long queryStartTime = TimeHelper.toMillisSinceMidnight(startTime);</TD></TR><TR CLASS="z"><TD CLASS="l">2456</TD><TD>    long queryEndTime = TimeHelper.toMillisSinceMidnight(endTime);</TD></TR><TR CLASS="z"><TD CLASS="l">2457</TD><TD>    ArrayList foundSessions = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">2458</TD><TD>    TradingSession[] sessions = sessionHome.findAll();</TD></TR><TR CLASS="z"><TD CLASS="l">2459</TD><TD>    for (int i = 0; i &lt; sessions.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2460</TD><TD>        if (TimeHelper.timesAreOverlapping(queryStartTime, queryEndTime, sessions[i].getStartTime(), sessions[i].getEndTime())) {</TD></TR><TR CLASS="z"><TD CLASS="l">2461</TD><TD>            foundSessions.add(sessionHome.toStruct(sessions[i]));</TD></TR><TR><TD CLASS="l">2462</TD><TD>        }</TD></TR><TR><TD CLASS="l">2463</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2464</TD><TD>    TradingSessionStruct[] result = new TradingSessionStruct[foundSessions.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2465</TD><TD>    foundSessions.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">2466</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2467</TD><TD>}</TD></TR><TR><TD CLASS="l">2468</TD><TD>/**</TD></TR><TR><TD CLASS="l">2469</TD><TD> * Returns the list of classes not assigned to any template.</TD></TR><TR><TD CLASS="l">2470</TD><TD> * @return com.cboe.idl.cmiProduct.ClassStruct[]</TD></TR><TR><TD CLASS="l">2471</TD><TD> * @exception SystemException</TD></TR><TR><TD CLASS="l">2472</TD><TD> * @exception AuthorizationException</TD></TR><TR><TD CLASS="l">2473</TD><TD> * @exception CommunicationException</TD></TR><TR><TD CLASS="l">2474</TD><TD> */</TD></TR><TR><TD CLASS="l">2475</TD><TD>public ClassStruct[] getUnassignedClasses(String sessionName) throws DataValidationException, SystemException,AuthorizationException,CommunicationException</TD></TR><TR><TD CLASS="l">2476</TD><TD>{</TD></TR><TR><TD CLASS="l">2477</TD><TD>        // Get the product classes from PCS.</TD></TR><TR><TD CLASS="l"><A NAME="78">2478</A></TD><TD> </TD></TR><TR><TD CLASS="l">2479</TD><TD>        ProductClassStruct[] classes;</TD></TR><TR><TD CLASS="l">2480</TD><TD> </TD></TR><TR><TD CLASS="l">2481</TD><TD>        // Now get all the un assigned classes.</TD></TR><TR CLASS="z"><TD CLASS="l">2482</TD><TD>        ClassStruct[] result = new ClassStruct[0];</TD></TR><TR><TD CLASS="l">2483</TD><TD>        try</TD></TR><TR><TD CLASS="l">2484</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2485</TD><TD>        TradingSession session = verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">2486</TD><TD>                BOHome home = HomeFactory.getInstance().findHome(ProductQueryServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2487</TD><TD>                ProductQueryService pqs = ((ProductQueryServiceHome)home).find();</TD></TR><TR CLASS="z"><TD CLASS="l">2488</TD><TD>                classes = pqs.getProductClasses(true/*onlyActive*/, false/*notReportingClasses*/, false/*noProducts*/);</TD></TR><TR CLASS="z"><TD CLASS="l">2489</TD><TD>                result = session.getUnassignedClasses(classes);</TD></TR><TR><TD CLASS="l">2490</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2491</TD><TD>        catch (CBOELoggableException e)</TD></TR><TR><TD CLASS="l">2492</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2493</TD><TD>                throw ExceptionBuilder.systemException(e.toString(),0);</TD></TR><TR CLASS="z"><TD CLASS="l">2494</TD><TD>        }</TD></TR><TR><TD CLASS="l">2495</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2496</TD><TD>        return  result;</TD></TR><TR><TD CLASS="l">2497</TD><TD>}</TD></TR><TR><TD CLASS="l">2498</TD><TD> </TD></TR><TR><TD CLASS="l">2499</TD><TD>/**</TD></TR><TR><TD CLASS="l">2500</TD><TD> *  Returns the list of registered clients(servers) for all sessions.</TD></TR><TR><TD CLASS="l">2501</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="73">2502</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2503</TD><TD>public TradingSessionRegistrationStruct[] getTradingSessionRegistrationNames()</TD></TR><TR><TD CLASS="l">2504</TD><TD>        throws DataValidationException, AuthorizationException, TransactionFailedException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">2505</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2506</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">2507</TD><TD>        Log.debug(this, &#34;getting all the valid registered clients for all sessions&#34;);</TD></TR><TR><TD CLASS="l">2508</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2509</TD><TD>    return registrationMapHome.getRegisteredServerNames(TradingSessionService.ALL_SESSIONS);</TD></TR><TR><TD CLASS="l">2510</TD><TD>}</TD></TR><TR><TD CLASS="l">2511</TD><TD> </TD></TR><TR><TD CLASS="l">2512</TD><TD>/**</TD></TR><TR><TD CLASS="l">2513</TD><TD> *  Returns the list of TradingSessionGroupStruct for all Sessions. Returning the only groups for which the product state changes are allowed</TD></TR><TR><TD CLASS="l">2514</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="74">2515</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2516</TD><TD>public TradingSessionGroupStruct[] getTradingSessionRoutingGroupNames()</TD></TR><TR><TD CLASS="l">2517</TD><TD>        throws DataValidationException, AuthorizationException, TransactionFailedException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">2518</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2519</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>        Log.debug(this, &#34;getting all the valid groups(trade servers) for all sessions&#34;);</TD></TR><TR><TD CLASS="l">2521</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2522</TD><TD>    return registrationMapHome.getRegisteredGroups(groupTypeForProductState);</TD></TR><TR><TD CLASS="l">2523</TD><TD>}</TD></TR><TR><TD CLASS="l">2524</TD><TD> </TD></TR><TR><TD CLASS="l">2525</TD><TD>/**</TD></TR><TR><TD CLASS="l">2526</TD><TD> *</TD></TR><TR><TD CLASS="l">2527</TD><TD> * get the history Event.</TD></TR><TR><TD CLASS="l"><A NAME="51">2528</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2529</TD><TD>public TradingSessionEventHistoryStructV2[] getEventHistoryV2(String sessionName)</TD></TR><TR><TD CLASS="l">2530</TD><TD>        throws DataValidationException, AuthorizationException, TransactionFailedException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">2531</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2532</TD><TD>    verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">2533</TD><TD>    Collection entries;</TD></TR><TR><TD CLASS="l">2534</TD><TD>    try</TD></TR><TR><TD CLASS="l">2535</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2536</TD><TD>        entries = getEventHistoryHome().findBySession(sessionName);</TD></TR><TR><TD CLASS="l">2537</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2538</TD><TD>    catch (TransactionFailedException ex)</TD></TR><TR><TD CLASS="l">2539</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2540</TD><TD>        String err = &#34;Persistence error querying for history : &#34; + ex;</TD></TR><TR CLASS="z"><TD CLASS="l">2541</TD><TD>        Log.exception(err, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">2542</TD><TD>        throw ExceptionBuilder.systemException(err, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">2543</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2544</TD><TD>    TradingSessionEventHistoryStructV2[] result = new TradingSessionEventHistoryStructV2[entries.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">2545</TD><TD>    Iterator iter = entries.iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">2546</TD><TD>    for (int i=0; iter.hasNext(); i++)</TD></TR><TR><TD CLASS="l">2547</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2548</TD><TD>        TradingSessionEventHistoryEntry entry = (TradingSessionEventHistoryEntry)iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">2549</TD><TD>        result[i] = getEventHistoryHome().convertToV2Struct(entry);</TD></TR><TR><TD CLASS="l">2550</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2551</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">2552</TD><TD>}</TD></TR><TR><TD CLASS="l">2553</TD><TD> </TD></TR><TR><TD CLASS="l">2554</TD><TD>/**</TD></TR><TR><TD CLASS="l">2555</TD><TD> * Get the Registered server event states for the given session.</TD></TR><TR><TD CLASS="l">2556</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="64">2557</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2558</TD><TD>public TradingSessionServerEventStateStruct[] getRegisteredServersEventState(String sessionName)</TD></TR><TR><TD CLASS="l">2559</TD><TD>        throws DataValidationException, AuthorizationException, TransactionFailedException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">2560</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2561</TD><TD>    return registrationMapHome.getClientEventStates(sessionName);</TD></TR><TR><TD CLASS="l">2562</TD><TD>}</TD></TR><TR><TD CLASS="l">2563</TD><TD> </TD></TR><TR><TD CLASS="l">2564</TD><TD> </TD></TR><TR><TD CLASS="l">2565</TD><TD>/**</TD></TR><TR><TD CLASS="l">2566</TD><TD> * Initialize this service instance using properties accessed from configService using the given</TD></TR><TR><TD CLASS="l">2567</TD><TD> * prefix.</TD></TR><TR><TD CLASS="l">2568</TD><TD> *</TD></TR><TR><TD CLASS="l">2569</TD><TD> * Also, to provide a mapping between trading session templates and session codes downloaded from TPF,</TD></TR><TR><TD CLASS="l">2570</TD><TD> * we use a set of configuration properties:</TD></TR><TR><TD CLASS="l">2571</TD><TD> * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">2572</TD><TD> *        sessionCodeMapping.templates=&lt;listOfTemplateNames&gt;</TD></TR><TR><TD CLASS="l">2573</TD><TD> *        sessionCodeMapping.template.&lt;templateName&gt;.sessionCodes=&lt;listOfSessionCodes&gt;</TD></TR><TR><TD CLASS="l">2574</TD><TD> * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">2575</TD><TD> *</TD></TR><TR><TD CLASS="l">2576</TD><TD> * Defaults will be used if any of these properties are not present.</TD></TR><TR><TD CLASS="l">2577</TD><TD> *</TD></TR><TR><TD CLASS="l">2578</TD><TD> * &lt;p&gt;This method is probably only invoked by the TradingSessionServiceHomeImpl class.</TD></TR><TR><TD CLASS="l">2579</TD><TD> *</TD></TR><TR><TD CLASS="l">2580</TD><TD> * &lt;p&gt;If the &lt;prefix&gt;.debug property exists and is &#34;true&#34;, then low-low level</TD></TR><TR><TD CLASS="l">2581</TD><TD> *   debugging will be enabled.</TD></TR><TR><TD CLASS="l">2582</TD><TD> *</TD></TR><TR><TD CLASS="l">2583</TD><TD> * @param configPrefix - the prefix string for properties relating to this service.</TD></TR><TR><TD CLASS="l">2584</TD><TD> * @param configService - the config service from whom to get the property values.</TD></TR><TR><TD CLASS="l"><A NAME="79">2585</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2586</TD><TD>public void initialize()</TD></TR><TR><TD CLASS="l">2587</TD><TD>                throws NoSuchPropertyException, InappropriateValueException</TD></TR><TR><TD CLASS="l">2588</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2589</TD><TD>        Log.information(this, &#34;Initializing...&#34;);</TD></TR><TR><TD CLASS="l">2590</TD><TD> </TD></TR><TR><TD CLASS="l">2591</TD><TD>        // Setup all needed instance variables.</TD></TR><TR CLASS="z"><TD CLASS="l">2592</TD><TD>        timerService = FoundationFramework.getInstance().getTimeService();</TD></TR><TR CLASS="z"><TD CLASS="l">2593</TD><TD>    serviceRecoveryManager = new ServiceRecoveryManager();</TD></TR><TR CLASS="z"><TD CLASS="l">2594</TD><TD>        serviceRecoveryManager.setTimerService(timerService);</TD></TR><TR><TD CLASS="l">2595</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2596</TD><TD>    if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2597</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2598</TD><TD>            Log.debug( this, &#34;Created ServiceRecoveryManager&#34; );</TD></TR><TR><TD CLASS="l">2599</TD><TD>    }</TD></TR><TR><TD CLASS="l">2600</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2601</TD><TD>    adjustedOrdersLogger = new PendingAdjustedmentOrdersLogger();</TD></TR><TR><TD CLASS="l">2602</TD><TD>        // Get properties from home</TD></TR><TR CLASS="z"><TD CLASS="l">2603</TD><TD>    Configuration config = new Configuration(getBOHome());</TD></TR><TR CLASS="z"><TD CLASS="l">2604</TD><TD>        amiCallbackTimerValue = config.getInt(&#34;amiCallbackTimeoutMillis&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2605</TD><TD>        serviceRecoveryManager.setTimeout(config.getInt(&#34;serviceLostTimeoutMillis&#34;));</TD></TR><TR CLASS="z"><TD CLASS="l">2606</TD><TD>        useRemoteRouteNameForClients = config.getBoolean(&#34;useRemoteRouteNameForClients&#34;, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2607</TD><TD>    underlyingStateOpenTriggeredSessions = config.getPropertyList(&#34;underlyingStateOpenTriggeredSessions&#34;,&#34;, &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2608</TD><TD>    underlyingStateHaltTriggeredSessions = config.getPropertyList(&#34;underlyingStateHaltTriggeredSessions&#34;,&#34;, &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2609</TD><TD>    underlyingStateHaltTriggeredSTOCKSessions = config.getPropertyList(&#34;underlyingStateHaltTriggeredStockSessions&#34;,&#34;, &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2610</TD><TD>    productStateImpl = config.getProperty(PRODUCT_STATE_CHANGE_IMPL);</TD></TR><TR CLASS="z"><TD CLASS="l">2611</TD><TD>        blockAutoTransitionFromSuspended = config.getBoolean(&#34;blockAutoTransitionFromSuspended&#34;, true);</TD></TR><TR CLASS="z"><TD CLASS="l">2612</TD><TD>    nonAdminProductStateImplementation = instantiateProductStateChangeStrategy(productStateImpl);</TD></TR><TR CLASS="z"><TD CLASS="l">2613</TD><TD>    groupTypeForProductState = config.getInt(&#34;groupTypeForProductState&#34;);</TD></TR><TR><TD CLASS="l">2614</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2615</TD><TD>    doublePublishSessionEventHistory = new Boolean(getBOHome().getProperty(&#34;doublePublishSessionEventHistory&#34;)).booleanValue();</TD></TR><TR CLASS="z"><TD CLASS="l">2616</TD><TD>    startSessionAbortOnError = new Boolean(getBOHome().getProperty(&#34;startSessionAbortOnError&#34;)).booleanValue();</TD></TR><TR CLASS="z"><TD CLASS="l">2617</TD><TD>    endOfDayPurgeAbortOnError = new Boolean(getBOHome().getProperty(&#34;endOfDayPurgeAbortOnError&#34;)).booleanValue();</TD></TR><TR CLASS="z"><TD CLASS="l">2618</TD><TD>    includeReportingClassesInBusinessDayStruct = new Boolean(getBOHome().getProperty(&#34;includeReportingClassesInBusinessDayStruct&#34;)).booleanValue();</TD></TR><TR><TD CLASS="l">2619</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2620</TD><TD>    Log.information(&#34;Value of startSessionAbortOnError is :&#34; + startSessionAbortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">2621</TD><TD>    Log.information(&#34;Value of endOfDayPurgeAbortOnError is :&#34; + endOfDayPurgeAbortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">2622</TD><TD>    Log.information(&#34;Value of doublePublishSessionEventHistory is :&#34; + doublePublishSessionEventHistory);</TD></TR><TR CLASS="z"><TD CLASS="l">2623</TD><TD>    Log.information(&#34;Value of includeReportingClassesInBusinessDayStruct is :&#34; + includeReportingClassesInBusinessDayStruct);</TD></TR><TR><TD CLASS="l">2624</TD><TD> </TD></TR><TR><TD CLASS="l">2625</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2626</TD><TD>    String output = &#34;Underlying products state change OPEN trigger list of sessions: &#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2627</TD><TD>    for (int i = 0; i &lt; underlyingStateOpenTriggeredSessions.length; i++)</TD></TR><TR><TD CLASS="l">2628</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2629</TD><TD>        output += underlyingStateOpenTriggeredSessions[i] + &#34;, &#34;;</TD></TR><TR><TD CLASS="l">2630</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2631</TD><TD>    Log.information(this,output);</TD></TR><TR><TD CLASS="l">2632</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2633</TD><TD>    output = &#34;Underlying products state change HALT trigger list of sessions: &#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2634</TD><TD>    for (int i = 0; i &lt; underlyingStateHaltTriggeredSessions.length; i++)</TD></TR><TR><TD CLASS="l">2635</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2636</TD><TD>        output += underlyingStateHaltTriggeredSessions[i] + &#34;, &#34;;</TD></TR><TR><TD CLASS="l">2637</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2638</TD><TD>    Log.information(this,output);</TD></TR><TR><TD CLASS="l">2639</TD><TD>    </TD></TR><TR CLASS="z"><TD CLASS="l">2640</TD><TD>    output = &#34;Underlying products state change HALT trigger list of STOCK sessions: &#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2641</TD><TD>    for (int i = 0; i &lt; this.underlyingStateHaltTriggeredSTOCKSessions.length; i++)</TD></TR><TR><TD CLASS="l">2642</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2643</TD><TD>        output += underlyingStateHaltTriggeredSTOCKSessions[i] + &#34;, &#34;;</TD></TR><TR><TD CLASS="l">2644</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2645</TD><TD>    Log.information(this,output);</TD></TR><TR><TD CLASS="l">2646</TD><TD>    </TD></TR><TR><TD CLASS="l">2647</TD><TD>        // Create the strategy factory for end of session/day processing.</TD></TR><TR CLASS="z"><TD CLASS="l">2648</TD><TD>        strategyFactory = new TradingSessionStrategyFactory(config, this);</TD></TR><TR><TD CLASS="l">2649</TD><TD> </TD></TR><TR><TD CLASS="l">2650</TD><TD>        // Register the admin callback methods.</TD></TR><TR><TD CLASS="l">2651</TD><TD>        try</TD></TR><TR><TD CLASS="l">2652</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2653</TD><TD>                commands.registerCallbacks();</TD></TR><TR><TD CLASS="l">2654</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2655</TD><TD>        catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException ex)</TD></TR><TR><TD CLASS="l">2656</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2657</TD><TD>                Log.exception(this, &#34;Failed to register callbacks&#34;, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">2658</TD><TD>        }</TD></TR><TR><TD CLASS="l">2659</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2660</TD><TD>    if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2661</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2662</TD><TD>            Log.debug( this, &#34;Registered the callbacks&#34; );</TD></TR><TR><TD CLASS="l">2663</TD><TD>    }</TD></TR><TR><TD CLASS="l">2664</TD><TD> </TD></TR><TR><TD CLASS="l">2665</TD><TD>         // Find the group home.</TD></TR><TR><TD CLASS="l">2666</TD><TD>        try</TD></TR><TR><TD CLASS="l">2667</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2668</TD><TD>                sessionHome = (TradingSessionHome)HomeFactory.getInstance().findHome(TradingSessionHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2669</TD><TD>            templateHome = (TradingSessionElementTemplateHome)HomeFactory.getInstance().findHome(TradingSessionElementTemplateHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2670</TD><TD>            templateClassHome = (TemplateClassHome)HomeFactory.getInstance().findHome(TemplateClassHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2671</TD><TD>            elementHome  = (TradingSessionElementHome)HomeFactory.getInstance().findHome(TradingSessionElementHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2672</TD><TD>            elementClassHome  = (SessionElementClassHome)HomeFactory.getInstance().findHome(SessionElementClassHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2673</TD><TD>        registrationMapHome = (TradingSessionRegistrationMapHome) HomeFactory.getInstance().findHome(TradingSessionRegistrationMapHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">2674</TD><TD>                if (sessionHome == null || templateHome == null || templateClassHome == null || elementHome == null || elementClassHome == null || registrationMapHome == null)</TD></TR><TR><TD CLASS="l">2675</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2676</TD><TD>                        throw new NullPointerException(&#34;Unable to find home required home&#34;);</TD></TR><TR><TD CLASS="l">2677</TD><TD>                }</TD></TR><TR><TD CLASS="l">2678</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2679</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">2680</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2681</TD><TD>                throw new NullPointerException(&#34;Unable to find home required home&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2682</TD><TD>        }</TD></TR><TR><TD CLASS="l">2683</TD><TD> </TD></TR><TR><TD CLASS="l">2684</TD><TD>        // Get end of business day strategy.</TD></TR><TR><TD CLASS="l">2685</TD><TD>        try</TD></TR><TR><TD CLASS="l">2686</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2687</TD><TD>                eobdStrategy = strategyFactory.getEndOfBusinessDayStrategy(null);</TD></TR><TR><TD CLASS="l">2688</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2690</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2691</TD><TD>                throw new NullPointerException(&#34;Unable to get strategy for End Of Business day.&#34; + e);</TD></TR><TR CLASS="z"><TD CLASS="l">2692</TD><TD>        }</TD></TR><TR><TD CLASS="l">2693</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2694</TD><TD>        Log.information(this, &#34;Initialization complete...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2695</TD><TD>}</TD></TR><TR><TD CLASS="l">2696</TD><TD>/**</TD></TR><TR><TD CLASS="l">2697</TD><TD> *  Modify the trading session described by the data in TradingSessionStruct.</TD></TR><TR><TD CLASS="l">2698</TD><TD> *  This method will only succeed if the sessionKey in the struct already</TD></TR><TR><TD CLASS="l">2699</TD><TD> *  exists in the TSS.</TD></TR><TR><TD CLASS="l"><A NAME="8b">2700</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2701</TD><TD>public void modifyTradingSessionElement(TradingSessionElementStruct elementStruct)</TD></TR><TR><TD CLASS="l">2702</TD><TD>        throws DataValidationException, TransactionFailedException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">2703</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2704</TD><TD>        boolean committed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2705</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">2706</TD><TD>        try</TD></TR><TR><TD CLASS="l">2707</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2708</TD><TD>                elementHome.updateElement(elementStruct);</TD></TR><TR><TD CLASS="l">2709</TD><TD>                // Add to database</TD></TR><TR CLASS="z"><TD CLASS="l">2710</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">2711</TD><TD>                if (committed)</TD></TR><TR><TD CLASS="l">2712</TD><TD>                {</TD></TR><TR><TD CLASS="l">2713</TD><TD>                        try</TD></TR><TR><TD CLASS="l">2714</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2715</TD><TD>                                publishTradingSessionElementUpdate(elementStruct);</TD></TR><TR><TD CLASS="l">2716</TD><TD>                                // If all OK.</TD></TR><TR CLASS="z"><TD CLASS="l">2717</TD><TD>                                Log.information(this,&#34;Modified element identified by key(&#34; + elementStruct.elementKey + &#34;)&#34;);</TD></TR><TR><TD CLASS="l">2718</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2719</TD><TD>                        catch (Exception e)</TD></TR><TR><TD CLASS="l">2720</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2721</TD><TD>                                Log.exception(&#34;Exception on publishTradingSessionElementUpdate&#34;,e);</TD></TR><TR CLASS="z"><TD CLASS="l">2722</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2723</TD><TD>        }</TD></TR><TR><TD CLASS="l">2724</TD><TD>        else</TD></TR><TR><TD CLASS="l">2725</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2726</TD><TD>                        throw ExceptionBuilder.transactionFailedException(&#34;Error committing transaction : &#34; , 0);</TD></TR><TR><TD CLASS="l">2727</TD><TD>                }</TD></TR><TR><TD CLASS="l">2728</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2729</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2730</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2731</TD><TD>                throw ExceptionBuilder.dataValidationException(e.details.message,DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">2732</TD><TD>        }</TD></TR><TR><TD CLASS="l">2733</TD><TD>        finally</TD></TR><TR><TD CLASS="l">2734</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2735</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">2736</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2737</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">2738</TD><TD>                }</TD></TR><TR><TD CLASS="l">2739</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2740</TD><TD>}</TD></TR><TR><TD CLASS="l">2741</TD><TD> </TD></TR><TR><TD CLASS="l">2742</TD><TD>/**</TD></TR><TR><TD CLASS="l">2743</TD><TD> * publish TradingSessionStateEvent</TD></TR><TR><TD CLASS="l">2744</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="96">2745</A></TD><TD>private void publishTradingSessionElementUpdate(TradingSessionElementStruct sessionElement) {</TD></TR><TR><TD CLASS="l">2746</TD><TD>        </TD></TR><TR><TD CLASS="l">2747</TD><TD> </TD></TR><TR><TD CLASS="l">2748</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">2749</TD><TD>    TradingSessionConsumer channel = getTradingSessionPublisher();</TD></TR><TR CLASS="z"><TD CLASS="l">2750</TD><TD>    Log.information(this, &#34;Begin publishing Trading Session Element &#34; + sessionElement.elementName + &#34; of session &#34;+ sessionElement.sessionName + &#34; to event channel. Got publisher.  Is null? &#34; + (channel==null));</TD></TR><TR CLASS="z"><TD CLASS="l">2751</TD><TD>    if (channel != null){</TD></TR><TR><TD CLASS="l">2752</TD><TD>            try        {</TD></TR><TR CLASS="z"><TD CLASS="l">2753</TD><TD>                    channel.acceptTradingSessionElementUpdate(sessionElement);</TD></TR><TR CLASS="z"><TD CLASS="l">2754</TD><TD>            Log.information(this, &#34;Trading Session Element &#34; + sessionElement.elementName + &#34;: published event.&#34;);</TD></TR><TR><TD CLASS="l">2755</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2756</TD><TD>            catch (Exception ex){</TD></TR><TR CLASS="z"><TD CLASS="l">2757</TD><TD>                        Log.alarm(this, &#34;Unexpected error publishing to TradingSessionState event channel: &#34; + ex);</TD></TR><TR CLASS="z"><TD CLASS="l">2758</TD><TD>            }</TD></TR><TR><TD CLASS="l">2759</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2760</TD><TD>}</TD></TR><TR><TD CLASS="l">2761</TD><TD>/**</TD></TR><TR><TD CLASS="l">2762</TD><TD> * Modifies the trading session group with the new values.</TD></TR><TR><TD CLASS="l">2763</TD><TD> * Old group obviously must exist.</TD></TR><TR><TD CLASS="l">2764</TD><TD> * @param newValues com.cboe.idl.session.TradingSessionStruct</TD></TR><TR><TD CLASS="l">2765</TD><TD> * @exception SystemException id errors commiting transaction.</TD></TR><TR><TD CLASS="l"><A NAME="8a">2766</A></TD><TD> * @exception DataValiadationException if the group is not found of if the strategy s not found.</TD></TR><TR><TD CLASS="l">2767</TD><TD> */</TD></TR><TR><TD CLASS="l">2768</TD><TD>public void modifyTradingSession(TradingSessionStruct newValues) throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">2769</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2770</TD><TD>        boolean success = false;</TD></TR><TR><TD CLASS="l">2771</TD><TD> </TD></TR><TR><TD CLASS="l">2772</TD><TD>        try</TD></TR><TR><TD CLASS="l">2773</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2774</TD><TD>            Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">2775</TD><TD>                sessionHome.updateSession(newValues);</TD></TR><TR CLASS="z"><TD CLASS="l">2776</TD><TD>                success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">2777</TD><TD>                if (success)</TD></TR><TR><TD CLASS="l">2778</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2779</TD><TD>                Log.information(this,&#34;Modified session group : &#34; + newValues.sessionName);</TD></TR><TR><TD CLASS="l">2780</TD><TD>        }</TD></TR><TR><TD CLASS="l">2781</TD><TD>        else</TD></TR><TR><TD CLASS="l">2782</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2783</TD><TD>                        throw ExceptionBuilder.systemException(&#34;Error commiting update transaction for session: &#34; + newValues.sessionName,0);</TD></TR><TR><TD CLASS="l">2784</TD><TD>                }</TD></TR><TR><TD CLASS="l">2785</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2786</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2787</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2788</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Unable to modify session, session does not exist: &#34; + newValues.sessionName,0);</TD></TR><TR><TD CLASS="l">2789</TD><TD>        }</TD></TR><TR><TD CLASS="l">2790</TD><TD>        finally</TD></TR><TR><TD CLASS="l">2791</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2792</TD><TD>                if (!success) // Commit failed.</TD></TR><TR><TD CLASS="l">2793</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2794</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">2795</TD><TD>                }</TD></TR><TR><TD CLASS="l">2796</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2797</TD><TD>}</TD></TR><TR><TD CLASS="l">2798</TD><TD>/**</TD></TR><TR><TD CLASS="l">2799</TD><TD> *  Modify the given trading session template to be the data contained in the</TD></TR><TR><TD CLASS="l">2800</TD><TD> *  struct being passed in.  This methodf will only succeed if the templateName</TD></TR><TR><TD CLASS="l">2801</TD><TD> *  element of the struct already exists in the TSS.</TD></TR><TR><TD CLASS="l"><A NAME="8c">2802</A></TD><TD> */</TD></TR><TR><TD CLASS="l">2803</TD><TD>public void modifyTradingSessionTemplate(TradingSessionElementTemplateStruct templateStruct)</TD></TR><TR><TD CLASS="l">2804</TD><TD>        throws TransactionFailedException, DataValidationException, CommunicationException, SystemException, AuthorizationException</TD></TR><TR><TD CLASS="l">2805</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2806</TD><TD>    if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2807</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2808</TD><TD>        Log.debug(this, &#34;Modify trading session template &#34; + templateStruct.templateName);</TD></TR><TR><TD CLASS="l">2809</TD><TD>    }</TD></TR><TR><TD CLASS="l">2810</TD><TD>    TradingSession parentSession;</TD></TR><TR CLASS="z"><TD CLASS="l">2811</TD><TD>        parentSession = verifySessionName(templateStruct.sessionName);</TD></TR><TR><TD CLASS="l">2812</TD><TD>        // Product close time must be &lt; end time.</TD></TR><TR CLASS="z"><TD CLASS="l">2813</TD><TD>        if (TimeHelper.toMillisSinceMidnight(templateStruct.productCloseTime) &gt;= parentSession.getEndTime())</TD></TR><TR><TD CLASS="l">2814</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2815</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Product Close Time cannot be greater than Session End Time.&#34;, DataValidationCodes.INVALID_TIME);</TD></TR><TR><TD CLASS="l">2816</TD><TD>        }</TD></TR><TR><TD CLASS="l">2817</TD><TD> </TD></TR><TR><TD CLASS="l">2818</TD><TD>        // Start the add in a transaction.</TD></TR><TR CLASS="z"><TD CLASS="l">2819</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">2820</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2821</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">2822</TD><TD>        try</TD></TR><TR><TD CLASS="l">2823</TD><TD>        {</TD></TR><TR><TD CLASS="l">2824</TD><TD>                // Update it</TD></TR><TR CLASS="z"><TD CLASS="l">2825</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2826</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2827</TD><TD>            Log.debug(this, &#34;Update trading session template via template manager.&#34;);</TD></TR><TR><TD CLASS="l">2828</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2829</TD><TD>                templateHome.updateTemplate(templateStruct);</TD></TR><TR><TD CLASS="l">2830</TD><TD> </TD></TR><TR><TD CLASS="l">2831</TD><TD>                // Add to database</TD></TR><TR CLASS="z"><TD CLASS="l">2832</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">2833</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">2834</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2835</TD><TD>                        throw ExceptionBuilder.transactionFailedException(&#34;Error committing transaction : &#34; , 0);</TD></TR><TR><TD CLASS="l">2836</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2837</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">2838</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2839</TD><TD>            Log.debug(this, &#34;Commited update of template.&#34;);</TD></TR><TR><TD CLASS="l">2840</TD><TD>        }</TD></TR><TR><TD CLASS="l">2841</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2842</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">2843</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2844</TD><TD>                throw ExceptionBuilder.dataValidationException(e.details.message,0);</TD></TR><TR><TD CLASS="l">2845</TD><TD>        }</TD></TR><TR><TD CLASS="l">2846</TD><TD>        finally</TD></TR><TR><TD CLASS="l">2847</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2848</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">2849</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2850</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">2851</TD><TD>                }</TD></TR><TR><TD CLASS="l">2852</TD><TD>        }</TD></TR><TR><TD CLASS="l">2853</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2854</TD><TD>        Log.information(this,&#34;Modified template: &#34; + templateStruct.templateName);</TD></TR><TR><TD CLASS="l">2855</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2856</TD><TD>}</TD></TR><TR><TD CLASS="l">2857</TD><TD>/**</TD></TR><TR><TD CLASS="l">2858</TD><TD> * This method is invoked when price adjustments have been completed (everywhere). It will not</TD></TR><TR><TD CLASS="l">2859</TD><TD> * propagate this call to the TradingSessionClients. But triggers End of day completion.</TD></TR><TR><TD CLASS="l">2860</TD><TD> *</TD></TR><TR><TD CLASS="l">2861</TD><TD> * This method is used by the TPF adapter to notify the SBT that all order adjustments</TD></TR><TR><TD CLASS="l">2862</TD><TD> * have been sent to SBT.</TD></TR><TR><TD CLASS="l">2863</TD><TD> *</TD></TR><TR><TD CLASS="l">2864</TD><TD> * This method is currently triggered by TPF.</TD></TR><TR><TD CLASS="l">2865</TD><TD> *</TD></TR><TR><TD CLASS="l">2866</TD><TD> * @param sessionKey - the target session's identifier</TD></TR><TR><TD CLASS="l">2867</TD><TD> * @param DataValidationException</TD></TR><TR><TD CLASS="l">2868</TD><TD> * @exception DataValiadationException</TD></TR><TR><TD CLASS="l"><A NAME="8e">2869</A></TD><TD> * @exception TransactionFailedException</TD></TR><TR><TD CLASS="l">2870</TD><TD> */</TD></TR><TR><TD CLASS="l">2871</TD><TD>public void priceAdjustmentsComplete() throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">2872</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2873</TD><TD>    Log.information(this,&#34;Received PRICE ADJUSTMENTS COMPLETED on TPF [All Order Adjustments have been received from TPF]. SBT will now continue with the End Of Day PURGE.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2874</TD><TD>    priceAdjustmentsComplete(registrationMapHome.getActiveClientsForSession(SessionNameValues.ALL_SESSION_NAME),</TD></TR><TR><TD CLASS="l">2875</TD><TD>            registrationMapHome.getInactiveClientsForSession(SessionNameValues.ALL_SESSION_NAME));</TD></TR><TR><TD CLASS="l"><A NAME="8f">2876</A></TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2877</TD><TD>}</TD></TR><TR><TD CLASS="l">2878</TD><TD>private void priceAdjustmentsComplete(String[] activeClients, String[] inactiveClients) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">2879</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2880</TD><TD>    logMessage(&#34;active servers are&#34;, &#34;&#34;,activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">2881</TD><TD>    logMessage(&#34;inactive servers are &#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">2882</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2883</TD><TD>    eobdStrategy.purge(endOfDayPurgeAbortOnError/* abort on all errors*/, activeClients, inactiveClients);</TD></TR><TR CLASS="z"><TD CLASS="l">2884</TD><TD>}</TD></TR><TR><TD CLASS="l">2885</TD><TD> </TD></TR><TR><TD CLASS="l">2886</TD><TD>/**</TD></TR><TR><TD CLASS="l">2887</TD><TD> * If the client is already registered then update it.</TD></TR><TR><TD CLASS="l">2888</TD><TD> * @param String the name of the client.</TD></TR><TR><TD CLASS="l"><A NAME="98">2889</A></TD><TD> * @param client com.cboe.idl.internalBusinessServices.TradingSessionClient</TD></TR><TR><TD CLASS="l">2890</TD><TD> */</TD></TR><TR><TD CLASS="l">2891</TD><TD>public synchronized void registerClient(String clientName, TradingSessionClient client)</TD></TR><TR><TD CLASS="l">2892</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2893</TD><TD>    boolean success=false;</TD></TR><TR><TD CLASS="l">2894</TD><TD>    try</TD></TR><TR><TD CLASS="l">2895</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2896</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">2897</TD><TD>        registrationMapHome.registerClient(clientName, client);</TD></TR><TR CLASS="z"><TD CLASS="l">2898</TD><TD>        success = Transaction.commit();</TD></TR><TR><TD CLASS="l">2899</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2900</TD><TD>        Log.information(this,&#34;Remote client registered: &#34; + clientName);</TD></TR><TR><TD CLASS="l">2901</TD><TD>    }</TD></TR><TR><TD CLASS="l">2902</TD><TD>    finally</TD></TR><TR><TD CLASS="l">2903</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2904</TD><TD>        if(!success)</TD></TR><TR><TD CLASS="l">2905</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2906</TD><TD>            Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">2907</TD><TD>            Log.alarm(this,&#34;Could not registerClient for clientName &#34; + clientName);</TD></TR><TR><TD CLASS="l">2908</TD><TD>        }</TD></TR><TR><TD CLASS="l">2909</TD><TD> </TD></TR><TR><TD CLASS="l">2910</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2911</TD><TD>}</TD></TR><TR><TD CLASS="l">2912</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="9a">2913</A></TD><TD> * Releases lock on service for session and business day updates.</TD></TR><TR><TD CLASS="l">2914</TD><TD> */</TD></TR><TR><TD CLASS="l">2915</TD><TD>private void releaseUpdateLock()</TD></TR><TR><TD CLASS="l">2916</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2917</TD><TD>    String oldReason = lockManager.releaseGlobalLock();</TD></TR><TR CLASS="z"><TD CLASS="l">2918</TD><TD>    Log.information(this, &#34;Update lock released for: &#34; + oldReason);</TD></TR><TR CLASS="z"><TD CLASS="l">2919</TD><TD>}</TD></TR><TR><TD CLASS="l">2920</TD><TD>/**</TD></TR><TR><TD CLASS="l">2921</TD><TD> * Releases lock on service for the given lock ids (usually registered client names).</TD></TR><TR><TD CLASS="l">2922</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="9b">2923</A></TD><TD> * @param force - if true, then any refCounting or 'locking thread' checks are ignored.</TD></TR><TR><TD CLASS="l">2924</TD><TD> */</TD></TR><TR><TD CLASS="l">2925</TD><TD>private void releaseUpdateLock(String[] lockIds)</TD></TR><TR><TD CLASS="l">2926</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2927</TD><TD>    for (int i=0; i &lt; lockIds.length; i++)</TD></TR><TR><TD CLASS="l">2928</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2929</TD><TD>        String oldReason = lockManager.releaseLock(lockIds[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">2930</TD><TD>        Log.information(this, &#34;Update lock '&#34; + lockIds[i] + &#34;' released for: &#34; + oldReason);</TD></TR><TR><TD CLASS="l">2931</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">2932</TD><TD>}</TD></TR><TR><TD CLASS="l">2933</TD><TD>/**</TD></TR><TR><TD CLASS="l">2934</TD><TD> *</TD></TR><TR><TD CLASS="l">2935</TD><TD> *  Remove a listener from the service for a specific event type.</TD></TR><TR><TD CLASS="l">2936</TD><TD> *</TD></TR><TR><TD CLASS="l">2937</TD><TD> *  @param type - a TradingSessionEventType (enumerated type implementation) to specify what event type to remove this listener from.</TD></TR><TR><TD CLASS="l"><A NAME="9c">2938</A></TD><TD> *  @param listener - the listener to remove.</TD></TR><TR><TD CLASS="l">2939</TD><TD> */</TD></TR><TR><TD CLASS="l">2940</TD><TD>public synchronized void removeListener(TradingSessionEventType type, TradingSessionListener listener)</TD></TR><TR><TD CLASS="l">2941</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2942</TD><TD>        localClientInstance.removeListener(type, listener);</TD></TR><TR CLASS="z"><TD CLASS="l">2943</TD><TD>}</TD></TR><TR><TD CLASS="l">2944</TD><TD>/**</TD></TR><TR><TD CLASS="l">2945</TD><TD> *</TD></TR><TR><TD CLASS="l">2946</TD><TD> *  Remove a listener from the service for any event types that it may be registered for.</TD></TR><TR><TD CLASS="l">2947</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="9d">2948</A></TD><TD> *  @param listener - the listener to remove.</TD></TR><TR><TD CLASS="l">2949</TD><TD> */</TD></TR><TR><TD CLASS="l">2950</TD><TD>public synchronized void removeListener(TradingSessionListener listener)</TD></TR><TR><TD CLASS="l">2951</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2952</TD><TD>        localClientInstance.removeListener(listener);</TD></TR><TR CLASS="z"><TD CLASS="l">2953</TD><TD>}</TD></TR><TR><TD CLASS="l">2954</TD><TD>/**</TD></TR><TR><TD CLASS="l">2955</TD><TD> * Removes the session if not open.</TD></TR><TR><TD CLASS="l">2956</TD><TD> * CARE MUST BE TAKEN WHEN REMOVING THE SESSION BECASUE EVEN IF THE</TD></TR><TR><TD CLASS="l">2957</TD><TD> * SESSION IS CLOSED THE END OF SESSI0ON/DAY MIGHT STILL BE IN PROGRESS.</TD></TR><TR><TD CLASS="l"><A NAME="9f">2958</A></TD><TD> * @param client com.cboe.idl.internalBusinessServices.TradingSessionClient</TD></TR><TR><TD CLASS="l">2959</TD><TD> */</TD></TR><TR><TD CLASS="l">2960</TD><TD>public void removeTradingSessionElement(int elementKey) throws TransactionFailedException, DataValidationException</TD></TR><TR><TD CLASS="l">2961</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">2962</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">2963</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2964</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">2965</TD><TD>        try</TD></TR><TR><TD CLASS="l">2966</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2967</TD><TD>        elementHome.removeElement(elementKey);</TD></TR><TR CLASS="z"><TD CLASS="l">2968</TD><TD>        committed = Transaction.commit();</TD></TR><TR><TD CLASS="l">2969</TD><TD>    }</TD></TR><TR><TD CLASS="l">2970</TD><TD>        finally</TD></TR><TR><TD CLASS="l">2971</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2972</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">2973</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">2974</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">2975</TD><TD>                }</TD></TR><TR><TD CLASS="l">2976</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2977</TD><TD>}</TD></TR><TR><TD CLASS="l">2978</TD><TD>/**</TD></TR><TR><TD CLASS="l">2979</TD><TD> * Removes a Trading session group</TD></TR><TR><TD CLASS="l">2980</TD><TD> * @param String a group name</TD></TR><TR><TD CLASS="l">2981</TD><TD> * @exception NotFoundException if the strategy doesnot exist.</TD></TR><TR><TD CLASS="l">2982</TD><TD> * @exception SystemException id errors commiting transaction.</TD></TR><TR><TD CLASS="l">2983</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="9e">2984</A></TD><TD>public void removeTradingSession(String aName) throws DataValidationException,SystemException</TD></TR><TR><TD CLASS="l">2985</TD><TD>{</TD></TR><TR><TD CLASS="l">2986</TD><TD> </TD></TR><TR><TD CLASS="l">2987</TD><TD>        // If there is any template using the group then we cannot remove the group.</TD></TR><TR CLASS="z"><TD CLASS="l">2988</TD><TD>        if (templateHome.isSessionInUse(aName))</TD></TR><TR><TD CLASS="l">2989</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2990</TD><TD>                String errMsg = &#34;Cannot remove group because some template is already using the group: &#34; + aName;</TD></TR><TR CLASS="z"><TD CLASS="l">2991</TD><TD>                throw ExceptionBuilder.dataValidationException(errMsg,0);</TD></TR><TR><TD CLASS="l">2992</TD><TD>        }</TD></TR><TR><TD CLASS="l">2993</TD><TD> </TD></TR><TR><TD CLASS="l">2994</TD><TD>        // Find the group first.</TD></TR><TR><TD CLASS="l">2995</TD><TD>        TradingSession group;</TD></TR><TR><TD CLASS="l">2996</TD><TD> </TD></TR><TR><TD CLASS="l">2997</TD><TD>        try</TD></TR><TR><TD CLASS="l">2998</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2999</TD><TD>                group = sessionHome.find(aName);</TD></TR><TR><TD CLASS="l">3000</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3001</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">3002</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3003</TD><TD>                throw ExceptionBuilder.dataValidationException(e.details.message,0);</TD></TR><TR CLASS="z"><TD CLASS="l">3004</TD><TD>        }</TD></TR><TR><TD CLASS="l">3005</TD><TD> </TD></TR><TR><TD CLASS="l">3006</TD><TD>        // Now Delete</TD></TR><TR CLASS="z"><TD CLASS="l">3007</TD><TD>        boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3008</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">3009</TD><TD>        try</TD></TR><TR><TD CLASS="l">3010</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3011</TD><TD>                sessionHome.remove(group);</TD></TR><TR CLASS="z"><TD CLASS="l">3012</TD><TD>                success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3013</TD><TD>                if (!success)</TD></TR><TR><TD CLASS="l">3014</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3015</TD><TD>                        throw ExceptionBuilder.systemException(&#34;Error commiting delete transaction for group: &#34; + aName,0);</TD></TR><TR><TD CLASS="l">3016</TD><TD>                }</TD></TR><TR><TD CLASS="l">3017</TD><TD>        }</TD></TR><TR><TD CLASS="l">3018</TD><TD>        finally</TD></TR><TR><TD CLASS="l">3019</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3020</TD><TD>                if (!success) // Commit failed.</TD></TR><TR><TD CLASS="l">3021</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3022</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">3023</TD><TD>                }</TD></TR><TR><TD CLASS="l">3024</TD><TD>        }</TD></TR><TR><TD CLASS="l">3025</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3026</TD><TD>        Log.information(this,&#34;Session group removed: &#34; + aName);</TD></TR><TR CLASS="z"><TD CLASS="l">3027</TD><TD>}</TD></TR><TR><TD CLASS="l">3028</TD><TD>/**</TD></TR><TR><TD CLASS="l">3029</TD><TD> *  Remove the given trading session template.  This method will fail if</TD></TR><TR><TD CLASS="l">3030</TD><TD> *  there is an open session listed under this template.  This method</TD></TR><TR><TD CLASS="l">3031</TD><TD> *  will, as a consequence, remove all sessions which are related to this</TD></TR><TR><TD CLASS="l">3032</TD><TD> *  template.</TD></TR><TR><TD CLASS="l">3033</TD><TD> *  NOTE: CARE MUST BE TAKEN WHEN REMOVING THE TEMPLATE. We cannot remove the template</TD></TR><TR><TD CLASS="l"><A NAME="a0">3034</A></TD><TD> *                  if there are session existing (OPEN OR NOT). MUST BLOW AWAY SESSIONS FIRST.</TD></TR><TR><TD CLASS="l">3035</TD><TD> */</TD></TR><TR><TD CLASS="l">3036</TD><TD>public void removeTradingSessionTemplate(String templateName) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3037</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3038</TD><TD>        boolean committed = false;</TD></TR><TR><TD CLASS="l">3039</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3040</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">3041</TD><TD>        try</TD></TR><TR><TD CLASS="l">3042</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3043</TD><TD>                templateHome.removeTemplate(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">3044</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3045</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3046</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3047</TD><TD>                        throw ExceptionBuilder.transactionFailedException(&#34;Error committing transaction : &#34; , 0);</TD></TR><TR><TD CLASS="l">3048</TD><TD>                }</TD></TR><TR><TD CLASS="l">3049</TD><TD>        }</TD></TR><TR><TD CLASS="l">3050</TD><TD>        finally</TD></TR><TR><TD CLASS="l">3051</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3052</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3053</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3054</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">3055</TD><TD>                }</TD></TR><TR><TD CLASS="l">3056</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3057</TD><TD>}</TD></TR><TR><TD CLASS="l">3058</TD><TD>/**</TD></TR><TR><TD CLASS="l">3059</TD><TD> * Inform all TradingSessionClients that the service identified by &#34;serviceName&#34; has been established</TD></TR><TR><TD CLASS="l">3060</TD><TD> * (perhaps re-established).</TD></TR><TR><TD CLASS="l">3061</TD><TD> *</TD></TR><TR><TD CLASS="l">3062</TD><TD> *  @param sessionName the target session's identifier</TD></TR><TR><TD CLASS="l">3063</TD><TD> *  @param serviceName - the name of the session that has been established (or reestablished).</TD></TR><TR><TD CLASS="l">3064</TD><TD> *                        This value should be obtained from the constant Strings listed in</TD></TR><TR><TD CLASS="l"><A NAME="a2">3065</A></TD><TD> *                        com.cboe.interfaces.businessServices.TradingSessionService.</TD></TR><TR><TD CLASS="l">3066</TD><TD> */</TD></TR><TR><TD CLASS="l">3067</TD><TD>public void serviceEstablished(final String sessionName, final String serviceName) throws DataValidationException</TD></TR><TR><TD CLASS="l">3068</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3069</TD><TD>    TradingSessionStruct sessionStruct = getEventTradingSesssion(sessionName);</TD></TR><TR><TD CLASS="l">3070</TD><TD> </TD></TR><TR><TD CLASS="l">3071</TD><TD>        // Tell the recovery manager that service is OK now.</TD></TR><TR CLASS="z"><TD CLASS="l">3072</TD><TD>        serviceRecoveryManager.serviceEstablished(sessionName, serviceName);</TD></TR><TR><TD CLASS="l">3073</TD><TD> </TD></TR><TR><TD CLASS="l">3074</TD><TD>        // Now tell the world. But don't wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">3075</TD><TD>        execute(false, TradingSessionEventType.SERVICE_ESTABLISHED, sessionStruct, serviceName);</TD></TR><TR CLASS="z"><TD CLASS="l">3076</TD><TD>}</TD></TR><TR><TD CLASS="l">3077</TD><TD>/**</TD></TR><TR><TD CLASS="l">3078</TD><TD> * Propogate the fact that a service has been lost to all of the known TradingSessionClients.</TD></TR><TR><TD CLASS="l">3079</TD><TD> *</TD></TR><TR><TD CLASS="l">3080</TD><TD> *  @param sessionId the target session's identifier</TD></TR><TR><TD CLASS="l"><A NAME="a3">3081</A></TD><TD> * @param serviceName java.lang.String the name identifying the service which was lost.</TD></TR><TR><TD CLASS="l">3082</TD><TD> */</TD></TR><TR><TD CLASS="l">3083</TD><TD>public void serviceLost(final String sessionName, final String serviceName) throws DataValidationException</TD></TR><TR><TD CLASS="l">3084</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3085</TD><TD>    TradingSessionStruct sessionStruct = getEventTradingSesssion(sessionName);</TD></TR><TR><TD CLASS="l">3086</TD><TD> </TD></TR><TR><TD CLASS="l">3087</TD><TD>        // If service is already lost ignore this call.</TD></TR><TR CLASS="z"><TD CLASS="l">3088</TD><TD>        if (serviceRecoveryManager.isLost(sessionName, serviceName))</TD></TR><TR><TD CLASS="l">3089</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3090</TD><TD>                return;</TD></TR><TR><TD CLASS="l">3091</TD><TD>        }</TD></TR><TR><TD CLASS="l">3092</TD><TD> </TD></TR><TR><TD CLASS="l">3093</TD><TD>        // Tell the recovery manager that service is NOT OK.</TD></TR><TR CLASS="z"><TD CLASS="l">3094</TD><TD>        serviceRecoveryManager.serviceLost(sessionName, serviceName);</TD></TR><TR><TD CLASS="l">3095</TD><TD> </TD></TR><TR><TD CLASS="l">3096</TD><TD>        // Now tell the world. But don't wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">3097</TD><TD>        execute(false, TradingSessionEventType.SERVICE_LOST, sessionStruct, serviceName);</TD></TR><TR CLASS="z"><TD CLASS="l">3098</TD><TD>}</TD></TR><TR><TD CLASS="l">3099</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="93">3100</A></TD><TD> * Publish the current day event.</TD></TR><TR><TD CLASS="l">3101</TD><TD> */</TD></TR><TR><TD CLASS="l">3102</TD><TD>private void publishCurrentDay() {</TD></TR><TR><TD CLASS="l">3103</TD><TD>    try        {</TD></TR><TR CLASS="z"><TD CLASS="l">3104</TD><TD>        Log.information(this, &#34;Preparing to publish updated business day&#34;);</TD></TR><TR><TD CLASS="l">3105</TD><TD> </TD></TR><TR><TD CLASS="l">3106</TD><TD>        // This call should always be made from this method, or at least</TD></TR><TR><TD CLASS="l">3107</TD><TD>        // from createCurrentBusinessDay, since we need to initialize a cache.</TD></TR><TR><TD CLASS="l">3108</TD><TD>        //</TD></TR><TR CLASS="z"><TD CLASS="l">3109</TD><TD>                BusinessDayStruct struct = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3110</TD><TD>                if (parallelCreateBusDayFlag)</TD></TR><TR><TD CLASS="l">3111</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3112</TD><TD>                        struct = getCurrentBusinessDayWithParallelThread();</TD></TR><TR><TD CLASS="l">3113</TD><TD>                }</TD></TR><TR><TD CLASS="l">3114</TD><TD>                else</TD></TR><TR><TD CLASS="l">3115</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3116</TD><TD>                        struct = getCurrentBusinessDay();</TD></TR><TR><TD CLASS="l">3117</TD><TD>                }</TD></TR><TR><TD CLASS="l">3118</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3119</TD><TD>        Log.information(this, &#34;Publishing updated business day&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3120</TD><TD>            getTradingSessionPublisher().acceptBusinessDayEvent(struct);</TD></TR><TR CLASS="z"><TD CLASS="l">3121</TD><TD>        Log.information(this, &#34;Changed state of current business day to &#34; + (struct.dayState == BusinessDayStates.STARTED ? &#34;STARTED&#34; : &#34;ENDED&#34;));</TD></TR><TR><TD CLASS="l">3122</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3123</TD><TD>    catch (Exception ex){</TD></TR><TR CLASS="z"><TD CLASS="l">3124</TD><TD>            Log.alarm(this, &#34;Unexpected error when trying to publish business day event: &#34; + ex);</TD></TR><TR CLASS="z"><TD CLASS="l">3125</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3126</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="a4">3127</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">3128</TD><TD> * Set state of the current business day and send out the appropriate event.</TD></TR><TR><TD CLASS="l">3129</TD><TD> */</TD></TR><TR><TD CLASS="l">3130</TD><TD>private void setCurrentDayState(short newState) {</TD></TR><TR CLASS="z"><TD CLASS="l">3131</TD><TD>    boolean success = false;</TD></TR><TR><TD CLASS="l">3132</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">3133</TD><TD>        Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">3134</TD><TD>        getBusinessDayHome().findCurrent().setState(newState);</TD></TR><TR CLASS="z"><TD CLASS="l">3135</TD><TD>        success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3136</TD><TD>        if (success) {</TD></TR><TR CLASS="z"><TD CLASS="l">3137</TD><TD>            publishCurrentDay();</TD></TR><TR><TD CLASS="l">3138</TD><TD>            }</TD></TR><TR><TD CLASS="l">3139</TD><TD>    }</TD></TR><TR><TD CLASS="l">3140</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">3141</TD><TD>        if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">3142</TD><TD>            Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">3143</TD><TD>            Log.alarm(this, &#34;Not able to change state of current business day&#34;);</TD></TR><TR><TD CLASS="l">3144</TD><TD>        }</TD></TR><TR><TD CLASS="l">3145</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3146</TD><TD>}</TD></TR><TR><TD CLASS="l">3147</TD><TD>/**</TD></TR><TR><TD CLASS="l">3148</TD><TD> * Sets the end of session status indicators.</TD></TR><TR><TD CLASS="l">3149</TD><TD> * Bascially persists the last event that is completed and the event that is</TD></TR><TR><TD CLASS="l">3150</TD><TD> * going to be executed.</TD></TR><TR><TD CLASS="l">3151</TD><TD> *</TD></TR><TR><TD CLASS="l">3152</TD><TD> * NOTE: ALL EXCEPTIONS ARE IGNORED (WE DON&#34;T WANT END OF SESSION TO STOP IF THIS FAILS)</TD></TR><TR><TD CLASS="l">3153</TD><TD> *                 WE WILL LOG ALL ERRORS SO ATLEAST WE KNOW WHAT IS GOING ON. THIS END OF SESSION</TD></TR><TR><TD CLASS="l">3154</TD><TD> *                 PROCESS IS NOT A HIGH TRANSACTION PROCESS, SO IT IS OK TO LOG.</TD></TR><TR><TD CLASS="l">3155</TD><TD> *</TD></TR><TR><TD CLASS="l">3156</TD><TD> *</TD></TR><TR><TD CLASS="l">3157</TD><TD> * @param int the session key.</TD></TR><TR><TD CLASS="l"><A NAME="a5">3158</A></TD><TD> * @param TradingSessionEventType the EOS event currently in progress.</TD></TR><TR><TD CLASS="l">3159</TD><TD> */</TD></TR><TR><TD CLASS="l">3160</TD><TD>public void setEndOfSessionStatus(String sessionName, TradingSessionEventType eventInProgress)</TD></TR><TR><TD CLASS="l">3161</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3162</TD><TD>        TradingSession session = null;</TD></TR><TR><TD CLASS="l">3163</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3164</TD><TD>        boolean committed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3165</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">3166</TD><TD>        try</TD></TR><TR><TD CLASS="l">3167</TD><TD>        {</TD></TR><TR><TD CLASS="l">3168</TD><TD>                // Validate the sessionKey</TD></TR><TR CLASS="z"><TD CLASS="l">3169</TD><TD>                session = verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">3170</TD><TD>                session.setCurrentEndOfSessionEvent((short)eventInProgress.getEnumValue());</TD></TR><TR CLASS="z"><TD CLASS="l">3171</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3172</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3173</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3174</TD><TD>                        Log.information(this,&#34;Error committing transaction, when setting EndofSessionStatus indicators for session(&#34; + sessionName + &#34;).&#34;);</TD></TR><TR><TD CLASS="l">3175</TD><TD>                }</TD></TR><TR><TD CLASS="l">3176</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3177</TD><TD>        catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">3178</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3179</TD><TD>                Log.information(this,&#34;Error setting EndOfSessionStatus indicators for session(&#34; + sessionName + &#34;). &#34; + e + &#34;:&#34; + e.details.message);</TD></TR><TR><TD CLASS="l">3180</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3181</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">3182</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3183</TD><TD>                Log.information(this,&#34;Error setting EndOfSessionStatus indicators for session(&#34; + sessionName + &#34;). &#34; + e);</TD></TR><TR><TD CLASS="l">3184</TD><TD>        }</TD></TR><TR><TD CLASS="l">3185</TD><TD>        finally</TD></TR><TR><TD CLASS="l">3186</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3187</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3188</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3189</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">3190</TD><TD>                }</TD></TR><TR><TD CLASS="l">3191</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3192</TD><TD>}</TD></TR><TR><TD CLASS="l">3193</TD><TD> </TD></TR><TR><TD CLASS="l">3194</TD><TD>/**</TD></TR><TR><TD CLASS="l">3195</TD><TD> * Sets product states for all products in the session.</TD></TR><TR><TD CLASS="l">3196</TD><TD> * to be deprecated</TD></TR><TR><TD CLASS="l">3197</TD><TD> * @param sesionName name of session</TD></TR><TR><TD CLASS="l">3198</TD><TD> * @param newState new product state code</TD></TR><TR><TD CLASS="l"><A NAME="aa">3199</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3200</TD><TD>public void setProductStatesForSession(String sessionName, short newState)</TD></TR><TR><TD CLASS="l">3201</TD><TD>    throws DataValidationException, TransactionFailedException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">3202</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3203</TD><TD>        TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">3204</TD><TD>        for (int i = 0; i &lt; elements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3205</TD><TD>            GroupErrorCodeResultStruct[] errorResults = setProductStatesForElement(elements[i], newState, true);</TD></TR><TR CLASS="z"><TD CLASS="l">3206</TD><TD>            processProductStateChangeErrorResults(errorResults);</TD></TR><TR><TD CLASS="l">3207</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3208</TD><TD>}</TD></TR><TR><TD CLASS="l">3209</TD><TD> </TD></TR><TR><TD CLASS="l">3210</TD><TD>/**</TD></TR><TR><TD CLASS="l">3211</TD><TD> * Set the state of all products in the given session to the given state.</TD></TR><TR><TD CLASS="l">3212</TD><TD> * to be deprecated</TD></TR><TR><TD CLASS="l">3213</TD><TD> * @param sessionId the target session's identifier</TD></TR><TR><TD CLASS="l">3214</TD><TD> * @param newProductState a numeric value indicating the new product state.  A value from ProductStates.</TD></TR><TR><TD CLASS="l">3215</TD><TD> * @exception IncompleteStateChangeException - thrown if at least one client didn't change the product state.</TD></TR><TR><TD CLASS="l"><A NAME="a7">3216</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3217</TD><TD>public void setProductStatesForElement(int elementKey, short newProductState)</TD></TR><TR><TD CLASS="l">3218</TD><TD>     throws DataValidationException, CommunicationException, SystemException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">3219</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3220</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">3221</TD><TD>        Log.debug(this, &#34;setting product state - element:state::&#34; + elementKey + &#34;:&#34; + newProductState);</TD></TR><TR><TD CLASS="l">3222</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3223</TD><TD>    GroupErrorCodeResultStruct[] grpErrorResults = setProductStatesForElement(elementKey, newProductState, true/*!autoTrigger*/);</TD></TR><TR CLASS="z"><TD CLASS="l">3224</TD><TD>    processProductStateChangeErrorResults(grpErrorResults);</TD></TR><TR CLASS="z"><TD CLASS="l">3225</TD><TD>}</TD></TR><TR><TD CLASS="l">3226</TD><TD> </TD></TR><TR><TD CLASS="l">3227</TD><TD>/**</TD></TR><TR><TD CLASS="l">3228</TD><TD> * Sets product states for all products traded for the group for the session.</TD></TR><TR><TD CLASS="l">3229</TD><TD> * Validate the group first whether its valid TRADE SERVER or not.</TD></TR><TR><TD CLASS="l">3230</TD><TD> * @param sesionName name of session</TD></TR><TR><TD CLASS="l">3231</TD><TD> * @param groupName PCS GroupName</TD></TR><TR><TD CLASS="l">3232</TD><TD> * @param newState new product state code</TD></TR><TR><TD CLASS="l">3233</TD><TD> */</TD></TR><TR><TD CLASS="l">3234</TD><TD>public ErrorCodeResultStruct[] setProductStatesForSessionForGroup(String sessionName, String groupName, short newState)</TD></TR><TR><TD CLASS="l"><A NAME="ab">3235</A></TD><TD>    throws DataValidationException, TransactionFailedException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">3236</TD><TD>{</TD></TR><TR><TD CLASS="l">3237</TD><TD>    int[] classKeysForGroup;</TD></TR><TR><TD CLASS="l">3238</TD><TD>    ErrorCodeResultStruct[] errorResults;</TD></TR><TR CLASS="z"><TD CLASS="l">3239</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">3240</TD><TD>        Log.debug(this, &#34;setting product state - session:TradeServer:state::&#34; + sessionName + &#34;:&#34; + groupName + &#34;:&#34; + newState);</TD></TR><TR><TD CLASS="l">3241</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3242</TD><TD>    if(registrationMapHome.validateGroupRegistration(sessionName, groupName, groupTypeForProductState))</TD></TR><TR><TD CLASS="l">3243</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3244</TD><TD>        classKeysForGroup = getProductConfigurationService().getProductClassesForGroup(groupName);</TD></TR><TR CLASS="z"><TD CLASS="l">3245</TD><TD>        errorResults = getProductStateChangeStrategy().setProductStatesForClasses(classKeysForGroup, sessionName,  newState);</TD></TR><TR CLASS="z"><TD CLASS="l">3246</TD><TD>        if (errorResults.length &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">3247</TD><TD>            logErrors(groupName, errorResults);</TD></TR><TR CLASS="z"><TD CLASS="l">3248</TD><TD>        return errorResults;</TD></TR><TR><TD CLASS="l">3249</TD><TD>    }</TD></TR><TR><TD CLASS="l">3250</TD><TD>    else</TD></TR><TR><TD CLASS="l">3251</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3252</TD><TD>        Log.alarm(this, &#34;Group validation failed while changing product state for session:TradeServer:groupType::&#34; + sessionName + &#34;:&#34; + groupName + &#34;:&#34; + groupTypeForProductState);</TD></TR><TR CLASS="z"><TD CLASS="l">3253</TD><TD>        throw ExceptionBuilder.dataValidationException(&#34;Group validation failed while changing product state for session:TradeServer:groupType::&#34; + sessionName + &#34;:&#34; + groupName + &#34;:&#34; + groupTypeForProductState, DataValidationCodes.INVALID_GROUP);</TD></TR><TR><TD CLASS="l">3254</TD><TD>    }</TD></TR><TR><TD CLASS="l">3255</TD><TD>}</TD></TR><TR><TD CLASS="l">3256</TD><TD> </TD></TR><TR><TD CLASS="l">3257</TD><TD>/**</TD></TR><TR><TD CLASS="l">3258</TD><TD> * Sets product states for all products in the session. Returns the errors to caller as part of struct[]</TD></TR><TR><TD CLASS="l">3259</TD><TD> * This method will deprecate setProductStatesForSession</TD></TR><TR><TD CLASS="l">3260</TD><TD> *</TD></TR><TR><TD CLASS="l">3261</TD><TD> * @param sesionName name of session</TD></TR><TR><TD CLASS="l">3262</TD><TD> * @param newState new product state code</TD></TR><TR><TD CLASS="l"><A NAME="ac">3263</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3264</TD><TD>public GroupErrorCodeResultStruct[] setProductStatesForSessionV2(String sessionName, short newState)</TD></TR><TR><TD CLASS="l">3265</TD><TD>    throws DataValidationException, TransactionFailedException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">3266</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3267</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">3268</TD><TD>        Log.debug(this, &#34;setting product state - session:state::&#34; + sessionName + &#34;:&#34; + newState);</TD></TR><TR><TD CLASS="l">3269</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3270</TD><TD>    List errorList = new LinkedList();</TD></TR><TR><TD CLASS="l">3271</TD><TD>    GroupErrorCodeResultStruct[] errorResults;</TD></TR><TR><TD CLASS="l">3272</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3273</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">3274</TD><TD>    for (int i = 0; i &lt; elements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3275</TD><TD>        errorResults = setProductStatesForElement(elements[i], newState, true);</TD></TR><TR CLASS="z"><TD CLASS="l">3276</TD><TD>        errorList.addAll(Arrays.asList(errorResults));</TD></TR><TR><TD CLASS="l">3277</TD><TD>    }</TD></TR><TR><TD CLASS="l">3278</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3279</TD><TD>    if (errorList.size() &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">3280</TD><TD>        return (GroupErrorCodeResultStruct[])errorList.toArray(new GroupErrorCodeResultStruct[errorList.size()]);</TD></TR><TR CLASS="z"><TD CLASS="l">3281</TD><TD>    return EMPTY_GroupErrorCodeResultStruct;</TD></TR><TR><TD CLASS="l">3282</TD><TD>}</TD></TR><TR><TD CLASS="l">3283</TD><TD> </TD></TR><TR><TD CLASS="l">3284</TD><TD>/**</TD></TR><TR><TD CLASS="l">3285</TD><TD> * Sets product states for all products for the element. Returns the errors to caller as part of struct[]</TD></TR><TR><TD CLASS="l">3286</TD><TD> * This method will deprecate setProductStatesForElement</TD></TR><TR><TD CLASS="l">3287</TD><TD> *</TD></TR><TR><TD CLASS="l">3288</TD><TD> * @param sesionName name of session</TD></TR><TR><TD CLASS="l">3289</TD><TD> * @param newState new product state code</TD></TR><TR><TD CLASS="l"><A NAME="a9">3290</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3291</TD><TD>public GroupErrorCodeResultStruct[] setProductStatesForElementV2(int elementKey, short newState)</TD></TR><TR><TD CLASS="l">3292</TD><TD>    throws DataValidationException, TransactionFailedException, CommunicationException, AuthorizationException, SystemException</TD></TR><TR><TD CLASS="l">3293</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3294</TD><TD>    if(Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">3295</TD><TD>        Log.debug(this, &#34;setting product state - element:state::&#34; + elementKey + &#34;:&#34; + newState);</TD></TR><TR><TD CLASS="l">3296</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3297</TD><TD>    return setProductStatesForElement(elementKey, newState, true/*!autoTrigger*/);</TD></TR><TR><TD CLASS="l">3298</TD><TD>}</TD></TR><TR><TD CLASS="l">3299</TD><TD> </TD></TR><TR><TD CLASS="l">3300</TD><TD>/**</TD></TR><TR><TD CLASS="l">3301</TD><TD> * Set the state of all products for the given element</TD></TR><TR><TD CLASS="l">3302</TD><TD> * Refactored from setProductStatesForElement(int,short)</TD></TR><TR><TD CLASS="l">3303</TD><TD> *</TD></TR><TR><TD CLASS="l">3304</TD><TD> * @param sessionId the target session's identifier</TD></TR><TR><TD CLASS="l">3305</TD><TD> * @param newProductState a numeric value indicating the new product state.  A value from ProductStates.</TD></TR><TR><TD CLASS="l">3306</TD><TD> * @param autoTrigger a boolean to indicate if this state change is automatic (timer expired, underlying tick) or manual.</TD></TR><TR><TD CLASS="l">3307</TD><TD> *        most calls will use 'false'.</TD></TR><TR><TD CLASS="l">3308</TD><TD> * @exception IncompleteStateChangeException - thrown if at least one client didn't change the product state.</TD></TR><TR><TD CLASS="l">3309</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="a8">3310</A></TD><TD>public GroupErrorCodeResultStruct[] setProductStatesForElement(int elementKey, short newProductState, boolean autoTrigger)</TD></TR><TR><TD CLASS="l">3311</TD><TD>     throws DataValidationException, CommunicationException, SystemException, TransactionFailedException, AuthorizationException</TD></TR><TR><TD CLASS="l">3312</TD><TD>{</TD></TR><TR><TD CLASS="l">3313</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">3314</TD><TD>        TradingSessionElement element = elementHome.findByKey(elementKey);</TD></TR><TR CLASS="z"><TD CLASS="l">3315</TD><TD>        return setProductStatesForElement(element, newProductState, autoTrigger);</TD></TR><TR><TD CLASS="l">3316</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3317</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">3318</TD><TD>        throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">3319</TD><TD>    }</TD></TR><TR><TD CLASS="l">3320</TD><TD>}</TD></TR><TR><TD CLASS="l">3321</TD><TD>/**</TD></TR><TR><TD CLASS="l">3322</TD><TD> * Facilitator method to process the Error Results and throw TransactionFailed errors</TD></TR><TR><TD CLASS="l">3323</TD><TD> * @param grpErrorResults</TD></TR><TR><TD CLASS="l">3324</TD><TD> * @throws TransactionFailedException</TD></TR><TR><TD CLASS="l"><A NAME="91">3325</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3326</TD><TD>public void processProductStateChangeErrorResults(GroupErrorCodeResultStruct[] grpErrorResults)</TD></TR><TR><TD CLASS="l">3327</TD><TD>    throws TransactionFailedException</TD></TR><TR><TD CLASS="l">3328</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3329</TD><TD>    int classKey = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3330</TD><TD>    if (grpErrorResults.length &gt; 0)</TD></TR><TR><TD CLASS="l">3331</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3332</TD><TD>        StringBuffer failedClasses = new StringBuffer(&#34;Quitting.. ProductState change failed for TradeServer:Classes::&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3333</TD><TD>        for (int i=0; i&lt; grpErrorResults.length; i++)</TD></TR><TR><TD CLASS="l">3334</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3335</TD><TD>            failedClasses.append(grpErrorResults[i].group.groupName).append(':');</TD></TR><TR CLASS="z"><TD CLASS="l">3336</TD><TD>            for (int j=0; j&lt;grpErrorResults[i].errorResults.length; j++)</TD></TR><TR><TD CLASS="l">3337</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">3338</TD><TD>                classKey = grpErrorResults[i].errorResults[j].classKey;</TD></TR><TR CLASS="z"><TD CLASS="l">3339</TD><TD>                failedClasses.append(classKey).append('(').append(getClassSymbol(classKey)).append(')').append(',');</TD></TR><TR><TD CLASS="l">3340</TD><TD>            }</TD></TR><TR><TD CLASS="l">3341</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3342</TD><TD>        throw ExceptionBuilder.transactionFailedException(failedClasses.toString(), TransactionFailedCodes.INCOMPLETE_STATE_CHANGE);</TD></TR><TR><TD CLASS="l">3343</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3344</TD><TD>}</TD></TR><TR><TD CLASS="l">3345</TD><TD> </TD></TR><TR><TD CLASS="l">3346</TD><TD>/**</TD></TR><TR><TD CLASS="l">3347</TD><TD> * Set the state of all products in the given session to the given state.</TD></TR><TR><TD CLASS="l">3348</TD><TD> * @param autoTrigger a boolean to indicate if this state change is automatic (timer expired, underlying tick) or manual.</TD></TR><TR><TD CLASS="l">3349</TD><TD> *        most calls will use 'false'.</TD></TR><TR><TD CLASS="l">3350</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="a6">3351</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3352</TD><TD>private GroupErrorCodeResultStruct[] setProductStatesForElement(final TradingSessionElement element, final short newProductState, final boolean autoTrigger)</TD></TR><TR><TD CLASS="l">3353</TD><TD>     throws SystemException, TransactionFailedException, AuthorizationException, DataValidationException, CommunicationException</TD></TR><TR><TD CLASS="l">3354</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3355</TD><TD>    Log.information(this,&#34;Setting Product State for Element &#34; + element.getElementName() + &#34; TO &#34; + newProductState);</TD></TR><TR CLASS="z"><TD CLASS="l">3356</TD><TD>    String sessionName = element.getSession().getSessionName();</TD></TR><TR><TD CLASS="l">3357</TD><TD>    ErrorCodeResultStruct[] errorResults;</TD></TR><TR><TD CLASS="l">3358</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3359</TD><TD>    String[] activeClients = registrationMapHome.getActiveClientsForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">3360</TD><TD>    lockServiceForUpdates(activeClients, &#34;Setting product states for &#34; + sessionName); // LOCK BY CLIENT</TD></TR><TR><TD CLASS="l">3361</TD><TD> </TD></TR><TR><TD CLASS="l">3362</TD><TD>    // Do not transition class from suspended to any other state if this method was auto-triggered and we are configured</TD></TR><TR><TD CLASS="l">3363</TD><TD>    // to block such transitions.</TD></TR><TR><TD CLASS="l">3364</TD><TD>    //</TD></TR><TR><TD CLASS="l">3365</TD><TD>    try{</TD></TR><TR CLASS="z"><TD CLASS="l">3366</TD><TD>        errorResults = getProductStateChangeStrategy().setProductStatesForElement(element,newProductState, autoTrigger &amp;&amp; blockAutoTransitionFromSuspended);</TD></TR><TR><TD CLASS="l">3367</TD><TD>    }</TD></TR><TR><TD CLASS="l">3368</TD><TD>    finally {</TD></TR><TR CLASS="z"><TD CLASS="l">3369</TD><TD>        releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">3370</TD><TD>    }</TD></TR><TR><TD CLASS="l">3371</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3372</TD><TD>    return convertErrorCodeToGroupErrorCode(sessionName, errorResults);</TD></TR><TR><TD CLASS="l">3373</TD><TD>}</TD></TR><TR><TD CLASS="l">3374</TD><TD> </TD></TR><TR><TD CLASS="l">3375</TD><TD>/**</TD></TR><TR><TD CLASS="l">3376</TD><TD> * Facilitator method to classify the error results per group</TD></TR><TR><TD CLASS="l">3377</TD><TD> * It converts Array of ErrorCodeResultStruct into Array of GroupErrorCodeResultStruct</TD></TR><TR><TD CLASS="l">3378</TD><TD> * For each class failed, it finds the valid group and builds GroupErrorCodeResultStruct array</TD></TR><TR><TD CLASS="l">3379</TD><TD> * @param sessionName</TD></TR><TR><TD CLASS="l">3380</TD><TD> * @param errorResults</TD></TR><TR><TD CLASS="l"><A NAME="1e">3381</A></TD><TD> * @return</TD></TR><TR><TD CLASS="l">3382</TD><TD> */</TD></TR><TR><TD CLASS="l">3383</TD><TD>private GroupErrorCodeResultStruct[] convertErrorCodeToGroupErrorCode(String sessionName, ErrorCodeResultStruct[] errorResults)</TD></TR><TR><TD CLASS="l">3384</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3385</TD><TD>    HashMap grpClassMap = new HashMap(DEFAULT_GROUP_SIZE);</TD></TR><TR CLASS="z"><TD CLASS="l">3386</TD><TD>    int classKey = 0;</TD></TR><TR><TD CLASS="l">3387</TD><TD>    String groupName;</TD></TR><TR><TD CLASS="l">3388</TD><TD>    List errorList;</TD></TR><TR><TD CLASS="l">3389</TD><TD>    GroupStruct[] groupsForClassKey;</TD></TR><TR><TD CLASS="l">3390</TD><TD>    GroupStruct group;</TD></TR><TR CLASS="z"><TD CLASS="l">3391</TD><TD>    StringBuffer errorStr = new StringBuffer(sessionName).append(&#34; on TradeServer:&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3392</TD><TD>    StringBuffer failedClasses = new StringBuffer(&#34;Product state change failed for Classes:&#34;);</TD></TR><TR><TD CLASS="l">3393</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3394</TD><TD>    for (int i=0; i&lt;errorResults.length; i++)</TD></TR><TR><TD CLASS="l">3395</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3396</TD><TD>        classKey = errorResults[i].classKey;</TD></TR><TR><TD CLASS="l">3397</TD><TD>        try</TD></TR><TR><TD CLASS="l">3398</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3399</TD><TD>            groupsForClassKey = getProductConfigurationService().getGroupsForProductClass(classKey);</TD></TR><TR><TD CLASS="l">3400</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3401</TD><TD>        catch(Exception e)  //Log the exception and proceed</TD></TR><TR><TD CLASS="l">3402</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3403</TD><TD>            Log.exception(this, &#34;Exception thrown while accessing PCS for class &#34;+ classKey, e);</TD></TR><TR CLASS="z"><TD CLASS="l">3404</TD><TD>            continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3405</TD><TD>        }</TD></TR><TR><TD CLASS="l">3406</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3407</TD><TD>        for (int j=0; j&lt; groupsForClassKey.length; j++)</TD></TR><TR><TD CLASS="l">3408</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3409</TD><TD>            groupName = groupsForClassKey[j].groupName;</TD></TR><TR CLASS="z"><TD CLASS="l">3410</TD><TD>            group = groupsForClassKey[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3411</TD><TD>            if(registrationMapHome.validateGroupRegistration(sessionName, groupName, groupTypeForProductState))</TD></TR><TR><TD CLASS="l">3412</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">3413</TD><TD>                GroupContainer grpContainer = new GroupContainer(group);</TD></TR><TR><TD CLASS="l">3414</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3415</TD><TD>                if (!grpClassMap.containsKey(grpContainer))</TD></TR><TR CLASS="z"><TD CLASS="l">3416</TD><TD>                    errorStr.append(groupName).append(',');</TD></TR><TR><TD CLASS="l">3417</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3418</TD><TD>                errorList = (List)grpClassMap.get(grpContainer);</TD></TR><TR CLASS="z"><TD CLASS="l">3419</TD><TD>                if(errorList == null)</TD></TR><TR><TD CLASS="l">3420</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3421</TD><TD>                    errorList = new ArrayList(GROUP_SIZE);</TD></TR><TR CLASS="z"><TD CLASS="l">3422</TD><TD>                    grpClassMap.put(grpContainer, errorList);</TD></TR><TR><TD CLASS="l">3423</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3424</TD><TD>                errorList.add(errorResults[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">3425</TD><TD>                break;</TD></TR><TR><TD CLASS="l">3426</TD><TD>            }</TD></TR><TR><TD CLASS="l">3427</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3428</TD><TD>        failedClasses.append(classKey).append('(').append(getClassSymbol(classKey)).append(')').append(',');</TD></TR><TR><TD CLASS="l">3429</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3430</TD><TD>    failedClasses.append(&#34; being traded for session:&#34;);</TD></TR><TR><TD CLASS="l">3431</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3432</TD><TD>    if (grpClassMap.size() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">3433</TD><TD>        return EMPTY_GroupErrorCodeResultStruct;</TD></TR><TR><TD CLASS="l">3434</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3435</TD><TD>    GroupErrorCodeResultStruct[] groupErrorCodeResultStructArray = new GroupErrorCodeResultStruct[grpClassMap.size()];</TD></TR><TR><TD CLASS="l">3436</TD><TD> </TD></TR><TR><TD CLASS="l">3437</TD><TD>    Map.Entry mapEntry;</TD></TR><TR CLASS="z"><TD CLASS="l">3438</TD><TD>    int i = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3439</TD><TD>    for (Iterator it = grpClassMap.entrySet().iterator(); it.hasNext(); i++)</TD></TR><TR><TD CLASS="l">3440</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3441</TD><TD>        mapEntry = (Map.Entry) it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">3442</TD><TD>        group = (GroupStruct) ((GroupContainer)mapEntry.getKey()).getStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">3443</TD><TD>        errorList = (List) mapEntry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">3444</TD><TD>        groupErrorCodeResultStructArray[i] = new GroupErrorCodeResultStruct(group, (ErrorCodeResultStruct[]) errorList.toArray(new ErrorCodeResultStruct[errorList.size()]));</TD></TR><TR><TD CLASS="l">3445</TD><TD>    }</TD></TR><TR><TD CLASS="l">3446</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3447</TD><TD>    Log.alarm(this, failedClasses.toString() + errorStr.toString());</TD></TR><TR CLASS="z"><TD CLASS="l">3448</TD><TD>    return groupErrorCodeResultStructArray;</TD></TR><TR><TD CLASS="l">3449</TD><TD>}</TD></TR><TR><TD CLASS="l">3450</TD><TD> </TD></TR><TR><TD CLASS="l">3451</TD><TD>/**</TD></TR><TR><TD CLASS="l">3452</TD><TD> * Get the instance of product state change strategy as per configuration</TD></TR><TR><TD CLASS="l">3453</TD><TD> * @return ProductStateChangeStrategy</TD></TR><TR><TD CLASS="l">3454</TD><TD> * @throws SystemException</TD></TR><TR><TD CLASS="l">3455</TD><TD> */</TD></TR><TR><TD CLASS="l">3456</TD><TD>private ProductStateChangeStrategy getProductStateChangeStrategy()</TD></TR><TR><TD CLASS="l"><A NAME="60">3457</A></TD><TD>    throws SystemException</TD></TR><TR><TD CLASS="l">3458</TD><TD>{</TD></TR><TR><TD CLASS="l">3459</TD><TD>    try</TD></TR><TR><TD CLASS="l">3460</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3461</TD><TD>        if (nonAdminProductStateImplementation == null)</TD></TR><TR CLASS="z"><TD CLASS="l">3462</TD><TD>            return instantiateProductStateChangeStrategy(new Configuration(getBOHome()).getProperty(PRODUCT_STATE_CHANGE_IMPL));</TD></TR><TR><TD CLASS="l">3463</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3464</TD><TD>    catch (InappropriateValueException e)</TD></TR><TR><TD CLASS="l">3465</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3466</TD><TD>       throw ExceptionBuilder.systemException(e.getMessage(),0);</TD></TR><TR><TD CLASS="l">3467</TD><TD> </TD></TR><TR><TD CLASS="l">3468</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3469</TD><TD>    catch (NoSuchPropertyException e)</TD></TR><TR><TD CLASS="l">3470</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3471</TD><TD>        throw ExceptionBuilder.systemException(e.getMessage(),0);</TD></TR><TR CLASS="z"><TD CLASS="l">3472</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3473</TD><TD>    return nonAdminProductStateImplementation;</TD></TR><TR><TD CLASS="l"><A NAME="5a">3474</A></TD><TD>}</TD></TR><TR><TD CLASS="l">3475</TD><TD> </TD></TR><TR><TD CLASS="l">3476</TD><TD>private ProductClassHome getProductClassHome()</TD></TR><TR><TD CLASS="l">3477</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3478</TD><TD>    if (productClassHome == null) {</TD></TR><TR><TD CLASS="l">3479</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">3480</TD><TD>            productClassHome = (ProductClassHome) HomeFactory.getInstance().findHome(ProductClassHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">3481</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3482</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">3483</TD><TD>            throw new NullPointerException(&#34;Unable to get product class home&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3484</TD><TD>        }</TD></TR><TR><TD CLASS="l">3485</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3486</TD><TD>    return productClassHome;</TD></TR><TR><TD CLASS="l">3487</TD><TD>}</TD></TR><TR><TD CLASS="l">3488</TD><TD> </TD></TR><TR><TD CLASS="l">3489</TD><TD>/**</TD></TR><TR><TD CLASS="l">3490</TD><TD> * Facilitator method to get the class symbold for requested classKey</TD></TR><TR><TD CLASS="l">3491</TD><TD> * @param classKey</TD></TR><TR><TD CLASS="l">3492</TD><TD> * @return String ClassSymbol</TD></TR><TR><TD CLASS="l"><A NAME="38">3493</A></TD><TD> */ private String getClassSymbol(int classKey)</TD></TR><TR><TD CLASS="l">3494</TD><TD>{</TD></TR><TR><TD CLASS="l">3495</TD><TD>    try</TD></TR><TR><TD CLASS="l">3496</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3497</TD><TD>        return getProductClassHome().findByKey(classKey).getSymbol();</TD></TR><TR><TD CLASS="l">3498</TD><TD> </TD></TR><TR><TD CLASS="l">3499</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3500</TD><TD>    catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">3501</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3502</TD><TD>        Log.information(&#34;NotFoundException thrown: Query to get class symbol failed for key &#34; + classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">3503</TD><TD>        return &#34;&#34;;</TD></TR><TR><TD CLASS="l">3504</TD><TD>    }</TD></TR><TR><TD CLASS="l">3505</TD><TD>}</TD></TR><TR><TD CLASS="l">3506</TD><TD> </TD></TR><TR><TD CLASS="l">3507</TD><TD>/**</TD></TR><TR><TD CLASS="l">3508</TD><TD> * Facilitator method to log the alarm with failed classes info</TD></TR><TR><TD CLASS="l"><A NAME="86">3509</A></TD><TD> * @param groupName</TD></TR><TR><TD CLASS="l">3510</TD><TD> * @param errors</TD></TR><TR><TD CLASS="l">3511</TD><TD> */ private void logErrors(String groupName, ErrorCodeResultStruct[] errors)</TD></TR><TR><TD CLASS="l">3512</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3513</TD><TD>    int classKey = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3514</TD><TD>    StringBuffer failedClasses = new StringBuffer(&#34;ProductState change failed for TradeServer:Classes::&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3515</TD><TD>    failedClasses.append(groupName).append(':');</TD></TR><TR><TD CLASS="l">3516</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3517</TD><TD>    for (int i=0; i&lt; errors.length; i++)</TD></TR><TR><TD CLASS="l">3518</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3519</TD><TD>        classKey = errors[i].classKey;</TD></TR><TR CLASS="z"><TD CLASS="l">3520</TD><TD>        failedClasses.append(classKey).append('(').append(getClassSymbol(classKey)).append(')').append(',');</TD></TR><TR><TD CLASS="l">3521</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3522</TD><TD>    Log.alarm(this, failedClasses.toString());</TD></TR><TR CLASS="z"><TD CLASS="l">3523</TD><TD>}</TD></TR><TR><TD CLASS="l">3524</TD><TD> </TD></TR><TR><TD CLASS="l">3525</TD><TD>/**</TD></TR><TR><TD CLASS="l">3526</TD><TD> * Set the session's state.  If the new state is different than the old state then the</TD></TR><TR><TD CLASS="l">3527</TD><TD> * new state will be published on the TradingSessionEventConsumer channel.</TD></TR><TR><TD CLASS="l">3528</TD><TD> *</TD></TR><TR><TD CLASS="l">3529</TD><TD> * @param in the the session key.</TD></TR><TR><TD CLASS="l">3530</TD><TD> * @param newState com.cboe.idl.cmiSession.SessionState.</TD></TR><TR><TD CLASS="l"><A NAME="ad">3531</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3532</TD><TD>private void setSessionState(TradingSession session, short newState)</TD></TR><TR><TD CLASS="l">3533</TD><TD>{</TD></TR><TR><TD CLASS="l">3534</TD><TD>        // Same state, no changes.</TD></TR><TR CLASS="z"><TD CLASS="l">3535</TD><TD>        if (session.getSessionState() == newState)</TD></TR><TR><TD CLASS="l">3536</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3537</TD><TD>                return;</TD></TR><TR><TD CLASS="l">3538</TD><TD>        }</TD></TR><TR><TD CLASS="l">3539</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3540</TD><TD>        boolean committed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3541</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">3542</TD><TD>        try</TD></TR><TR><TD CLASS="l">3543</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3544</TD><TD>                session.setSessionState(newState);</TD></TR><TR CLASS="z"><TD CLASS="l">3545</TD><TD>                committed = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3546</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3547</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3548</TD><TD>                        Log.alarm(this,&#34;Unable to commit transaction when setting session state for session(&#34; + session.getSessionName() + &#34;)&#34;);</TD></TR><TR><TD CLASS="l">3549</TD><TD>                }</TD></TR><TR><TD CLASS="l">3550</TD><TD> </TD></TR><TR><TD CLASS="l">3551</TD><TD>        }</TD></TR><TR><TD CLASS="l">3552</TD><TD>        finally</TD></TR><TR><TD CLASS="l">3553</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3554</TD><TD>                if (!committed)</TD></TR><TR><TD CLASS="l">3555</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3556</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">3557</TD><TD>                }</TD></TR><TR><TD CLASS="l">3558</TD><TD>        }</TD></TR><TR><TD CLASS="l">3559</TD><TD>        // Now publich the event to the world.</TD></TR><TR CLASS="z"><TD CLASS="l">3560</TD><TD>    publishTradingSessionState(session);</TD></TR><TR CLASS="z"><TD CLASS="l">3561</TD><TD>}</TD></TR><TR><TD CLASS="l">3562</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="97">3563</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">3564</TD><TD>     * publish TradingSessionStateEvent</TD></TR><TR><TD CLASS="l">3565</TD><TD>     */</TD></TR><TR><TD CLASS="l">3566</TD><TD>    private void publishTradingSessionState(TradingSession session) {</TD></TR><TR CLASS="z"><TD CLASS="l">3567</TD><TD>        TradingSessionConsumer channel = getTradingSessionPublisher();</TD></TR><TR CLASS="z"><TD CLASS="l">3568</TD><TD>        short state = session.getSessionState();</TD></TR><TR CLASS="z"><TD CLASS="l">3569</TD><TD>        Log.information(this, &#34;Begin publishing state &#34; + state + &#34; of session &#34;+ session.getSessionName() + &#34; to event channel. Got publisher.  Is null? &#34; + (channel==null));</TD></TR><TR CLASS="z"><TD CLASS="l">3570</TD><TD>            if (channel != null){</TD></TR><TR><TD CLASS="l">3571</TD><TD>                    try        {</TD></TR><TR CLASS="z"><TD CLASS="l">3572</TD><TD>                            TradingSessionStateStruct struct = new TradingSessionStateStruct(session.getSessionName(), state);</TD></TR><TR CLASS="z"><TD CLASS="l">3573</TD><TD>                            channel.acceptTradingSessionState(struct);</TD></TR><TR CLASS="z"><TD CLASS="l">3574</TD><TD>                Log.information(this, &#34;session &#34;+ session.getSessionName() + &#34; state changed to &#34; + state + &#34;: published event.&#34;);</TD></TR><TR><TD CLASS="l">3575</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">3576</TD><TD>                    catch (Exception ex){</TD></TR><TR CLASS="z"><TD CLASS="l">3577</TD><TD>                            Log.alarm(this, &#34;Unexpected error publishing to TradingSessionState event channel: &#34; + ex);</TD></TR><TR CLASS="z"><TD CLASS="l">3578</TD><TD>                    }</TD></TR><TR><TD CLASS="l">3579</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">3580</TD><TD>    }</TD></TR><TR><TD CLASS="l">3581</TD><TD> </TD></TR><TR><TD CLASS="l">3582</TD><TD>/**</TD></TR><TR><TD CLASS="l">3583</TD><TD> * This method is called when all sessions are down.</TD></TR><TR><TD CLASS="l">3584</TD><TD> * If force start flag parameter is false and if the auto start flag is true for the</TD></TR><TR><TD CLASS="l">3585</TD><TD> * strategy then the processing will begin automatically.</TD></TR><TR><TD CLASS="l">3586</TD><TD> *</TD></TR><TR><TD CLASS="l">3587</TD><TD> * This method will do the following.</TD></TR><TR><TD CLASS="l">3588</TD><TD> * 1. Check to see if all sessions are closed.</TD></TR><TR><TD CLASS="l">3589</TD><TD> * 2. Get the strategy for the end of business day.</TD></TR><TR><TD CLASS="l">3590</TD><TD> * 3. If strategy is to be auto started then perform end of business day.</TD></TR><TR><TD CLASS="l">3591</TD><TD> *</TD></TR><TR><TD CLASS="l">3592</TD><TD> * NOTE: MAKE SURE THIS METHOD DOES NOT HANG, OTHER WISE IT WILL BLOCK ALL</TD></TR><TR><TD CLASS="l">3593</TD><TD> *                  OTHER TIMERS FROM EXPIRING.</TD></TR><TR><TD CLASS="l">3594</TD><TD> *</TD></TR><TR><TD CLASS="l">3595</TD><TD> * @param boolean forceStart if true will forcefully do end of day processing.</TD></TR><TR><TD CLASS="l">3596</TD><TD> * @param boolean if true aborts on first rrror.</TD></TR><TR><TD CLASS="l">3597</TD><TD> * @exception DataValidationException</TD></TR><TR><TD CLASS="l"><A NAME="b1">3598</A></TD><TD> * @exception TransactionFailedException</TD></TR><TR><TD CLASS="l">3599</TD><TD> */</TD></TR><TR><TD CLASS="l">3600</TD><TD>public void startEndOfDay(boolean forceStart,boolean abortOnError) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3601</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3602</TD><TD>    logMessage(&#34;startEndOfDay is called.&#34;, &#34;&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3603</TD><TD>    startEndOfDay(forceStart, abortOnError, registrationMapHome.getActiveClientsForSession(SessionNameValues.ALL_SESSION_NAME),</TD></TR><TR><TD CLASS="l">3604</TD><TD>            registrationMapHome.getInactiveClientsForSession(SessionNameValues.ALL_SESSION_NAME) );</TD></TR><TR><TD CLASS="l"><A NAME="b2">3605</A></TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3606</TD><TD>}</TD></TR><TR><TD CLASS="l">3607</TD><TD>public void startEndOfDay(boolean forceStart,boolean abortOnError, String[] activeClients, String[] inactiveClients) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3608</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3609</TD><TD>    logMessage(&#34;active servers are&#34;, &#34;&#34;,activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">3610</TD><TD>    logMessage(&#34;inactive servers are &#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">3611</TD><TD> </TD></TR><TR><TD CLASS="l">3612</TD><TD>        class EndOfDayThread implements Runnable</TD></TR><TR><TD CLASS="l">3613</TD><TD>        {</TD></TR><TR><TD CLASS="l">3614</TD><TD>                boolean abortOnError;</TD></TR><TR><TD CLASS="l"><A NAME="cc">3615</A></TD><TD>                TradingSessionEOBDStrategy strategy;</TD></TR><TR><TD CLASS="l">3616</TD><TD>        String[] activeClients, inactiveClients;</TD></TR><TR><TD CLASS="l">3617</TD><TD> </TD></TR><TR><TD CLASS="l">3618</TD><TD>                EndOfDayThread(TradingSessionEOBDStrategy aStrategy, boolean anAbortOnError, String[] actives, String[] inactives)</TD></TR><TR CLASS="z"><TD CLASS="l">3619</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3620</TD><TD>                        strategy          = aStrategy;</TD></TR><TR CLASS="z"><TD CLASS="l">3621</TD><TD>                        abortOnError = anAbortOnError;</TD></TR><TR CLASS="z"><TD CLASS="l">3622</TD><TD>            activeClients = actives;</TD></TR><TR CLASS="z"><TD CLASS="l">3623</TD><TD>            inactiveClients = inactives;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="ce">3624</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">3625</TD><TD> </TD></TR><TR><TD CLASS="l">3626</TD><TD>                public void run()</TD></TR><TR><TD CLASS="l">3627</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3628</TD><TD>                        String errMsg = &#34;Error performing End Of Day processing.&#34;;</TD></TR><TR><TD CLASS="l">3629</TD><TD>                        try</TD></TR><TR><TD CLASS="l">3630</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">3631</TD><TD>                                strategy.performEndOfBusinessDay(abortOnError, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">3632</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3633</TD><TD>                        catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">3634</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">3635</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg + &#34;. Due to error: &#34; + e.details.message,e);</TD></TR><TR><TD CLASS="l">3636</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3637</TD><TD>                        catch (TransactionFailedException e)</TD></TR><TR><TD CLASS="l">3638</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">3639</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg + &#34;. Due to error: &#34; + e.details.message,e);</TD></TR><TR><TD CLASS="l">3640</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3641</TD><TD>                        catch (Exception e)</TD></TR><TR><TD CLASS="l">3642</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">3643</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg,e);</TD></TR><TR><TD CLASS="l">3644</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3645</TD><TD>            finally {</TD></TR><TR CLASS="z"><TD CLASS="l">3646</TD><TD>                releaseUpdateLock();</TD></TR><TR CLASS="z"><TD CLASS="l">3647</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">3648</TD><TD>                }</TD></TR><TR><TD CLASS="l">3649</TD><TD>        }</TD></TR><TR><TD CLASS="l">3650</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3651</TD><TD>        Log.information(this,&#34;Starting End Of Day processing.... ForceStart/AbortOnError: &#34; + forceStart + &#34;/&#34; + abortOnError);</TD></TR><TR><TD CLASS="l">3652</TD><TD> </TD></TR><TR><TD CLASS="l">3653</TD><TD>        // VALIDATE. If sucessfull start end of day processing thread.</TD></TR><TR><TD CLASS="l">3654</TD><TD>        // All sessions must be down if we are not force starting.</TD></TR><TR><TD CLASS="l">3655</TD><TD>        // Even though there is a flag that is maintained that tells us if this group is the</TD></TR><TR><TD CLASS="l">3656</TD><TD>        // the last group that comes down before end of day.</TD></TR><TR><TD CLASS="l">3657</TD><TD>        // The End of day process requires a lot of manual intervention so it doesnot make</TD></TR><TR><TD CLASS="l">3658</TD><TD>        // sense to automate this yet.</TD></TR><TR CLASS="z"><TD CLASS="l">3659</TD><TD>        if (!forceStart &amp;&amp; !areAllSessionsClosed() )</TD></TR><TR><TD CLASS="l">3660</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3661</TD><TD>                Log.information(this,&#34;End Of Day not performed because not all sessions are closed.&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">3662</TD><TD>        throw ExceptionBuilder.transactionFailedException(&#34;End Of Day not performed because not all sessions are closed.&#34;,0);</TD></TR><TR><TD CLASS="l">3663</TD><TD>        }</TD></TR><TR><TD CLASS="l">3664</TD><TD> </TD></TR><TR><TD CLASS="l">3665</TD><TD>        try</TD></TR><TR><TD CLASS="l">3666</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3667</TD><TD>                TradingSessionEOBDStrategy strategy = strategyFactory.getEndOfBusinessDayStrategy(null);</TD></TR><TR><TD CLASS="l">3668</TD><TD> </TD></TR><TR><TD CLASS="l">3669</TD><TD>                // ALL VALIDATIONS MUST BE DONE BEFORE THIS POINT</TD></TR><TR><TD CLASS="l">3670</TD><TD> </TD></TR><TR><TD CLASS="l">3671</TD><TD>                // Check to see if we need to automatically start end of day processing.</TD></TR><TR><TD CLASS="l">3672</TD><TD>                // See note above.</TD></TR><TR CLASS="z"><TD CLASS="l">3673</TD><TD>                if (strategy.isAutoStart() || forceStart)</TD></TR><TR><TD CLASS="l">3674</TD><TD>                {</TD></TR><TR><TD CLASS="l">3675</TD><TD>            // Lock service before starting thread - need to get failure back to user</TD></TR><TR><TD CLASS="l">3676</TD><TD>            // Lock will be released when processing in thread completes.</TD></TR><TR CLASS="z"><TD CLASS="l">3677</TD><TD>            lockServiceForUpdates(&#34;Start end of day processing&#34;);</TD></TR><TR><TD CLASS="l">3678</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3679</TD><TD>            setCurrentDayState(BusinessDayStates.ENDED);</TD></TR><TR CLASS="z"><TD CLASS="l">3680</TD><TD>                        Thread t = new Thread(new EndOfDayThread(strategy,abortOnError, activeClients, inactiveClients));</TD></TR><TR CLASS="z"><TD CLASS="l">3681</TD><TD>                        t.start();</TD></TR><TR CLASS="z"><TD CLASS="l">3682</TD><TD>                }</TD></TR><TR><TD CLASS="l">3683</TD><TD>                else</TD></TR><TR><TD CLASS="l">3684</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3685</TD><TD>                        Log.alarm(this,&#34;(AUTOMATIC END OF DAY PROCESSING IS OFF). End Of Day not started, must be triggered manually.&#34;);</TD></TR><TR><TD CLASS="l">3686</TD><TD>                }</TD></TR><TR><TD CLASS="l">3687</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3688</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">3689</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3690</TD><TD>                throw ExceptionBuilder.dataValidationException(e.details.message,0);</TD></TR><TR CLASS="z"><TD CLASS="l">3691</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3692</TD><TD>}</TD></TR><TR><TD CLASS="l">3693</TD><TD>/**</TD></TR><TR><TD CLASS="l">3694</TD><TD> *  Stop session: set session state to CLOSED and publish an event.</TD></TR><TR><TD CLASS="l"><A NAME="c1">3695</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3696</TD><TD>public void stopSession(final String sessionName)</TD></TR><TR><TD CLASS="l">3697</TD><TD>    throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3698</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3699</TD><TD>    TradingSession session = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">3700</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3701</TD><TD>        Log.information(this, &#34;Setting session &#34; + sessionName + &#34; to closed.&#34;);</TD></TR><TR><TD CLASS="l">3702</TD><TD> </TD></TR><TR><TD CLASS="l">3703</TD><TD>    // If no exception thrown state the state to closed.</TD></TR><TR><TD CLASS="l">3704</TD><TD>    //</TD></TR><TR><TD CLASS="l">3705</TD><TD>    // The setSessionState method will only publish the state change event if the session is not already closed.</TD></TR><TR><TD CLASS="l">3706</TD><TD>    //</TD></TR><TR CLASS="z"><TD CLASS="l">3707</TD><TD>    setSessionState(session,TradingSessionStates.CLOSED);</TD></TR><TR CLASS="z"><TD CLASS="l">3708</TD><TD>}</TD></TR><TR><TD CLASS="l">3709</TD><TD>/**</TD></TR><TR><TD CLASS="l">3710</TD><TD> * This method is called when all products for the session.</TD></TR><TR><TD CLASS="l">3711</TD><TD> * If force start flag parameter is false and if the auto start flag is true for the</TD></TR><TR><TD CLASS="l">3712</TD><TD> * strategy then the processing will begin automatically.</TD></TR><TR><TD CLASS="l">3713</TD><TD> *</TD></TR><TR><TD CLASS="l">3714</TD><TD> * This method will do the following.</TD></TR><TR><TD CLASS="l">3715</TD><TD> * 1. Check to see if there are no open sessions in this group.</TD></TR><TR><TD CLASS="l">3716</TD><TD> * 2. Get the strategy for the session group.</TD></TR><TR><TD CLASS="l">3717</TD><TD> * 3. If strategy is to be auto started then perform end of session group.</TD></TR><TR><TD CLASS="l">3718</TD><TD> * 4. Call end of business day processing.</TD></TR><TR><TD CLASS="l">3719</TD><TD> *</TD></TR><TR><TD CLASS="l">3720</TD><TD> * NOTE: MAKE SURE THIS METHOD DOES NOT HANG, OTHER WISE IT WILL BLOCK ALL</TD></TR><TR><TD CLASS="l">3721</TD><TD> *                  OTHER TIMERS FROM EXPIRING.</TD></TR><TR><TD CLASS="l">3722</TD><TD> *</TD></TR><TR><TD CLASS="l">3723</TD><TD> *  @param sessionId the target session's identifier</TD></TR><TR><TD CLASS="l">3724</TD><TD> *  @param forceStart if true will forcefully do end of session processing.</TD></TR><TR><TD CLASS="l">3725</TD><TD> *  @param abortOnError if true processing will stop if not all clients have completed.</TD></TR><TR><TD CLASS="l">3726</TD><TD> *  @exception DataValidationException if strategies not found.</TD></TR><TR><TD CLASS="l"><A NAME="b7">3727</A></TD><TD> *  @exception TransactionFailedException does not occur becasue the processing is started in another thread.</TD></TR><TR><TD CLASS="l">3728</TD><TD> */</TD></TR><TR><TD CLASS="l">3729</TD><TD>public void startEndOfSession(String sessionName,boolean forceStart,boolean abortOnError) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3730</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3731</TD><TD>    logMessage(&#34;startEndOfSession is called. With session&#34; , sessionName);</TD></TR><TR><TD CLASS="l">3732</TD><TD>    </TD></TR><TR CLASS="z"><TD CLASS="l">3733</TD><TD>    startEndOfSession(sessionName, forceStart, abortOnError, registrationMapHome.getActiveClientsForSession(sessionName), registrationMapHome.getInactiveClientsForSession(sessionName));</TD></TR><TR CLASS="z"><TD CLASS="l">3734</TD><TD>}</TD></TR><TR><TD CLASS="l">3735</TD><TD> </TD></TR><TR><TD CLASS="l">3736</TD><TD>private void startEndOfSession(String sessionName,boolean forceStart,boolean abortOnError, String[] activeClients, String[] inactiveClients) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3737</TD><TD>{</TD></TR><TR><TD CLASS="l">3738</TD><TD>    //********** start of definition of innner class EndSessionThread *************</TD></TR><TR><TD CLASS="l">3739</TD><TD>        class EndSessionThread implements Runnable</TD></TR><TR><TD CLASS="l">3740</TD><TD>        {</TD></TR><TR><TD CLASS="l">3741</TD><TD>                TradingSession session;</TD></TR><TR><TD CLASS="l">3742</TD><TD>                TradingSessionEOSStrategy strategy;</TD></TR><TR><TD CLASS="l"><A NAME="cf">3743</A></TD><TD>                boolean abortOnError;</TD></TR><TR><TD CLASS="l">3744</TD><TD>        String[] activeClients, inactiveClients;</TD></TR><TR><TD CLASS="l">3745</TD><TD> </TD></TR><TR><TD CLASS="l">3746</TD><TD>                EndSessionThread(TradingSession aSession,TradingSessionEOSStrategy aStrategy,boolean anAbortOnError, String[] actives, String[] inactives)</TD></TR><TR CLASS="z"><TD CLASS="l">3747</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3748</TD><TD>                        session  = aSession;</TD></TR><TR CLASS="z"><TD CLASS="l">3749</TD><TD>                        strategy   = aStrategy;</TD></TR><TR CLASS="z"><TD CLASS="l">3750</TD><TD>                        abortOnError = anAbortOnError;</TD></TR><TR CLASS="z"><TD CLASS="l">3751</TD><TD>            activeClients = actives;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="d1">3752</A></TD><TD>            inactiveClients = inactives;</TD></TR><TR CLASS="z"><TD CLASS="l">3753</TD><TD>                }</TD></TR><TR><TD CLASS="l">3754</TD><TD> </TD></TR><TR><TD CLASS="l">3755</TD><TD>                public void run(){</TD></TR><TR CLASS="z"><TD CLASS="l">3756</TD><TD>                        String errMsg = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3757</TD><TD>            boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3758</TD><TD>            boolean lockReleased = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3759</TD><TD>            sessionClosedFlag =null;</TD></TR><TR><TD CLASS="l">3760</TD><TD>                        try        {</TD></TR><TR CLASS="z"><TD CLASS="l">3761</TD><TD>                                errMsg = &#34;Error performing End Of Session processing : Session(&#34; + session.getSessionName() + &#34;)&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">3762</TD><TD>                                strategy.performEndOfSession(session.getSessionName(),abortOnError, activeClients, inactiveClients);</TD></TR><TR CLASS="z"><TD CLASS="l">3763</TD><TD>                Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">3764</TD><TD>                session.completeEndOfSession();</TD></TR><TR CLASS="z"><TD CLASS="l">3765</TD><TD>                success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">3766</TD><TD>                if (success) {</TD></TR><TR CLASS="z"><TD CLASS="l">3767</TD><TD>                                    Log.information(TradingSessionServiceLocalImpl.this,&#34;End Of Session processing complete : Session(&#34; + session.getSessionName() + &#34;)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">3768</TD><TD>                    publishTradingSessionState(session);</TD></TR><TR><TD CLASS="l">3769</TD><TD>                    // need to release lock now before EOD processing may be started</TD></TR><TR CLASS="z"><TD CLASS="l">3770</TD><TD>                    releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">3771</TD><TD>                    lockReleased = true;</TD></TR><TR CLASS="z"><TD CLASS="l">3772</TD><TD>                                       if (session.isLastSessionOfDay() &amp;&amp; areAllSessionsClosed())        {  // Do the End of Business Day</TD></TR><TR CLASS="z"><TD CLASS="l">3773</TD><TD>                                            errMsg = &#34;Error performing End Of Day process.&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">3774</TD><TD>                                            startEndOfDay(false,true);</TD></TR><TR><TD CLASS="l">3775</TD><TD>                                    }</TD></TR><TR><TD CLASS="l">3776</TD><TD>                    else {</TD></TR><TR CLASS="z"><TD CLASS="l">3777</TD><TD>                        if (!session.isLastSessionOfDay())</TD></TR><TR CLASS="z"><TD CLASS="l">3778</TD><TD>                            Log.information(TradingSessionServiceLocalImpl.this,&#34;END OF DAY not yet performed because session (&#34; + session.getSessionName() + &#34;) is not the last session.&#34;);</TD></TR><TR><TD CLASS="l">3779</TD><TD>                        else</TD></TR><TR CLASS="z"><TD CLASS="l">3780</TD><TD>                            Log.information(TradingSessionServiceLocalImpl.this,&#34;END OF DAY not yet performed because not all sessions are closed.&#34;);</TD></TR><TR><TD CLASS="l">3781</TD><TD>                    }</TD></TR><TR><TD CLASS="l">3782</TD><TD> </TD></TR><TR><TD CLASS="l">3783</TD><TD>                }</TD></TR><TR><TD CLASS="l">3784</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">3785</TD><TD>                                    Log.alarm(TradingSessionServiceLocalImpl.this,errMsg + &#34;. Unable to commit transaction.&#34;);</TD></TR><TR><TD CLASS="l">3786</TD><TD>                }</TD></TR><TR><TD CLASS="l">3787</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3788</TD><TD>                        catch (DataValidationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">3789</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg + &#34;. Due to error: &#34; + e.details.message,e);</TD></TR><TR><TD CLASS="l">3790</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3791</TD><TD>                        catch (TransactionFailedException e){</TD></TR><TR CLASS="z"><TD CLASS="l">3792</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg + &#34;. Due to error: &#34; + e.details.message,e);</TD></TR><TR><TD CLASS="l">3793</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3794</TD><TD>                        catch (Exception e){</TD></TR><TR CLASS="z"><TD CLASS="l">3795</TD><TD>                                Log.exception(TradingSessionServiceLocalImpl.this,errMsg,e);</TD></TR><TR><TD CLASS="l">3796</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3797</TD><TD>            finally {</TD></TR><TR CLASS="z"><TD CLASS="l">3798</TD><TD>                if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">3799</TD><TD>                    if(Transaction.inTransaction())  //performEndOfSession could throw exception even before transaction is started.</TD></TR><TR><TD CLASS="l">3800</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">3801</TD><TD>                        Transaction.rollback();</TD></TR><TR><TD CLASS="l">3802</TD><TD>                    }</TD></TR><TR><TD CLASS="l">3803</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3804</TD><TD>                if (!lockReleased) {</TD></TR><TR CLASS="z"><TD CLASS="l">3805</TD><TD>                    releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR><TD CLASS="l">3806</TD><TD>                }</TD></TR><TR><TD CLASS="l">3807</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="b8">3808</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">3809</TD><TD>        }</TD></TR><TR><TD CLASS="l">3810</TD><TD>    //********** end of definition of innner class EndSessionThread *************</TD></TR><TR><TD CLASS="l">3811</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3812</TD><TD>    logMessage(&#34;active servers are&#34;, &#34;&#34;,activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">3813</TD><TD>    logMessage(&#34;inactive servers are &#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">3814</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3815</TD><TD>    TradingSession session = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">3816</TD><TD>    </TD></TR><TR><TD CLASS="l">3817</TD><TD>    // Clearing Market Data Summary cache</TD></TR><TR CLASS="z"><TD CLASS="l">3818</TD><TD>    getMarketDataSummaryHome().clearSummaryCache();</TD></TR><TR><TD CLASS="l">3819</TD><TD>    </TD></TR><TR><TD CLASS="l">3820</TD><TD>    // make sure that the session product cache is built prior to sending out events.</TD></TR><TR CLASS="z"><TD CLASS="l">3821</TD><TD>    getSessionProdCache(sessionName);</TD></TR><TR><TD CLASS="l">3822</TD><TD>    </TD></TR><TR CLASS="z"><TD CLASS="l">3823</TD><TD>        Log.information(&#34;Starting End Of Session processing : Session(&#34; + session.getSessionName() + &#34;). ForceStart/AbortOnError = &#34; + forceStart + &#34;/&#34; + abortOnError);</TD></TR><TR><TD CLASS="l">3824</TD><TD> </TD></TR><TR><TD CLASS="l">3825</TD><TD>        // DO VALIDATIONS</TD></TR><TR><TD CLASS="l">3826</TD><TD>        // Make sure all sessions for the group are closed.</TD></TR><TR><TD CLASS="l">3827</TD><TD>        // If force start is on, ignoe this check.</TD></TR><TR CLASS="z"><TD CLASS="l">3828</TD><TD>        if (!forceStart &amp;&amp; !session.allProductsClosed())</TD></TR><TR><TD CLASS="l">3829</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3830</TD><TD>                String errMsg = &#34;End Of Session processing for session(&#34; + session.getSessionName() + &#34;) not performed. All products in session are not closed.&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">3831</TD><TD>                throw ExceptionBuilder.transactionFailedException(errMsg,0);</TD></TR><TR><TD CLASS="l">3832</TD><TD>        }</TD></TR><TR><TD CLASS="l">3833</TD><TD> </TD></TR><TR><TD CLASS="l">3834</TD><TD>        // Get the group and the strategy associated with the group.</TD></TR><TR><TD CLASS="l">3835</TD><TD>        try</TD></TR><TR><TD CLASS="l">3836</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3837</TD><TD>                TradingSessionEOSStrategy eosStrategy = strategyFactory.getEndOfSessionStrategy(session.getEndOfSessionStrategy());</TD></TR><TR><TD CLASS="l">3838</TD><TD> </TD></TR><TR><TD CLASS="l">3839</TD><TD>                // ALL VALIDATIONS MUST BE DONE BEFORE THIS POINT</TD></TR><TR><TD CLASS="l">3840</TD><TD> </TD></TR><TR><TD CLASS="l">3841</TD><TD>                // If we auto starting or force starting.</TD></TR><TR CLASS="z"><TD CLASS="l">3842</TD><TD>                if (session.autoStartEndOfSession() || forceStart)</TD></TR><TR><TD CLASS="l">3843</TD><TD>                {</TD></TR><TR><TD CLASS="l">3844</TD><TD>            // Lock service before starting thread - need to get failure back to user</TD></TR><TR><TD CLASS="l">3845</TD><TD>            // Lock will be released when processing in thread completes.</TD></TR><TR CLASS="z"><TD CLASS="l">3846</TD><TD>            lockServiceForUpdates(activeClients, &#34;Start end of session for &#34; + sessionName); // LOCK BY CLIENT</TD></TR><TR><TD CLASS="l">3847</TD><TD> </TD></TR><TR><TD CLASS="l">3848</TD><TD>                        // Start the thread for end of session processing.</TD></TR><TR CLASS="z"><TD CLASS="l">3849</TD><TD>                        Thread t = new Thread(new EndSessionThread(session,eosStrategy,abortOnError,activeClients, inactiveClients));</TD></TR><TR CLASS="z"><TD CLASS="l">3850</TD><TD>                        t.start();</TD></TR><TR CLASS="z"><TD CLASS="l">3851</TD><TD>                }</TD></TR><TR><TD CLASS="l">3852</TD><TD>                else</TD></TR><TR><TD CLASS="l">3853</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">3854</TD><TD>                        Log.alarm(this,&#34;(AUTOMATIC END OF SESSION PROCESSING IS OFF). End Of Session not started, must be triggered manually : Session(&#34; + session.getSessionName() + &#34;)&#34;);</TD></TR><TR><TD CLASS="l">3855</TD><TD>                }</TD></TR><TR><TD CLASS="l">3856</TD><TD> </TD></TR><TR><TD CLASS="l">3857</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3858</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">3859</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3860</TD><TD>                throw ExceptionBuilder.dataValidationException(e.details.message,0);</TD></TR><TR CLASS="z"><TD CLASS="l">3861</TD><TD>        }</TD></TR><TR><TD CLASS="l">3862</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3863</TD><TD>}</TD></TR><TR><TD CLASS="l">3864</TD><TD>/**</TD></TR><TR><TD CLASS="l">3865</TD><TD> * This method currently just executes the end of business day functionality.</TD></TR><TR><TD CLASS="l">3866</TD><TD> * This method is currently triggered by TPF or can be triggered from IPD. 07/18/2005 ...</TD></TR><TR><TD CLASS="l">3867</TD><TD> * @param sessionKey - the target session's identifier</TD></TR><TR><TD CLASS="l">3868</TD><TD> * @exception DataValidationException</TD></TR><TR><TD CLASS="l"><A NAME="ba">3869</A></TD><TD> * @exception TransactionFailedException</TD></TR><TR><TD CLASS="l">3870</TD><TD> */</TD></TR><TR><TD CLASS="l">3871</TD><TD>public void startPriceAdjustments() throws DataValidationException</TD></TR><TR><TD CLASS="l">3872</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3873</TD><TD>        Log.information(this,&#34;Received STOCK_SPLIT_COMPLETED. SBT Price Adjustments will start now.&#34;);</TD></TR><TR><TD CLASS="l">3874</TD><TD> </TD></TR><TR><TD CLASS="l">3875</TD><TD>        try</TD></TR><TR><TD CLASS="l">3876</TD><TD>        {</TD></TR><TR><TD CLASS="l">3877</TD><TD>                // Just do the end of business day functionality.</TD></TR><TR><TD CLASS="l">3878</TD><TD>                // Force start end of business day but abort on first error.</TD></TR><TR CLASS="z"><TD CLASS="l">3879</TD><TD>                startEndOfDay(true,true);</TD></TR><TR><TD CLASS="l">3880</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3881</TD><TD>        catch (TransactionFailedException e)</TD></TR><TR><TD CLASS="l">3882</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3883</TD><TD>                Log.exception(this,&#34;Error performing End of Day processing....&#34;,e);</TD></TR><TR CLASS="z"><TD CLASS="l">3884</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3885</TD><TD>}</TD></TR><TR><TD CLASS="l">3886</TD><TD> </TD></TR><TR><TD CLASS="l">3887</TD><TD>/**</TD></TR><TR><TD CLASS="l">3888</TD><TD> *  Force the firing of any of the events types from TradingSessionEventType on the specefied servers</TD></TR><TR><TD CLASS="l">3889</TD><TD> *</TD></TR><TR><TD CLASS="l">3890</TD><TD> *  @param eventType: the enumerated value associated with the given</TD></TR><TR><TD CLASS="l">3891</TD><TD> *    TradingSessionEventType, accessed via the getEnumValue() method.</TD></TR><TR><TD CLASS="l">3892</TD><TD> *    For example, TradingSessionEventType.CLOSE_SESSION.getEnumValue()</TD></TR><TR><TD CLASS="l">3893</TD><TD> *</TD></TR><TR><TD CLASS="l">3894</TD><TD> *  @param sessionKey: the key associated with the trading session that this</TD></TR><TR><TD CLASS="l">3895</TD><TD> *    event is being fired for.</TD></TR><TR><TD CLASS="l">3896</TD><TD> *</TD></TR><TR><TD CLASS="l">3897</TD><TD> *  @param contextString: some events require a context string (for example,</TD></TR><TR><TD CLASS="l">3898</TD><TD> *    SESSION_LOST requires the session name).</TD></TR><TR><TD CLASS="l">3899</TD><TD> *</TD></TR><TR><TD CLASS="l">3900</TD><TD> *  @return boolean the value is pretty useless. AMI calls may not complete.</TD></TR><TR><TD CLASS="l"><A NAME="2c">3901</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3902</TD><TD>public boolean fireEventForServers(int eventType, String sessionName, String contextString, boolean waitForCompletion, boolean vetoable, String[] serverNames)</TD></TR><TR><TD CLASS="l">3903</TD><TD>    throws DataValidationException, AuthorizationException, TransactionFailedException, CommunicationException, SystemException</TD></TR><TR><TD CLASS="l">3904</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3905</TD><TD>    logMessage(&#34;fireEventForServers is called &#34;, sessionName, serverNames );</TD></TR><TR CLASS="z"><TD CLASS="l">3906</TD><TD>    validateServerNamesWithSession(sessionName,serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3907</TD><TD>    return fireEvent(eventType,sessionName,contextString,waitForCompletion, vetoable, serverNames, new String[0]);</TD></TR><TR><TD CLASS="l">3908</TD><TD>}</TD></TR><TR><TD CLASS="l">3909</TD><TD> </TD></TR><TR><TD CLASS="l">3910</TD><TD>/**</TD></TR><TR><TD CLASS="l">3911</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="b9">3912</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3913</TD><TD>public void startEndOfSessionForServers(String sessionName, boolean forceStart, boolean abortOnError, String[] serverNames)</TD></TR><TR><TD CLASS="l">3914</TD><TD>    throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3915</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3916</TD><TD>    logMessage(&#34;startEndOfSessionForServers is called. With session&#34; , sessionName , serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3917</TD><TD>    validateServerNamesWithSession(sessionName, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3918</TD><TD>    startEndOfSession(sessionName, forceStart, abortOnError, serverNames, new String[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">3919</TD><TD>}</TD></TR><TR><TD CLASS="l">3920</TD><TD> </TD></TR><TR><TD CLASS="l">3921</TD><TD>/**</TD></TR><TR><TD CLASS="l">3922</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="b3">3923</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3924</TD><TD>public void startEndOfDayForServers(boolean forceStart, boolean abortOnError, String[] serverNames)</TD></TR><TR><TD CLASS="l">3925</TD><TD>    throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3926</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3927</TD><TD>    logMessage(&#34;startEndOfDayForServers is called.&#34;, &#34;&#34;, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3928</TD><TD>    validateServerNames(serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3929</TD><TD>    startEndOfDay(forceStart, abortOnError, serverNames, new String[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">3930</TD><TD>}</TD></TR><TR><TD CLASS="l">3931</TD><TD> </TD></TR><TR><TD CLASS="l">3932</TD><TD>/**</TD></TR><TR><TD CLASS="l">3933</TD><TD> * This methods executes the end of business day functionality for the given servers.</TD></TR><TR><TD CLASS="l"><A NAME="bb">3934</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3935</TD><TD>public void startPriceAdjustmentsForServers(String[] serverNames)</TD></TR><TR><TD CLASS="l">3936</TD><TD>        throws DataValidationException</TD></TR><TR><TD CLASS="l">3937</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3938</TD><TD>    logMessage(&#34;startPriceAdjustmentsForServers is called.&#34;, &#34;&#34;, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3939</TD><TD>    validateServerNames(serverNames);</TD></TR><TR><TD CLASS="l">3940</TD><TD>    try</TD></TR><TR><TD CLASS="l">3941</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3942</TD><TD>        startEndOfDayForServers(true, true, serverNames );</TD></TR><TR><TD CLASS="l">3943</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3944</TD><TD>    catch(TransactionFailedException e)</TD></TR><TR><TD CLASS="l">3945</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3946</TD><TD>        Log.exception(this, &#34;Error performing startPriceAdjustmentsForServers&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">3947</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3948</TD><TD>}</TD></TR><TR><TD CLASS="l">3949</TD><TD> </TD></TR><TR><TD CLASS="l">3950</TD><TD>/**</TD></TR><TR><TD CLASS="l">3951</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="90">3952</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3953</TD><TD>public void priceAdjustmentsCompleteForServers(String[] serverNames)</TD></TR><TR><TD CLASS="l">3954</TD><TD>    throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">3955</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">3956</TD><TD>    logMessage(&#34;priceAdjustmentsCompleteForServers is called&#34;, &#34;&#34;, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3957</TD><TD>    validateServerNames(serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">3958</TD><TD>    priceAdjustmentsComplete(serverNames, new String[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">3959</TD><TD>}</TD></TR><TR><TD CLASS="l">3960</TD><TD> </TD></TR><TR><TD CLASS="l">3961</TD><TD>/**</TD></TR><TR><TD CLASS="l">3962</TD><TD> * Register the client for the given session name and client name</TD></TR><TR><TD CLASS="l">3963</TD><TD> * @param sessionNames</TD></TR><TR><TD CLASS="l">3964</TD><TD> * @param clientName</TD></TR><TR><TD CLASS="l">3965</TD><TD> * @param client</TD></TR><TR><TD CLASS="l">3966</TD><TD> * @throws DataValidationException</TD></TR><TR><TD CLASS="l">3967</TD><TD> * @throws AuthorizationException</TD></TR><TR><TD CLASS="l">3968</TD><TD> * @throws CommunicationException</TD></TR><TR><TD CLASS="l">3969</TD><TD> * @throws SystemException</TD></TR><TR><TD CLASS="l"><A NAME="99">3970</A></TD><TD> */</TD></TR><TR><TD CLASS="l">3971</TD><TD>public void registerClientWithSessions(String[] sessionNames, String clientName, TradingSessionClient client, KeyValueStruct[] registrationDetails)</TD></TR><TR><TD CLASS="l">3972</TD><TD>{</TD></TR><TR><TD CLASS="l">3973</TD><TD>    String session;</TD></TR><TR CLASS="z"><TD CLASS="l">3974</TD><TD>    boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3975</TD><TD>    if(sessionNames == null || sessionNames.length == 0 || sessionNames[0].equals(&#34;&#34;) || sessionNames[0].equals(&#34; &#34;))</TD></TR><TR><TD CLASS="l">3976</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3977</TD><TD>        sessionNames = new String[] { SessionNameValues.ALL_SESSION_NAME };</TD></TR><TR CLASS="z"><TD CLASS="l">3978</TD><TD>        Log.information(this,&#34;Client - &#34; + clientName + &#34; will be registed for all sessions as it passed empty/null session list.&#34;);</TD></TR><TR><TD CLASS="l">3979</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">3980</TD><TD>    for(int i=0; i&lt; sessionNames.length; i++)</TD></TR><TR><TD CLASS="l">3981</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">3982</TD><TD>        success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3983</TD><TD>        session = sessionNames[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3984</TD><TD>        Log.information(this,&#34;Remote client registered:session name/client name=&#34; + session + &#34;/&#34; +clientName);</TD></TR><TR><TD CLASS="l">3985</TD><TD>        try</TD></TR><TR><TD CLASS="l">3986</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3987</TD><TD>            Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">3988</TD><TD>            registrationMapHome.registerClient(session, clientName, client, registrationDetails);</TD></TR><TR CLASS="z"><TD CLASS="l">3989</TD><TD>            success = Transaction.commit();</TD></TR><TR><TD CLASS="l">3990</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3991</TD><TD>        catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">3992</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3993</TD><TD>            Log.exception(this, &#34;Could not register the client with TSS client/session:&#34; + clientName + &#34;/&#34; + session, e);</TD></TR><TR><TD CLASS="l">3994</TD><TD>        }</TD></TR><TR><TD CLASS="l">3995</TD><TD>        finally</TD></TR><TR><TD CLASS="l">3996</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">3997</TD><TD>            if(!success)</TD></TR><TR><TD CLASS="l">3998</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">3999</TD><TD>                Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">4000</TD><TD>                Log.alarm(this, &#34; Could not registerClientWithSession for client/session:&#34; + clientName + &#34;/&#34; + session);</TD></TR><TR><TD CLASS="l">4001</TD><TD>            }</TD></TR><TR><TD CLASS="l">4002</TD><TD>        }</TD></TR><TR><TD CLASS="l">4003</TD><TD>    }</TD></TR><TR><TD CLASS="l">4004</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4005</TD><TD>    if(Log.isDebugOn())</TD></TR><TR><TD CLASS="l">4006</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4007</TD><TD>        if(registrationDetails != null &amp;&amp; registrationDetails.length &gt; 0)</TD></TR><TR><TD CLASS="l">4008</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4009</TD><TD>            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">4010</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4011</TD><TD>                Log.debug(this, &#34;for client &#34; + clientName + &#34; registrationDetail = &#34; + registrationDetails[0].key + &#34;/&#34; + registrationDetails[0].value);</TD></TR><TR><TD CLASS="l">4012</TD><TD>            }</TD></TR><TR><TD CLASS="l">4013</TD><TD>        }</TD></TR><TR><TD CLASS="l">4014</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4015</TD><TD>}</TD></TR><TR><TD CLASS="l">4016</TD><TD> </TD></TR><TR><TD CLASS="l">4017</TD><TD>/**</TD></TR><TR><TD CLASS="l">4018</TD><TD> * start the session on the specified servers</TD></TR><TR><TD CLASS="l">4019</TD><TD> * @param sessionName</TD></TR><TR><TD CLASS="l">4020</TD><TD> * @param serverNames</TD></TR><TR><TD CLASS="l">4021</TD><TD> * @throws DataValidationException</TD></TR><TR><TD CLASS="l">4022</TD><TD> * @throws TransactionFailedException</TD></TR><TR><TD CLASS="l"><A NAME="bf">4023</A></TD><TD> */</TD></TR><TR><TD CLASS="l">4024</TD><TD>public void startSessionForServers(String sessionName, String[] serverNames)</TD></TR><TR><TD CLASS="l">4025</TD><TD>        throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4026</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">4027</TD><TD>    startSessionForServers(sessionName, serverNames, false /* no quick start - update the tselement */);</TD></TR><TR CLASS="z"><TD CLASS="l">4028</TD><TD>}</TD></TR><TR><TD CLASS="l">4029</TD><TD> </TD></TR><TR><TD CLASS="l">4030</TD><TD>/**</TD></TR><TR><TD CLASS="l">4031</TD><TD> *  start the session on the specified servers</TD></TR><TR><TD CLASS="l">4032</TD><TD> * but bypass the rebuilding of the trading session element</TD></TR><TR><TD CLASS="l">4033</TD><TD> * to speed up the session start.</TD></TR><TR><TD CLASS="l">4034</TD><TD>  * @param sessionName</TD></TR><TR><TD CLASS="l">4035</TD><TD> * @param serverNames</TD></TR><TR><TD CLASS="l">4036</TD><TD> * @param quickStart</TD></TR><TR><TD CLASS="l">4037</TD><TD> * @throws DataValidationException</TD></TR><TR><TD CLASS="l">4038</TD><TD> * @throws TransactionFailedException</TD></TR><TR><TD CLASS="l"><A NAME="c0">4039</A></TD><TD> */</TD></TR><TR><TD CLASS="l">4040</TD><TD>public void startSessionForServers(String sessionName, String[] serverNames, boolean quickStart)</TD></TR><TR><TD CLASS="l">4041</TD><TD>        throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4042</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">4043</TD><TD>    logMessage(&#34;startSessionForServers is called with session&#34; , sessionName , serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">4044</TD><TD>    if(quickStart){</TD></TR><TR CLASS="z"><TD CLASS="l">4045</TD><TD>    Log.information(this, &#34;The updating of the Trading Session Element will be skipped&#34;);</TD></TR><TR><TD CLASS="l">4046</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4047</TD><TD>    validateServerNamesWithSession(sessionName, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">4048</TD><TD>    startSession(sessionName, serverNames, new String[0]/*no inactive servers*/, quickStart);</TD></TR><TR CLASS="z"><TD CLASS="l">4049</TD><TD>}</TD></TR><TR><TD CLASS="l">4050</TD><TD> </TD></TR><TR><TD CLASS="l">4051</TD><TD> </TD></TR><TR><TD CLASS="l">4052</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4053</TD><TD>     * Invoke the startSession(sessionId) method on each of the known TradingSessionClient objects.</TD></TR><TR><TD CLASS="l">4054</TD><TD>     *</TD></TR><TR><TD CLASS="l">4055</TD><TD>     * NOTE: MAKE SURE THIS METHOD DOES NOT HANG, OTHER WISE IT WILL BLOCK ALL</TD></TR><TR><TD CLASS="l">4056</TD><TD>     *                  OTHER TIMERS FROM EXPIRING.</TD></TR><TR><TD CLASS="l">4057</TD><TD>     *</TD></TR><TR><TD CLASS="l">4058</TD><TD>     * @param sessionKey the target session's identifier</TD></TR><TR><TD CLASS="l">4059</TD><TD>     * @exception DataValidationException if the session key is invalid.</TD></TR><TR><TD CLASS="l"><A NAME="bc">4060</A></TD><TD>     * @exception TransactionFailedException will not occur any more because a new thread is started.</TD></TR><TR><TD CLASS="l">4061</TD><TD>     */</TD></TR><TR><TD CLASS="l">4062</TD><TD>    public void startSession(String sessionName) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4063</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4064</TD><TD>        startSession(sessionName, false /* no quick start - update the tselement */);</TD></TR><TR CLASS="z"><TD CLASS="l">4065</TD><TD>    }</TD></TR><TR><TD CLASS="l">4066</TD><TD> </TD></TR><TR><TD CLASS="l">4067</TD><TD>    /** Start the session. Pass the flag to indicate if the trading session element should be updated with any added classes</TD></TR><TR><TD CLASS="l">4068</TD><TD>     *  based on the template.</TD></TR><TR><TD CLASS="l">4069</TD><TD>     *</TD></TR><TR><TD CLASS="l">4070</TD><TD>     * @param sessionName</TD></TR><TR><TD CLASS="l">4071</TD><TD>     * @param quickStart</TD></TR><TR><TD CLASS="l">4072</TD><TD>     * @throws DataValidationException</TD></TR><TR><TD CLASS="l"><A NAME="be">4073</A></TD><TD>     * @throws TransactionFailedException</TD></TR><TR><TD CLASS="l">4074</TD><TD>     */</TD></TR><TR><TD CLASS="l">4075</TD><TD>    public void startSession(String sessionName, boolean quickStart) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4076</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4077</TD><TD>        logMessage(&#34;startSession is called with session &#34;, sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4078</TD><TD>        quickStart = getQuickStartSessionFlag();</TD></TR><TR CLASS="z"><TD CLASS="l">4079</TD><TD>        if(quickStart){</TD></TR><TR CLASS="z"><TD CLASS="l">4080</TD><TD>            Log.information(this, &#34;The updating of the Trading Session Element will be skipped&#34;);</TD></TR><TR><TD CLASS="l">4081</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4082</TD><TD>        startSession(sessionName, registrationMapHome.getActiveClientsForSession(sessionName), registrationMapHome.getInactiveClientsForSession(sessionName), quickStart);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="87">4083</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4084</TD><TD> </TD></TR><TR><TD CLASS="l">4085</TD><TD>    private void logMessage(String method, String sessionName)</TD></TR><TR><TD CLASS="l">4086</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4087</TD><TD>        logMessage(method, sessionName, new String[0]);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="88">4088</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4089</TD><TD> </TD></TR><TR><TD CLASS="l">4090</TD><TD>    private void logMessage(String method, String session, String[] servers)</TD></TR><TR><TD CLASS="l">4091</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4092</TD><TD>        StringBuffer serverList = new StringBuffer();</TD></TR><TR CLASS="z"><TD CLASS="l">4093</TD><TD>        if(servers.length &gt; 0)</TD></TR><TR><TD CLASS="l">4094</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4095</TD><TD>            serverList.append(&#34; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4096</TD><TD>            for(int i=0; i &lt; servers.length; i++)</TD></TR><TR><TD CLASS="l">4097</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4098</TD><TD>                serverList.append(&#34; : &#34;).append(servers[i]);</TD></TR><TR><TD CLASS="l">4099</TD><TD>            }</TD></TR><TR><TD CLASS="l">4100</TD><TD>        }</TD></TR><TR><TD CLASS="l">4101</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4102</TD><TD>        Log.information(this, method + session + serverList);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c2">4103</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4104</TD><TD> </TD></TR><TR><TD CLASS="l">4105</TD><TD>    private void validateServerNames(String[] serverNames) throws DataValidationException</TD></TR><TR><TD CLASS="l">4106</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4107</TD><TD>        boolean success = true;</TD></TR><TR CLASS="z"><TD CLASS="l">4108</TD><TD>        StringBuffer invalidServers = new StringBuffer();</TD></TR><TR CLASS="z"><TD CLASS="l">4109</TD><TD>        for(int i=0; i &lt; serverNames.length; i++)</TD></TR><TR><TD CLASS="l">4110</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4111</TD><TD>            if( ! registrationMapHome.validateClientRegistration(serverNames[i]))</TD></TR><TR><TD CLASS="l">4112</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4113</TD><TD>                success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4114</TD><TD>                invalidServers.append(&#34; : &#34;).append(serverNames[i]);</TD></TR><TR><TD CLASS="l">4115</TD><TD>            }</TD></TR><TR><TD CLASS="l">4116</TD><TD>        }</TD></TR><TR><TD CLASS="l">4117</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4118</TD><TD>        if(!success)</TD></TR><TR><TD CLASS="l">4119</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4120</TD><TD>            Log.information(this, &#34;Invalid servers name supplied &#34;  + invalidServers);</TD></TR><TR CLASS="z"><TD CLASS="l">4121</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Request is rejected because there are one/more invalid servers supplied:&#34;</TD></TR><TR><TD CLASS="l">4122</TD><TD>                    + invalidServers, DataValidationCodes.INVALID_GROUP);</TD></TR><TR><TD CLASS="l">4123</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c3">4124</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4125</TD><TD> </TD></TR><TR><TD CLASS="l">4126</TD><TD>    private void validateServerNamesWithSession(String sessionName, String[] serverNames) throws DataValidationException</TD></TR><TR><TD CLASS="l">4127</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4128</TD><TD>        boolean success = true;</TD></TR><TR CLASS="z"><TD CLASS="l">4129</TD><TD>        String invalidServers = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">4130</TD><TD>        for(int i=0; i &lt; serverNames.length; i++)</TD></TR><TR><TD CLASS="l">4131</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4132</TD><TD>            if( ! registrationMapHome.validateClientRegistration(sessionName, serverNames[i]))</TD></TR><TR><TD CLASS="l">4133</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4134</TD><TD>                success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4135</TD><TD>                invalidServers += &#34; : &#34; + serverNames[i];</TD></TR><TR><TD CLASS="l">4136</TD><TD>            }</TD></TR><TR><TD CLASS="l">4137</TD><TD>        }</TD></TR><TR><TD CLASS="l">4138</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4139</TD><TD>        if(!success)</TD></TR><TR><TD CLASS="l">4140</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4141</TD><TD>            Log.information(this, &#34;Invalid session-servers combination supplied &#34; + sessionName + &#34; - &#34; + invalidServers);</TD></TR><TR CLASS="z"><TD CLASS="l">4142</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Request is rejected because there are one/more invalid servers for the session supplied:&#34;</TD></TR><TR><TD CLASS="l">4143</TD><TD>                    + invalidServers, DataValidationCodes.INVALID_GROUP);</TD></TR><TR><TD CLASS="l">4144</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4145</TD><TD>    }</TD></TR><TR><TD CLASS="l">4146</TD><TD> </TD></TR><TR><TD CLASS="l">4147</TD><TD>/**</TD></TR><TR><TD CLASS="l">4148</TD><TD> * Invoke the startSession(sessionId) method on each of the known TradingSessionClient objects.</TD></TR><TR><TD CLASS="l">4149</TD><TD> *</TD></TR><TR><TD CLASS="l">4150</TD><TD> * NOTE: MAKE SURE THIS METHOD DOES NOT HANG, OTHER WISE IT WILL BLOCK ALL</TD></TR><TR><TD CLASS="l">4151</TD><TD> *                  OTHER TIMERS FROM EXPIRING.</TD></TR><TR><TD CLASS="l">4152</TD><TD> *</TD></TR><TR><TD CLASS="l">4153</TD><TD> * @param sessionKey the target session's identifier</TD></TR><TR><TD CLASS="l">4154</TD><TD> * @exception DataValidationException if the session key is invalid.</TD></TR><TR><TD CLASS="l">4155</TD><TD> * @exception TransactionFailedException will not occur any more because a new thread is started.</TD></TR><TR><TD CLASS="l">4156</TD><TD> */</TD></TR><TR><TD CLASS="l">4157</TD><TD>private void startSession(String sessionName, String[] activeClients, String[] inactiveClients, boolean quickStart) throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4158</TD><TD>{</TD></TR><TR><TD CLASS="l">4159</TD><TD>    // Create a new thread to start the session.</TD></TR><TR><TD CLASS="l">4160</TD><TD>        // So as to not hold up other timers from dequeing.</TD></TR><TR><TD CLASS="l">4161</TD><TD>        class StartSessionThread implements Runnable</TD></TR><TR><TD CLASS="l">4162</TD><TD>        {</TD></TR><TR><TD CLASS="l">4163</TD><TD>                TradingSession session;</TD></TR><TR><TD CLASS="l">4164</TD><TD>        String[] activeClients;</TD></TR><TR><TD CLASS="l"><A NAME="d8">4165</A></TD><TD>        String[] inactiveClients;</TD></TR><TR><TD CLASS="l">4166</TD><TD>        boolean quickStart;</TD></TR><TR><TD CLASS="l">4167</TD><TD> </TD></TR><TR><TD CLASS="l">4168</TD><TD>                StartSessionThread(TradingSession aSession, String[] active, String[] inactive, boolean quick)</TD></TR><TR CLASS="z"><TD CLASS="l">4169</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4170</TD><TD>                        session = aSession;</TD></TR><TR CLASS="z"><TD CLASS="l">4171</TD><TD>            activeClients = active;</TD></TR><TR CLASS="z"><TD CLASS="l">4172</TD><TD>            inactiveClients = inactive;</TD></TR><TR CLASS="z"><TD CLASS="l">4173</TD><TD>            quickStart = quick;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="da">4174</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">4175</TD><TD>                public void run()</TD></TR><TR><TD CLASS="l">4176</TD><TD>                {</TD></TR><TR><TD CLASS="l">4177</TD><TD>                        // Start the session.</TD></TR><TR CLASS="z"><TD CLASS="l">4178</TD><TD>            boolean success = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4179</TD><TD>            sessionClosedFlag = null;</TD></TR><TR><TD CLASS="l">4180</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">4181</TD><TD>                            Log.information(TradingSessionServiceLocalImpl.this,&#34;Starting session : &#34; + session.getSessionName());</TD></TR><TR CLASS="z"><TD CLASS="l">4182</TD><TD>                Transaction.startTransaction();</TD></TR><TR CLASS="z"><TD CLASS="l">4183</TD><TD>                session.startSession(quickStart);</TD></TR><TR CLASS="z"><TD CLASS="l">4184</TD><TD>                success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">4185</TD><TD>                if (success) {</TD></TR><TR CLASS="z"><TD CLASS="l">4186</TD><TD>                                Log.information(TradingSessionServiceLocalImpl.this,&#34;Session started : &#34; + session.getSessionName() + &#34;. NOW SENDING START_SESSION TO ALL SERVERS.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4187</TD><TD>                    publishTradingSessionState(session);</TD></TR><TR><TD CLASS="l">4188</TD><TD>                }</TD></TR><TR><TD CLASS="l">4189</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">4190</TD><TD>                                Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Start session failed for session : &#34; + session.getSessionName() + &#34;. Unable to commit transaction.&#34;);</TD></TR><TR><TD CLASS="l">4191</TD><TD>                }</TD></TR><TR><TD CLASS="l">4192</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4193</TD><TD>            catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4194</TD><TD>                Log.exception(TradingSessionServiceLocalImpl.this, &#34;Start session failed for session : &#34; + session.getSessionName(), e);</TD></TR><TR><TD CLASS="l">4195</TD><TD>            }</TD></TR><TR><TD CLASS="l">4196</TD><TD>            finally {</TD></TR><TR CLASS="z"><TD CLASS="l">4197</TD><TD>                if (!success) {</TD></TR><TR CLASS="z"><TD CLASS="l">4198</TD><TD>                    Transaction.rollback();</TD></TR><TR CLASS="z"><TD CLASS="l">4199</TD><TD>                    releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">4200</TD><TD>                    return;</TD></TR><TR><TD CLASS="l">4201</TD><TD>                }</TD></TR><TR><TD CLASS="l">4202</TD><TD>            }</TD></TR><TR><TD CLASS="l">4203</TD><TD> </TD></TR><TR><TD CLASS="l">4204</TD><TD>            // send notice to clients</TD></TR><TR><TD CLASS="l">4205</TD><TD>                        TradingSessionClientAction action;</TD></TR><TR CLASS="z"><TD CLASS="l">4206</TD><TD>            TradingSessionStruct sessionStruct = sessionHome.toStruct(session);</TD></TR><TR CLASS="z"><TD CLASS="l">4207</TD><TD>                        action = new TradingSessionClientAction(TradingSessionServiceLocalImpl.this, TradingSessionEventType.PREPARE_START_OF_SESSION,sessionStruct,null, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">4208</TD><TD> </TD></TR><TR><TD CLASS="l">4209</TD><TD>                        // Wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">4210</TD><TD>                        execute(true,action);</TD></TR><TR><TD CLASS="l">4211</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4212</TD><TD>                        if (action.allClientsComplete())</TD></TR><TR><TD CLASS="l">4213</TD><TD>                        {</TD></TR><TR><TD CLASS="l">4214</TD><TD>                // first step succeeded - do second step</TD></TR><TR CLASS="z"><TD CLASS="l">4215</TD><TD>                            action = new TradingSessionClientAction(TradingSessionServiceLocalImpl.this, TradingSessionEventType.START_SESSION,sessionStruct,null, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">4216</TD><TD> </TD></TR><TR><TD CLASS="l">4217</TD><TD>                            // Wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">4218</TD><TD>                            execute(true,action);</TD></TR><TR><TD CLASS="l">4219</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4220</TD><TD>            else if(!startSessionAbortOnError)</TD></TR><TR><TD CLASS="l">4221</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4222</TD><TD>                Log.information(&#34;startSessionAbortOnError is set to :&#34; + startSessionAbortOnError + &#34; so will continue even though one/more server failed for action &#34; + action);</TD></TR><TR><TD CLASS="l">4223</TD><TD>                String[] clientsToDisable;</TD></TR><TR><TD CLASS="l">4224</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4225</TD><TD>                clientsToDisable = action.getClients(ClientAction.CLIENT_STATE_TYPE_NEED_TO_DISABLE);</TD></TR><TR><TD CLASS="l">4226</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4227</TD><TD>                action = new TradingSessionClientAction(TradingSessionServiceLocalImpl.this, TradingSessionEventType.START_SESSION,sessionStruct,null, activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">4228</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4229</TD><TD>                action.disableClients( clientsToDisable);</TD></TR><TR><TD CLASS="l">4230</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4231</TD><TD>                execute(true, action);</TD></TR><TR><TD CLASS="l">4232</TD><TD>            }</TD></TR><TR><TD CLASS="l">4233</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4234</TD><TD>                        if (!action.allClientsComplete())</TD></TR><TR><TD CLASS="l">4235</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">4236</TD><TD>                                if (action.nbrExceptions != action.nbrCalled) // at least one was successfull.</TD></TR><TR><TD CLASS="l">4237</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">4238</TD><TD>                                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Session started (but not all servers completed) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">4239</TD><TD>                                }</TD></TR><TR><TD CLASS="l">4240</TD><TD>                                else</TD></TR><TR><TD CLASS="l">4241</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">4242</TD><TD>                                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Error starting session (ALL SERVERS ARE DOWN) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">4243</TD><TD>                                }</TD></TR><TR><TD CLASS="l">4244</TD><TD>                        }</TD></TR><TR><TD CLASS="l">4245</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="bd">4246</A></TD><TD>            releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">4247</TD><TD>                }</TD></TR><TR><TD CLASS="l">4248</TD><TD>        }</TD></TR><TR><TD CLASS="l">4249</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4250</TD><TD>    logMessage(&#34;active servers are&#34;,&#34;&#34;, activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">4251</TD><TD>    logMessage(&#34;inactive servers are&#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">4252</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4253</TD><TD>    TradingSession session = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">4254</TD><TD> </TD></TR><TR><TD CLASS="l">4255</TD><TD>    // make sure that the session product cache is built prior to sending out events.</TD></TR><TR CLASS="z"><TD CLASS="l">4256</TD><TD>    getSessionProdCache(sessionName);</TD></TR><TR><TD CLASS="l">4257</TD><TD>    </TD></TR><TR><TD CLASS="l">4258</TD><TD>    // Sessions only used for underlying products do not have a product state service configured for them,</TD></TR><TR><TD CLASS="l">4259</TD><TD>    // so those sessions cannot be started.</TD></TR><TR CLASS="z"><TD CLASS="l">4260</TD><TD>    if (TradingSessionNameHelper.isUnderlyingSession(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">4261</TD><TD>        throw ExceptionBuilder.dataValidationException(&#34;Cannot start a session only used for underlying products&#34;, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">4262</TD><TD>    }</TD></TR><TR><TD CLASS="l">4263</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4264</TD><TD>    if (TradingSessionNameHelper.isNotApplicableSession(sessionName))</TD></TR><TR><TD CLASS="l">4265</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4266</TD><TD>        throw ExceptionBuilder.dataValidationException(&#34;Cannot start a NOT_APPLICABLE session: &#34; + sessionName, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">4267</TD><TD>    }</TD></TR><TR><TD CLASS="l">4268</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4269</TD><TD>    if (getBusinessDayHome().findCurrent().getState() == BusinessDayStates.STARTED)</TD></TR><TR><TD CLASS="l">4270</TD><TD>    {</TD></TR><TR><TD CLASS="l">4271</TD><TD>        // Need to lock service before starting thread so user will get error if other update in progress</TD></TR><TR><TD CLASS="l">4272</TD><TD>        // Release will be done at end of processing by thread.</TD></TR><TR CLASS="z"><TD CLASS="l">4273</TD><TD>        lockServiceForUpdates(activeClients, &#34;Starting session &#34; + sessionName); // LOCK BY CLIENT</TD></TR><TR><TD CLASS="l">4274</TD><TD> </TD></TR><TR><TD CLASS="l">4275</TD><TD>            // Log and tell everyone.</TD></TR><TR CLASS="z"><TD CLASS="l">4276</TD><TD>            Log.information(this,&#34;Starting Session : Session(&#34; + session.getSessionName() + &#34;), Start session timer will be deleted.&#34;);</TD></TR><TR><TD CLASS="l">4277</TD><TD> </TD></TR><TR><TD CLASS="l">4278</TD><TD>        // Create thread and start it.</TD></TR><TR CLASS="z"><TD CLASS="l">4279</TD><TD>            Thread t = new Thread(new StartSessionThread(session, activeClients, inactiveClients, quickStart));</TD></TR><TR CLASS="z"><TD CLASS="l">4280</TD><TD>            t.start();</TD></TR><TR CLASS="z"><TD CLASS="l">4281</TD><TD>    }</TD></TR><TR><TD CLASS="l">4282</TD><TD>    else</TD></TR><TR><TD CLASS="l">4283</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4284</TD><TD>        String errorMessage = &#34;Session &#34; + sessionName + &#34; could not be started - business day (&#34; + TimeHelper.toDateString(getBusinessDayHome().findCurrent().getDate().getTime()) + &#34;) is not started&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">4285</TD><TD>        Log.alarm(this, errorMessage);</TD></TR><TR CLASS="z"><TD CLASS="l">4286</TD><TD>        throw ExceptionBuilder.dataValidationException(errorMessage, 0);</TD></TR><TR><TD CLASS="l">4287</TD><TD>    }</TD></TR><TR><TD CLASS="l">4288</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4289</TD><TD>}</TD></TR><TR><TD CLASS="l">4290</TD><TD>        </TD></TR><TR><TD CLASS="l">4291</TD><TD> </TD></TR><TR><TD CLASS="l">4292</TD><TD>        </TD></TR><TR><TD CLASS="l">4293</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="7f">4294</A></TD><TD>         * </TD></TR><TR><TD CLASS="l">4295</TD><TD>         */</TD></TR><TR><TD CLASS="l">4296</TD><TD>        private boolean isMultiClassStrategyLegs (TradingSession session, StrategyRequestStruct strategyRequest)</TD></TR><TR><TD CLASS="l">4297</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4298</TD><TD>        boolean validMultiClassStrategy = true;</TD></TR><TR><TD CLASS="l">4299</TD><TD>                try </TD></TR><TR><TD CLASS="l">4300</TD><TD>                {</TD></TR><TR><TD CLASS="l">4301</TD><TD>                        // check if all legs are OPTIONs and they belong to the multiclass strategy classes and all are in the current session</TD></TR><TR CLASS="z"><TD CLASS="l">4302</TD><TD>                ProductKeysStruct[] productKeys     = new ProductKeysStruct[ strategyRequest.strategyLegs.length ];</TD></TR><TR CLASS="z"><TD CLASS="l">4303</TD><TD>            int[] classKeys = new int[productKeys.length];</TD></TR><TR CLASS="z"><TD CLASS="l">4304</TD><TD>                for ( int i = 0; validMultiClassStrategy &amp;&amp; (i &lt; strategyRequest.strategyLegs.length); i++ )</TD></TR><TR><TD CLASS="l">4305</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4306</TD><TD>                        SessionElementClass sessionClass    = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4307</TD><TD>                    productKeys[i] = getProductQueryService().getProductKeys(strategyRequest.strategyLegs[i].product);</TD></TR><TR CLASS="z"><TD CLASS="l">4308</TD><TD>                        if (productKeys[i].productType != ProductTypes.OPTION)</TD></TR><TR><TD CLASS="l">4309</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">4310</TD><TD>                                validMultiClassStrategy = false;</TD></TR><TR><TD CLASS="l">4311</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4312</TD><TD>                        else if ((sessionClass = session.findClassByKey(productKeys[i].classKey)) == null)</TD></TR><TR><TD CLASS="l">4313</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">4314</TD><TD>                                validMultiClassStrategy = false;</TD></TR><TR><TD CLASS="l">4315</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4316</TD><TD>                        classKeys[i] = productKeys[i].classKey;                        </TD></TR><TR><TD CLASS="l">4317</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4318</TD><TD>                if (validMultiClassStrategy &amp;&amp; !(MultiClassStrategyUtils.isMultiClassStrategyClassKeys(classKeys)))</TD></TR><TR><TD CLASS="l">4319</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4320</TD><TD>                        validMultiClassStrategy = false;</TD></TR><TR><TD CLASS="l">4321</TD><TD>                }                </TD></TR><TR><TD CLASS="l">4322</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4323</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">4324</TD><TD>                {</TD></TR><TR><TD CLASS="l">4325</TD><TD>                        // If any exception occurs, just log the exception and set the validMultiClassStrategy to false. </TD></TR><TR CLASS="z"><TD CLASS="l">4326</TD><TD>                        validMultiClassStrategy = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4327</TD><TD>                        Log.exception(this,e);</TD></TR><TR CLASS="z"><TD CLASS="l">4328</TD><TD>                }</TD></TR><TR><TD CLASS="l">4329</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4330</TD><TD>        return validMultiClassStrategy;</TD></TR><TR><TD CLASS="l">4331</TD><TD>        }</TD></TR><TR><TD CLASS="l">4332</TD><TD>        </TD></TR><TR><TD CLASS="l">4333</TD><TD>/**</TD></TR><TR><TD CLASS="l">4334</TD><TD> * Validates the legs of a strategy request to make sure that all of the legs are for</TD></TR><TR><TD CLASS="l">4335</TD><TD> * products selected for the strategy.</TD></TR><TR><TD CLASS="l">4336</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="c5">4337</A></TD><TD> * @exception DataValidationException if at least one leg is not valid.</TD></TR><TR><TD CLASS="l">4338</TD><TD> */</TD></TR><TR><TD CLASS="l">4339</TD><TD>private void validateStrategyLegs(String sessionName, StrategyRequestStruct strategyRequest)</TD></TR><TR><TD CLASS="l">4340</TD><TD>throws DataValidationException{</TD></TR><TR CLASS="z"><TD CLASS="l">4341</TD><TD>        TradingSession session = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4342</TD><TD>        boolean multiClassChecked = false; </TD></TR><TR><TD CLASS="l">4343</TD><TD>    try {</TD></TR><TR CLASS="z"><TD CLASS="l">4344</TD><TD>        session = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">4345</TD><TD>        // for buy/write, need to make sure we don't try and work with the equity product as it will not be</TD></TR><TR><TD CLASS="l">4346</TD><TD>        // considered 'in session'</TD></TR><TR><TD CLASS="l">4347</TD><TD>        // so need all product keys info for each leg to use later and determine productType</TD></TR><TR CLASS="z"><TD CLASS="l">4348</TD><TD>        ProductKeysStruct[] productKeys     = new ProductKeysStruct[ strategyRequest.strategyLegs.length ];</TD></TR><TR CLASS="z"><TD CLASS="l">4349</TD><TD>        SessionElementClass sessionClass    = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4350</TD><TD>        for ( int j = 0; j &lt; strategyRequest.strategyLegs.length; j++ )</TD></TR><TR><TD CLASS="l">4351</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4352</TD><TD>            productKeys[ j ] = getProductQueryService().getProductKeys(strategyRequest.strategyLegs[j].product);</TD></TR><TR CLASS="z"><TD CLASS="l">4353</TD><TD>            if (    ( productKeys[ j ].productType != ProductTypes.EQUITY )</TD></TR><TR><TD CLASS="l">4354</TD><TD>                &amp;&amp;  ( productKeys[ j ].productType != ProductTypes.INDEX )</TD></TR><TR><TD CLASS="l">4355</TD><TD>                &amp;&amp;  ( sessionClass == null )</TD></TR><TR><TD CLASS="l">4356</TD><TD>                )</TD></TR><TR><TD CLASS="l">4357</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4358</TD><TD>                sessionClass = session.findClassByKey(productKeys[ j ].classKey);</TD></TR><TR><TD CLASS="l">4359</TD><TD>            }</TD></TR><TR><TD CLASS="l">4360</TD><TD>        }</TD></TR><TR><TD CLASS="l">4361</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4362</TD><TD>        for (int i = 0; !multiClassChecked &amp;&amp; (i &lt; strategyRequest.strategyLegs.length); i++) {</TD></TR><TR><TD CLASS="l">4363</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">4364</TD><TD>                if ( (productKeys[ i ].productType != ProductTypes.EQUITY) &amp;&amp;</TD></TR><TR><TD CLASS="l">4365</TD><TD>                     (productKeys[ i ].productType != ProductTypes.INDEX) )</TD></TR><TR><TD CLASS="l">4366</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4367</TD><TD>                    sessionClass.findProduct(strategyRequest.strategyLegs[i].product);</TD></TR><TR><TD CLASS="l">4368</TD><TD>                }</TD></TR><TR><TD CLASS="l">4369</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4370</TD><TD>            catch (NotFoundException nfe) </TD></TR><TR><TD CLASS="l">4371</TD><TD>            {</TD></TR><TR><TD CLASS="l">4372</TD><TD>                    // existing strategy creation failed.</TD></TR><TR><TD CLASS="l">4373</TD><TD>                    // check if this is a multiclass strategy</TD></TR><TR CLASS="z"><TD CLASS="l">4374</TD><TD>                    if (!isMultiClassStrategyLegs(session, strategyRequest))</TD></TR><TR><TD CLASS="l">4375</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">4376</TD><TD>                            throw ExceptionBuilder.dataValidationException(&#34;Invalid leg for session, product key = &#34; + strategyRequest.strategyLegs[i].product, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4377</TD><TD>                            }</TD></TR><TR CLASS="z"><TD CLASS="l">4378</TD><TD>                    multiClassChecked = true;</TD></TR><TR CLASS="z"><TD CLASS="l">4379</TD><TD>            }</TD></TR><TR><TD CLASS="l">4380</TD><TD>        }</TD></TR><TR><TD CLASS="l">4381</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4382</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4383</TD><TD>        throw new DataValidationException(e.details);</TD></TR><TR><TD CLASS="l">4384</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4385</TD><TD>    catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4386</TD><TD>        Log.exception(&#34;TradingSessionService&gt;&gt;validateStrategyLegs. Failed to validate strategy legs&#34;,e);</TD></TR><TR CLASS="z"><TD CLASS="l">4387</TD><TD>        throw ExceptionBuilder.dataValidationException(e.getMessage(), 0);</TD></TR><TR CLASS="z"><TD CLASS="l">4388</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4389</TD><TD>}</TD></TR><TR><TD CLASS="l">4390</TD><TD>        </TD></TR><TR><TD CLASS="l">4391</TD><TD>/**</TD></TR><TR><TD CLASS="l">4392</TD><TD> * Verify that the given sessionKey is a valid session.</TD></TR><TR><TD CLASS="l">4393</TD><TD> *</TD></TR><TR><TD CLASS="l">4394</TD><TD> * @param sessionKey int the session we are looking for.</TD></TR><TR><TD CLASS="l">4395</TD><TD> * @exception DataValidationException if the session is not found.</TD></TR><TR><TD CLASS="l">4396</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="c7">4397</A></TD><TD>protected TradingSession verifySessionName(String sessionName) throws DataValidationException</TD></TR><TR><TD CLASS="l">4398</TD><TD>{</TD></TR><TR><TD CLASS="l">4399</TD><TD>    try</TD></TR><TR><TD CLASS="l">4400</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4401</TD><TD>            TradingSession session = sessionHome.find(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4402</TD><TD>        return session;</TD></TR><TR><TD CLASS="l">4403</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4404</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">4405</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4406</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Session (&#34; + sessionName + &#34;) not found.&#34;, com.cboe.idl.cmiErrorCodes.DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">4407</TD><TD>        }</TD></TR><TR><TD CLASS="l">4408</TD><TD>}</TD></TR><TR><TD CLASS="l">4409</TD><TD> </TD></TR><TR><TD CLASS="l">4410</TD><TD>/**</TD></TR><TR><TD CLASS="l">4411</TD><TD> * Verify that the given template name if valid.</TD></TR><TR><TD CLASS="l">4412</TD><TD> *</TD></TR><TR><TD CLASS="l">4413</TD><TD> * @param templateName name of template</TD></TR><TR><TD CLASS="l">4414</TD><TD> * @exception DataValidationException if the template is not found.</TD></TR><TR><TD CLASS="l">4415</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="c8">4416</A></TD><TD>private TradingSessionElementTemplate verifyTemplateName(String templateName) throws DataValidationException</TD></TR><TR><TD CLASS="l">4417</TD><TD>{</TD></TR><TR><TD CLASS="l">4418</TD><TD>    try</TD></TR><TR><TD CLASS="l">4419</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4420</TD><TD>            TradingSessionElementTemplate template = templateHome.findByName(templateName);</TD></TR><TR CLASS="z"><TD CLASS="l">4421</TD><TD>        return template;</TD></TR><TR><TD CLASS="l">4422</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4423</TD><TD>        catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">4424</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4425</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Template (&#34; + templateName + &#34;) not found.&#34;, com.cboe.idl.cmiErrorCodes.DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">4426</TD><TD>        }</TD></TR><TR><TD CLASS="l">4427</TD><TD>}</TD></TR><TR><TD CLASS="l">4428</TD><TD> </TD></TR><TR><TD CLASS="l">4429</TD><TD>/**</TD></TR><TR><TD CLASS="l">4430</TD><TD> *  This method is not an IDL method implementation.  Called by the strategy impls.</TD></TR><TR><TD CLASS="l">4431</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="2d">4432</A></TD><TD>public boolean getAbortEndOfSession(String sessionName)</TD></TR><TR><TD CLASS="l">4433</TD><TD>{</TD></TR><TR><TD CLASS="l">4434</TD><TD>    try</TD></TR><TR><TD CLASS="l">4435</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4436</TD><TD>            TradingSession session = sessionHome.find(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4437</TD><TD>            return session.abortEndOfSession();</TD></TR><TR><TD CLASS="l">4438</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4439</TD><TD>    catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4440</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">4441</TD><TD>    }</TD></TR><TR><TD CLASS="l">4442</TD><TD>}</TD></TR><TR><TD CLASS="l">4443</TD><TD> </TD></TR><TR><TD CLASS="l">4444</TD><TD>/**</TD></TR><TR><TD CLASS="l">4445</TD><TD> *  Abort end-of-session processing at the next opportunity.</TD></TR><TR><TD CLASS="l"><A NAME="3">4446</A></TD><TD> */</TD></TR><TR><TD CLASS="l">4447</TD><TD>public void abortEndOfSession(String sessionName)</TD></TR><TR><TD CLASS="l">4448</TD><TD>        throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">4449</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">4450</TD><TD>    boolean success = false;</TD></TR><TR><TD CLASS="l">4451</TD><TD>    try</TD></TR><TR><TD CLASS="l">4452</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4453</TD><TD>        Transaction.startTransaction();</TD></TR><TR><TD CLASS="l">4454</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4455</TD><TD>            TradingSession session = sessionHome.find(sessionName);</TD></TR><TR><TD CLASS="l">4456</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4457</TD><TD>        session.setAbortEndOfSession(true);</TD></TR><TR CLASS="z"><TD CLASS="l">4458</TD><TD>        success = Transaction.commit();</TD></TR><TR CLASS="z"><TD CLASS="l">4459</TD><TD>        if (!success)</TD></TR><TR><TD CLASS="l">4460</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4461</TD><TD>            throw ExceptionBuilder.transactionFailedException(&#34;failed to update session for abort end of session.&#34;, 0);</TD></TR><TR><TD CLASS="l">4462</TD><TD>        }</TD></TR><TR><TD CLASS="l">4463</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4464</TD><TD>    catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">4465</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4466</TD><TD>                throw ExceptionBuilder.dataValidationException(&#34;Session (&#34; + sessionName + &#34;) not found.&#34;, com.cboe.idl.cmiErrorCodes.DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">4467</TD><TD>        }</TD></TR><TR><TD CLASS="l">4468</TD><TD>    finally</TD></TR><TR><TD CLASS="l">4469</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4470</TD><TD>        if (!success)</TD></TR><TR><TD CLASS="l">4471</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4472</TD><TD>            Log.alarm(this, &#34;Rolling back transaction due to error updating trading session for abort EOS&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4473</TD><TD>            Transaction.rollback();</TD></TR><TR><TD CLASS="l">4474</TD><TD>        }</TD></TR><TR><TD CLASS="l">4475</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4476</TD><TD>}</TD></TR><TR><TD CLASS="l">4477</TD><TD> </TD></TR><TR><TD CLASS="l">4478</TD><TD>/**</TD></TR><TR><TD CLASS="l">4479</TD><TD> *  get the event history</TD></TR><TR><TD CLASS="l"><A NAME="4f">4480</A></TD><TD> */</TD></TR><TR><TD CLASS="l">4481</TD><TD>public TradingSessionEventHistoryStruct[] getEventHistory(String sessionName)</TD></TR><TR><TD CLASS="l">4482</TD><TD>    throws SystemException, DataValidationException</TD></TR><TR><TD CLASS="l">4483</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">4484</TD><TD>        verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">4485</TD><TD>    Collection entries;</TD></TR><TR><TD CLASS="l">4486</TD><TD>    try</TD></TR><TR><TD CLASS="l">4487</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4488</TD><TD>        entries = getEventHistoryHome().findBySession(sessionName);</TD></TR><TR><TD CLASS="l">4489</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4490</TD><TD>        catch (TransactionFailedException ex)</TD></TR><TR><TD CLASS="l">4491</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4492</TD><TD>        String err = &#34;Persistence error querying for history: &#34; + ex;</TD></TR><TR CLASS="z"><TD CLASS="l">4493</TD><TD>        Log.exception(err, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">4494</TD><TD>        throw ExceptionBuilder.systemException(err, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">4495</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4496</TD><TD>    TradingSessionEventHistoryStruct[] result = new TradingSessionEventHistoryStruct[entries.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">4497</TD><TD>    Iterator iter = entries.iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">4498</TD><TD>    for (int i=0; iter.hasNext(); i++)</TD></TR><TR><TD CLASS="l">4499</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4500</TD><TD>        TradingSessionEventHistoryEntry entry = (TradingSessionEventHistoryEntry)iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">4501</TD><TD>        result[i] = getEventHistoryHome().convertToStruct(entry);</TD></TR><TR><TD CLASS="l">4502</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4503</TD><TD>    return result;</TD></TR><TR><TD CLASS="l">4504</TD><TD>}</TD></TR><TR><TD CLASS="l">4505</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="52">4506</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">4507</TD><TD> * Gets trading session struct to be user for events.</TD></TR><TR><TD CLASS="l">4508</TD><TD> */</TD></TR><TR><TD CLASS="l">4509</TD><TD>private TradingSessionStruct getEventTradingSesssion(String sessionName) throws DataValidationException {</TD></TR><TR CLASS="z"><TD CLASS="l">4510</TD><TD>    TradingSessionStruct sessionStruct = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4511</TD><TD>    if ( !TradingSessionNameHelper.isForAllSessions(sessionName)) {</TD></TR><TR><TD CLASS="l">4512</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">4513</TD><TD>            sessionStruct = getTradingSessionByName(sessionName);</TD></TR><TR><TD CLASS="l">4514</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4515</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4516</TD><TD>            Log.exception(&#34;Not found trading session by name &#34; + sessionName, e );</TD></TR><TR CLASS="z"><TD CLASS="l">4517</TD><TD>                    throw ExceptionBuilder.dataValidationException(&#34;Not found trading session by name &#34; + sessionName,0);</TD></TR><TR CLASS="z"><TD CLASS="l">4518</TD><TD>        }</TD></TR><TR><TD CLASS="l">4519</TD><TD>    }</TD></TR><TR><TD CLASS="l">4520</TD><TD>    else {</TD></TR><TR CLASS="z"><TD CLASS="l">4521</TD><TD>        sessionStruct = TradingSessionNameHelper.createAllSessionsStruct();</TD></TR><TR><TD CLASS="l">4522</TD><TD>    }</TD></TR><TR CLASS="z"><TD CLASS="l">4523</TD><TD>    return sessionStruct;</TD></TR><TR><TD CLASS="l">4524</TD><TD>}</TD></TR><TR><TD CLASS="l">4525</TD><TD> </TD></TR><TR><TD CLASS="l">4526</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4527</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="34">4528</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">4529</TD><TD>        public com.cboe.idl.cmiSession.SessionClassStruct getClassBySessionForKey( String sessionName, int classKey)</TD></TR><TR><TD CLASS="l">4530</TD><TD>        throws DataValidationException,NotFoundException</TD></TR><TR><TD CLASS="l">4531</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4532</TD><TD>        if (classKey == 0)</TD></TR><TR><TD CLASS="l">4533</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4534</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Class key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4535</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4536</TD><TD>        TradingSession session = verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4537</TD><TD>        SessionElementClass sessionClass = session.findClassByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4538</TD><TD>        SessionClassStruct classStruct = elementClassHome.toSessionClassStruct(sessionClass);</TD></TR><TR CLASS="z"><TD CLASS="l">4539</TD><TD>                return classStruct;</TD></TR><TR><TD CLASS="l">4540</TD><TD>        }</TD></TR><TR><TD CLASS="l">4541</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="35">4542</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">4543</TD><TD>        public com.cboe.idl.cmiSession.SessionClassStruct getClassBySessionForSymbol( String sessionName, short productType, String className)</TD></TR><TR><TD CLASS="l">4544</TD><TD>        throws SystemException, CommunicationException, AuthorizationException, DataValidationException,NotFoundException</TD></TR><TR><TD CLASS="l">4545</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4546</TD><TD>        String classSymbols[] = { className };</TD></TR><TR CLASS="z"><TD CLASS="l">4547</TD><TD>        ProductClassStruct classStruct = getProductQueryService().getProductClassesBySymbol(classSymbols, productType, false, false, false)[0];</TD></TR><TR CLASS="z"><TD CLASS="l">4548</TD><TD>        return getClassBySessionForKey(sessionName, classStruct.info.classKey);</TD></TR><TR><TD CLASS="l">4549</TD><TD>        }</TD></TR><TR><TD CLASS="l">4550</TD><TD> </TD></TR><TR><TD CLASS="l">4551</TD><TD>         /**</TD></TR><TR><TD CLASS="l"><A NAME="58">4552</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">4553</TD><TD>        public com.cboe.idl.cmiSession.SessionProductStruct getProductBySessionForKey(String sessionName, int productKey)</TD></TR><TR><TD CLASS="l">4554</TD><TD>        throws DataValidationException, NotFoundException</TD></TR><TR><TD CLASS="l">4555</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4556</TD><TD>        if (productKey == 0)</TD></TR><TR><TD CLASS="l">4557</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4558</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Product key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4559</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4560</TD><TD>         TradingSession session = verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4561</TD><TD>         SessionElementProduct product = session.findProductByKey(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4562</TD><TD>         return product.toSessionProductStruct();</TD></TR><TR><TD CLASS="l">4563</TD><TD>        }</TD></TR><TR><TD CLASS="l">4564</TD><TD> </TD></TR><TR><TD CLASS="l">4565</TD><TD>       /** Gets all products by session+class</TD></TR><TR><TD CLASS="l">4566</TD><TD>        *</TD></TR><TR><TD CLASS="l">4567</TD><TD>        *  @param String sessionName</TD></TR><TR><TD CLASS="l">4568</TD><TD>        *  @param int classKey</TD></TR><TR><TD CLASS="l">4569</TD><TD>        *  @return  com.cboe.idl.cmiSession.SessionProductStruct[]</TD></TR><TR><TD CLASS="l">4570</TD><TD>        *  all the products of the class in the session</TD></TR><TR><TD CLASS="l"><A NAME="62">4571</A></TD><TD>        */</TD></TR><TR><TD CLASS="l">4572</TD><TD>        public SessionProductStruct[] getProductsBySessionForClass(String sessionName, int classKey)</TD></TR><TR><TD CLASS="l">4573</TD><TD>        throws DataValidationException</TD></TR><TR><TD CLASS="l">4574</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4575</TD><TD>        if (classKey == 0)</TD></TR><TR><TD CLASS="l">4576</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4577</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Class key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4578</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4579</TD><TD>          verifySessionName(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4580</TD><TD>          TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4581</TD><TD>          SessionElementClass sessionElementClass = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4582</TD><TD>          for (int i = 0; i&lt;elements.length; i++)</TD></TR><TR><TD CLASS="l">4583</TD><TD>          {</TD></TR><TR CLASS="z"><TD CLASS="l">4584</TD><TD>            sessionElementClass = elements[i].getClassByKey(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4585</TD><TD>            if (null != sessionElementClass )</TD></TR><TR><TD CLASS="l">4586</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4587</TD><TD>                SessionClassDetailStruct  sessionClassDetail = elementClassHome.toStruct(sessionElementClass);</TD></TR><TR CLASS="z"><TD CLASS="l">4588</TD><TD>                return sessionClassDetail.products;</TD></TR><TR><TD CLASS="l">4589</TD><TD>            }</TD></TR><TR><TD CLASS="l">4590</TD><TD>          }</TD></TR><TR CLASS="z"><TD CLASS="l">4591</TD><TD>          return new SessionProductStruct[0];</TD></TR><TR><TD CLASS="l">4592</TD><TD>          // Log.information(this, &#34; Not found SessionProducts, getProductsBySessionForClass(sessionName, classKey) (&#34; + sessionName + &#34;, &#34; + calssKey + &#34;)&#34; );</TD></TR><TR><TD CLASS="l">4593</TD><TD>          // throw ExceptionBuilder.dataValidationException(&#34; Not found SessionProducts, getProductsBySessionForClass(sessionName, classKey) (&#34; + sessionName + &#34;, &#34; + calssKey + &#34;)&#34;, 0);</TD></TR><TR><TD CLASS="l">4594</TD><TD> </TD></TR><TR><TD CLASS="l">4595</TD><TD> </TD></TR><TR><TD CLASS="l">4596</TD><TD>        }</TD></TR><TR><TD CLASS="l">4597</TD><TD> </TD></TR><TR><TD CLASS="l">4598</TD><TD>       /** Gets all Strategies by session+class</TD></TR><TR><TD CLASS="l">4599</TD><TD>        *</TD></TR><TR><TD CLASS="l">4600</TD><TD>        *   @param String sessionName</TD></TR><TR><TD CLASS="l">4601</TD><TD>        *   @param int classKey</TD></TR><TR><TD CLASS="l">4602</TD><TD>        *   @return  com.cboe.idl.cmiSession.SessionStrategyStruct[]</TD></TR><TR><TD CLASS="l">4603</TD><TD>        *   all the Strategies of the class in the session</TD></TR><TR><TD CLASS="l"><A NAME="69">4604</A></TD><TD>        */</TD></TR><TR><TD CLASS="l">4605</TD><TD>        public SessionStrategyStruct[] getStrategiesBySessionForClass(String sessionName, int classKey)</TD></TR><TR><TD CLASS="l">4606</TD><TD>        throws DataValidationException</TD></TR><TR><TD CLASS="l">4607</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4608</TD><TD>        if (classKey == 0)</TD></TR><TR><TD CLASS="l">4609</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4610</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Class key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4611</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4612</TD><TD>            SessionProductStruct[] products = getProductsBySessionForClass(sessionName,classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4613</TD><TD>            ArrayList strategies = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">4614</TD><TD>            for (int i = 0; i &lt; products.length; i++) {</TD></TR><TR><TD CLASS="l">4615</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">4616</TD><TD>                    SessionStrategyStruct sessionStrategy =</TD></TR><TR><TD CLASS="l">4617</TD><TD>                        buildSessionStrategyStruct(products[i],sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4618</TD><TD>                    strategies.add(sessionStrategy);</TD></TR><TR><TD CLASS="l">4619</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4620</TD><TD>                catch (DataValidationException e)</TD></TR><TR><TD CLASS="l">4621</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4622</TD><TD>                    System.out.println( new Date() + &#34;Not found Strategy with productKey: &#34; + products[i].productStruct.productKeys.productKey + &#34; classKey: &#34; + products[i].productStruct.productKeys.classKey + &#34; productType: &#34; + products[i].productStruct.productKeys.productType + &#34; in ProductQueryService : &#34; + e.details.message);</TD></TR><TR><TD CLASS="l">4623</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4624</TD><TD>                catch (Exception e)</TD></TR><TR><TD CLASS="l">4625</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4626</TD><TD>                     Log.exception(this, &#34;Not found Strategy with productKey: &#34; + products[i].productStruct.productKeys.productKey + &#34; classKey: &#34; + products[i].productStruct.productKeys.classKey + &#34; productType: &#34; + products[i].productStruct.productKeys.productType + &#34; in ProductQueryService&#34;, e);</TD></TR><TR CLASS="z"><TD CLASS="l">4627</TD><TD>                }</TD></TR><TR><TD CLASS="l">4628</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4629</TD><TD>            SessionStrategyStruct[] result = new SessionStrategyStruct[strategies.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">4630</TD><TD>            strategies.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">4631</TD><TD>            return result;</TD></TR><TR><TD CLASS="l">4632</TD><TD>        }</TD></TR><TR><TD CLASS="l">4633</TD><TD> </TD></TR><TR><TD CLASS="l">4634</TD><TD>        /**</TD></TR><TR><TD CLASS="l">4635</TD><TD>         */</TD></TR><TR><TD CLASS="l">4636</TD><TD>        public com.cboe.idl.cmiSession.SessionProductStruct getProductBySessionForName( String sessionName, ProductNameStruct productNameStruct)</TD></TR><TR><TD CLASS="l"><A NAME="59">4637</A></TD><TD>        throws DataValidationException, NotFoundException</TD></TR><TR><TD CLASS="l">4638</TD><TD>        {</TD></TR><TR><TD CLASS="l">4639</TD><TD>        ProductStruct productStruct;</TD></TR><TR><TD CLASS="l">4640</TD><TD>        int productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">4641</TD><TD>        SessionProductStruct sessionProduct = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4642</TD><TD>        ProductNameStruct [] pnStructs = new ProductNameStruct[1];</TD></TR><TR CLASS="z"><TD CLASS="l">4643</TD><TD>        pnStructs[0] = productNameStruct;</TD></TR><TR><TD CLASS="l">4644</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">4645</TD><TD>            productStruct = getProductQueryService().getProductsByName(pnStructs)[0];</TD></TR><TR CLASS="z"><TD CLASS="l">4646</TD><TD>            productKey = productStruct.productKeys.productKey;</TD></TR><TR><TD CLASS="l">4647</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4648</TD><TD>        catch (Exception e ) {</TD></TR><TR CLASS="z"><TD CLASS="l">4649</TD><TD>            if(Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">4650</TD><TD>                                Log.debug(&#34;Exception in getProductBySessionForName &#34; + e);</TD></TR><TR><TD CLASS="l">4651</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4652</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Not found product &#34; + productNameStruct.productSymbol + &#34; in session &#34; + sessionName, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">4653</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4654</TD><TD>        sessionProduct = getProductBySessionForKey(sessionName, productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4655</TD><TD>                return sessionProduct;</TD></TR><TR><TD CLASS="l">4656</TD><TD>    }</TD></TR><TR><TD CLASS="l">4657</TD><TD> </TD></TR><TR><TD CLASS="l">4658</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6b">4659</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">4660</TD><TD>        public com.cboe.idl.cmiSession.SessionStrategyStruct getStrategyBySessionForKey( String sessionName, int productKey)</TD></TR><TR><TD CLASS="l">4661</TD><TD>        throws DataValidationException,NotFoundException</TD></TR><TR><TD CLASS="l">4662</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4663</TD><TD>        if (productKey == 0)</TD></TR><TR><TD CLASS="l">4664</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4665</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Product key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4666</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4667</TD><TD>        SessionProductStruct product = getProductBySessionForKey(sessionName, productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4668</TD><TD>        SessionStrategyStruct strategy = null;</TD></TR><TR><TD CLASS="l">4669</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">4670</TD><TD>            strategy = buildSessionStrategyStruct(product,sessionName);</TD></TR><TR><TD CLASS="l">4671</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4672</TD><TD>        catch ( Exception e ) {</TD></TR><TR CLASS="z"><TD CLASS="l">4673</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Not found strategy &#34; + productKey + &#34; in session &#34; + sessionName, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">4674</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4675</TD><TD>        if ( strategy == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4676</TD><TD>            throw ExceptionBuilder.notFoundException(&#34;Not found strategy &#34; + productKey + &#34; in session &#34; + sessionName, 0);</TD></TR><TR><TD CLASS="l">4677</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4678</TD><TD>                return strategy;</TD></TR><TR><TD CLASS="l">4679</TD><TD>        }</TD></TR><TR><TD CLASS="l">4680</TD><TD>/**</TD></TR><TR><TD CLASS="l">4681</TD><TD> * getStrategiesByComponent  -  gets SessionStrategyStructs by component for a session</TD></TR><TR><TD CLASS="l">4682</TD><TD> *</TD></TR><TR><TD CLASS="l">4683</TD><TD> * @param productKey</TD></TR><TR><TD CLASS="l">4684</TD><TD> * @param sessionName</TD></TR><TR><TD CLASS="l">4685</TD><TD> *</TD></TR><TR><TD CLASS="l">4686</TD><TD> * @return SessionStrategyStruct[]</TD></TR><TR><TD CLASS="l"><A NAME="68">4687</A></TD><TD> */</TD></TR><TR><TD CLASS="l">4688</TD><TD>    public SessionStrategyStruct[] getStrategiesByComponent(int productKey, String sessionName)</TD></TR><TR><TD CLASS="l">4689</TD><TD>           throws SystemException, DataValidationException, AuthorizationException, CommunicationException</TD></TR><TR><TD CLASS="l">4690</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4691</TD><TD>        if (productKey == 0)</TD></TR><TR><TD CLASS="l">4692</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4693</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Product key 0 is invalid&#34;, DataValidationCodes.INVALID_PRODUCT);</TD></TR><TR><TD CLASS="l">4694</TD><TD>        }</TD></TR><TR><TD CLASS="l">4695</TD><TD>        // Ask PQS for strategies by component</TD></TR><TR CLASS="z"><TD CLASS="l">4696</TD><TD>        StrategyStruct[] strategies = getProductQueryService().getStrategiesByComponent(productKey);</TD></TR><TR><TD CLASS="l">4697</TD><TD> </TD></TR><TR><TD CLASS="l">4698</TD><TD>        // Get the trading session</TD></TR><TR CLASS="z"><TD CLASS="l">4699</TD><TD>        TradingSession tradingSession = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">4700</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4701</TD><TD>        ArrayList sessionStrategies = new ArrayList();</TD></TR><TR><TD CLASS="l">4702</TD><TD>        try</TD></TR><TR><TD CLASS="l">4703</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4704</TD><TD>            for(int i = 0; i &lt; strategies.length; i++)</TD></TR><TR><TD CLASS="l">4705</TD><TD>            {</TD></TR><TR><TD CLASS="l">4706</TD><TD>                // For each strategy, see if the trading session has that product</TD></TR><TR><TD CLASS="l">4707</TD><TD>                // and if it does not, the product does not exist in the session.</TD></TR><TR CLASS="z"><TD CLASS="l">4708</TD><TD>                if(null != tradingSession.getProductByKey(</TD></TR><TR><TD CLASS="l">4709</TD><TD>                    strategies[i].product.productKeys.productKey))</TD></TR><TR><TD CLASS="l">4710</TD><TD>                {</TD></TR><TR><TD CLASS="l">4711</TD><TD>                    // This strategy exists in this session</TD></TR><TR CLASS="z"><TD CLASS="l">4712</TD><TD>                    SessionStrategyStruct strategy = buildSessionStrategyStruct(strategies[i], sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4713</TD><TD>                    sessionStrategies.add(strategy);</TD></TR><TR><TD CLASS="l">4714</TD><TD>                }</TD></TR><TR><TD CLASS="l">4715</TD><TD>            }</TD></TR><TR><TD CLASS="l">4716</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4717</TD><TD>        catch(Exception e)</TD></TR><TR><TD CLASS="l">4718</TD><TD>        {</TD></TR><TR><TD CLASS="l">4719</TD><TD>            // Any exceptions would be coming from buildSessionStrategyStruct(),</TD></TR><TR><TD CLASS="l">4720</TD><TD>            // which is only being called if the product exists in the session.</TD></TR><TR><TD CLASS="l">4721</TD><TD>            // If any exceptions are caught, then this becomes a SystemException.</TD></TR><TR CLASS="z"><TD CLASS="l">4722</TD><TD>            throw ExceptionBuilder.systemException(&#34;Error getting SessionStrategyStruct for strategy in session.&#34;, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">4723</TD><TD>        }</TD></TR><TR><TD CLASS="l">4724</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4725</TD><TD>        SessionStrategyStruct[] result = new SessionStrategyStruct[sessionStrategies.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">4726</TD><TD>        sessionStrategies.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">4727</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">4728</TD><TD>   }</TD></TR><TR><TD CLASS="l">4729</TD><TD> </TD></TR><TR><TD CLASS="l">4730</TD><TD>/**</TD></TR><TR><TD CLASS="l">4731</TD><TD> * Automatically sends product state change requests for configured sessions when the</TD></TR><TR><TD CLASS="l">4732</TD><TD> * corresponding underlying product changes state.</TD></TR><TR><TD CLASS="l">4733</TD><TD> *</TD></TR><TR><TD CLASS="l">4734</TD><TD> * CASE 1</TD></TR><TR><TD CLASS="l">4735</TD><TD> * If the underlying goes into open state and the derived products state is in pre-open then</TD></TR><TR><TD CLASS="l">4736</TD><TD> * change the derived products state to opening rotation.</TD></TR><TR><TD CLASS="l">4737</TD><TD> *</TD></TR><TR><TD CLASS="l">4738</TD><TD> * CASE 2</TD></TR><TR><TD CLASS="l">4739</TD><TD> * If the underlying goes into halt state change the derived products state to trading halt.</TD></TR><TR><TD CLASS="l">4740</TD><TD> *</TD></TR><TR><TD CLASS="l">4741</TD><TD> * @param int underlying class key</TD></TR><TR><TD CLASS="l">4742</TD><TD> * @param String underlying session name</TD></TR><TR><TD CLASS="l">4743</TD><TD> * @param ProductStateStruct[] new States</TD></TR><TR><TD CLASS="l">4744</TD><TD> *</TD></TR><TR><TD CLASS="l">4745</TD><TD> */</TD></TR><TR><TD CLASS="l">4746</TD><TD>    public void acceptUnderlyingProductStateChange(int underlyingClassKey, String sessionName, ProductStateStruct[] newStates)</TD></TR><TR><TD CLASS="l"><A NAME="6">4747</A></TD><TD>    {</TD></TR><TR><TD CLASS="l">4748</TD><TD> </TD></TR><TR><TD CLASS="l">4749</TD><TD>        // Since one underlying class will have only one product in it.</TD></TR><TR><TD CLASS="l">4750</TD><TD>        // We can just pick the product key from the ProductStateStruct[0] element.</TD></TR><TR CLASS="z"><TD CLASS="l">4751</TD><TD>        ProductStateStruct underlyingProductState = newStates[0];</TD></TR><TR CLASS="z"><TD CLASS="l">4752</TD><TD>        if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">4753</TD><TD>           Log.debug(this,&#34;Underlying state change received for class/session/State: &#34; + underlyingClassKey + &#34;/&#34; + sessionName + &#34;/&#34; + underlyingProductState.productState);</TD></TR><TR><TD CLASS="l">4754</TD><TD>        }</TD></TR><TR><TD CLASS="l">4755</TD><TD> </TD></TR><TR><TD CLASS="l">4756</TD><TD>        // Ignore product state change requests that are not open or halt states.</TD></TR><TR CLASS="z"><TD CLASS="l">4757</TD><TD>        if (underlyingProductState.productState != ProductStates.OPEN &amp;&amp; underlyingProductState.productState != ProductStates.HALTED) {</TD></TR><TR CLASS="z"><TD CLASS="l">4758</TD><TD>            if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">4759</TD><TD>                Log.debug(this,&#34;Process Underlying state change : Derivative products will not change state as underlying is not halted or in open state for class/session/state: &#34; + underlyingClassKey + &#34;/&#34; + sessionName + &#34;/&#34; + underlyingProductState.productState);</TD></TR><TR><TD CLASS="l">4760</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4761</TD><TD>            return;</TD></TR><TR><TD CLASS="l">4762</TD><TD>        }</TD></TR><TR><TD CLASS="l">4763</TD><TD> </TD></TR><TR><TD CLASS="l">4764</TD><TD>        // Get all derivative products that are affected by this underlying product.</TD></TR><TR><TD CLASS="l">4765</TD><TD>        List derivativeClassStructs;</TD></TR><TR CLASS="z"><TD CLASS="l">4766</TD><TD>        if (this.derivativesByUnderlying == null)</TD></TR><TR><TD CLASS="l">4767</TD><TD>        {</TD></TR><TR><TD CLASS="l">4768</TD><TD>            // If we failed to init the map for some reason, then get the data the old&amp;slow way:</TD></TR><TR><TD CLASS="l">4769</TD><TD>            //</TD></TR><TR><TD CLASS="l">4770</TD><TD>            try</TD></TR><TR><TD CLASS="l">4771</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4772</TD><TD>                ProductClassStruct[] prodClasses = getProductQueryService().getDerivativesForProduct(underlyingProductState.productKeys.productKey, true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">4773</TD><TD>                derivativeClassStructs = new ArrayList(prodClasses.length);</TD></TR><TR CLASS="z"><TD CLASS="l">4774</TD><TD>                for (int i = 0; i &lt; prodClasses.length; i++)</TD></TR><TR><TD CLASS="l">4775</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">4776</TD><TD>                    derivativeClassStructs.add(prodClasses[i].info);</TD></TR><TR><TD CLASS="l">4777</TD><TD>                }</TD></TR><TR><TD CLASS="l">4778</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4779</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">4780</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4781</TD><TD>                Log.exception(this,&#34;Error getting derivatives for underlyng product (in processing underlying state change) for underlying class/underlying product/session/State: &#34; + underlyingClassKey + &#34;/&#34; + underlyingProductState.productKeys.productKey + &#34;/&#34; + sessionName + &#34;/&#34; + underlyingProductState.productState + &#34;. Exception: &#34; + e,e);</TD></TR><TR CLASS="z"><TD CLASS="l">4782</TD><TD>                return;</TD></TR><TR CLASS="z"><TD CLASS="l">4783</TD><TD>            }</TD></TR><TR><TD CLASS="l">4784</TD><TD>        }</TD></TR><TR><TD CLASS="l">4785</TD><TD>        else</TD></TR><TR><TD CLASS="l">4786</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4787</TD><TD>            derivativeClassStructs = (List)this.derivativesByUnderlying.get(new Integer(underlyingProductState.productKeys.productKey));</TD></TR><TR CLASS="z"><TD CLASS="l">4788</TD><TD>            if (derivativeClassStructs == null)</TD></TR><TR><TD CLASS="l">4789</TD><TD>            {</TD></TR><TR><TD CLASS="l">4790</TD><TD>                // (This does happen in real life.)</TD></TR><TR><TD CLASS="l">4791</TD><TD>                //</TD></TR><TR CLASS="z"><TD CLASS="l">4792</TD><TD>                Log.information(this, &#34;Received state change for product that has no derivatives in any session: undly class/session/State: &#34; + underlyingClassKey + &#34;/&#34; + sessionName + &#34;/&#34; + underlyingProductState.productState);</TD></TR><TR CLASS="z"><TD CLASS="l">4793</TD><TD>                return;</TD></TR><TR><TD CLASS="l">4794</TD><TD>            }</TD></TR><TR><TD CLASS="l">4795</TD><TD>        }</TD></TR><TR><TD CLASS="l">4796</TD><TD> </TD></TR><TR><TD CLASS="l">4797</TD><TD>        // Walk through array of classes processing state change for the regular(outright) first</TD></TR><TR><TD CLASS="l">4798</TD><TD>        // and then the strategy class</TD></TR><TR><TD CLASS="l">4799</TD><TD>        //</TD></TR><TR CLASS="z"><TD CLASS="l">4800</TD><TD>        final int len = derivativeClassStructs.size();</TD></TR><TR CLASS="z"><TD CLASS="l">4801</TD><TD>        for (int i = 0; i &lt; len; i++)</TD></TR><TR><TD CLASS="l">4802</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4803</TD><TD>            final ClassStruct classStruct = (ClassStruct)derivativeClassStructs.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">4804</TD><TD>            if (classStruct.productType != ProductTypes.STRATEGY)</TD></TR><TR><TD CLASS="l">4805</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4806</TD><TD>               if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">4807</TD><TD>               {</TD></TR><TR CLASS="z"><TD CLASS="l">4808</TD><TD>                   Log.debug(this,&#34;NonStrategy Class = &#34; + classStruct.classKey);</TD></TR><TR><TD CLASS="l">4809</TD><TD>               }</TD></TR><TR CLASS="z"><TD CLASS="l">4810</TD><TD>               processStateChangeForDerivative(classStruct,underlyingProductState,sessionName);</TD></TR><TR><TD CLASS="l">4811</TD><TD>            }</TD></TR><TR><TD CLASS="l">4812</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4813</TD><TD>        for (int i = 0; i &lt; len; i++)</TD></TR><TR><TD CLASS="l">4814</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4815</TD><TD>            final ClassStruct classStruct = (ClassStruct)derivativeClassStructs.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">4816</TD><TD>            if (classStruct.productType == ProductTypes.STRATEGY)</TD></TR><TR><TD CLASS="l">4817</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4818</TD><TD>                 if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">4819</TD><TD>                 {</TD></TR><TR CLASS="z"><TD CLASS="l">4820</TD><TD>                     Log.debug(this,&#34;Strategy Class =&#34; + classStruct.classKey );</TD></TR><TR><TD CLASS="l">4821</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">4822</TD><TD>               processStateChangeForDerivative(classStruct,underlyingProductState,sessionName);</TD></TR><TR><TD CLASS="l">4823</TD><TD>            }</TD></TR><TR><TD CLASS="l">4824</TD><TD>        }</TD></TR><TR><TD CLASS="l">4825</TD><TD>        </TD></TR><TR><TD CLASS="l">4826</TD><TD>        // now process if message is to halt on stock sessions</TD></TR><TR CLASS="z"><TD CLASS="l">4827</TD><TD>        if(underlyingProductState.productState == ProductStates.HALTED &amp;&amp; this.underlyingStateHaltTriggeredSTOCKSessions.length &gt; 0 )</TD></TR><TR><TD CLASS="l">4828</TD><TD>        {   </TD></TR><TR><TD CLASS="l">4829</TD><TD>            try</TD></TR><TR><TD CLASS="l">4830</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4831</TD><TD>                ProductClassStruct prodClass = getProductQueryService().getProductClassByKey(underlyingProductState.productKeys.classKey, false, false, true);      </TD></TR><TR CLASS="z"><TD CLASS="l">4832</TD><TD>                processStateChangeForDerivative(prodClass.info,underlyingProductState,sessionName);</TD></TR><TR><TD CLASS="l">4833</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4834</TD><TD>            catch (Exception e)</TD></TR><TR><TD CLASS="l">4835</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4836</TD><TD>                Log.exception(this,&#34;Error getting getProductClassesByKey for underlyng product (in processing underlying state change) for underlying class/underlying product/session/State: &#34; + underlyingClassKey + &#34;/&#34; + underlyingProductState.productKeys.productKey + &#34;/&#34; + sessionName + &#34;/&#34; + underlyingProductState.productState + &#34;. Exception: &#34; + e,e);</TD></TR><TR CLASS="z"><TD CLASS="l">4837</TD><TD>                return;</TD></TR><TR CLASS="z"><TD CLASS="l">4838</TD><TD>            }</TD></TR><TR><TD CLASS="l">4839</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4840</TD><TD>    }</TD></TR><TR><TD CLASS="l">4841</TD><TD> </TD></TR><TR><TD CLASS="l">4842</TD><TD>/**</TD></TR><TR><TD CLASS="l">4843</TD><TD> * For each of these classes find all sessions the class is part of and then</TD></TR><TR><TD CLASS="l">4844</TD><TD> * for all the sessions that are configured to trigger automatically on underlying</TD></TR><TR><TD CLASS="l">4845</TD><TD> * state change send a request to PSS to do so.</TD></TR><TR><TD CLASS="l">4846</TD><TD> * If anything fails in the process log errors and go on.</TD></TR><TR><TD CLASS="l">4847</TD><TD> */</TD></TR><TR><TD CLASS="l"><A NAME="92">4848</A></TD><TD>    private void processStateChangeForDerivative(ClassStruct derivativeClass, ProductStateStruct underlyingProductState, String underlyingSession)</TD></TR><TR><TD CLASS="l">4849</TD><TD>    {</TD></TR><TR><TD CLASS="l">4850</TD><TD>        // Get all sessions this derivative class is part of:</TD></TR><TR><TD CLASS="l">4851</TD><TD>        List sessionNames;</TD></TR><TR CLASS="z"><TD CLASS="l">4852</TD><TD>        if (this.sessionsByClass == null)</TD></TR><TR><TD CLASS="l">4853</TD><TD>        {</TD></TR><TR><TD CLASS="l">4854</TD><TD>            // If we failed to initialize the cached maps for some reason,</TD></TR><TR><TD CLASS="l">4855</TD><TD>            // then get the info the old&amp;slow way.</TD></TR><TR><TD CLASS="l">4856</TD><TD>            //</TD></TR><TR><TD CLASS="l">4857</TD><TD>            TradingSessionStruct[] sessions;</TD></TR><TR><TD CLASS="l">4858</TD><TD>            try</TD></TR><TR><TD CLASS="l">4859</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4860</TD><TD>                sessions = getTradingSessionsForClass(derivativeClass.classKey);</TD></TR><TR><TD CLASS="l">4861</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4862</TD><TD>            catch (DataValidationException ex)</TD></TR><TR><TD CLASS="l">4863</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4864</TD><TD>                Log.exception(this, &#34;Derivative class key was invalid! State change not processed.&#34;, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">4865</TD><TD>                return;</TD></TR><TR CLASS="z"><TD CLASS="l">4866</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4867</TD><TD>            sessionNames = new ArrayList(sessions.length);</TD></TR><TR CLASS="z"><TD CLASS="l">4868</TD><TD>            for (int i = 0; i &lt; sessions.length; i++)</TD></TR><TR><TD CLASS="l">4869</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4870</TD><TD>                sessionNames.add(sessions[i].sessionName);</TD></TR><TR><TD CLASS="l">4871</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4872</TD><TD>        }</TD></TR><TR><TD CLASS="l">4873</TD><TD>        else</TD></TR><TR><TD CLASS="l">4874</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4875</TD><TD>            sessionNames = (List)this.sessionsByClass.get(new Integer(derivativeClass.classKey));</TD></TR><TR CLASS="z"><TD CLASS="l">4876</TD><TD>            if (sessionNames == null)</TD></TR><TR><TD CLASS="l">4877</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">4878</TD><TD>                Log.information(this, &#34;No sessions found for class &#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol + &#34;)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4879</TD><TD>                return;</TD></TR><TR><TD CLASS="l">4880</TD><TD>            }</TD></TR><TR><TD CLASS="l">4881</TD><TD>        }</TD></TR><TR><TD CLASS="l">4882</TD><TD> </TD></TR><TR><TD CLASS="l">4883</TD><TD>        // Figure out what the new product states should be.</TD></TR><TR><TD CLASS="l">4884</TD><TD>        // NOTE: to go into opening rotation the all products in the class must in pre-open state.</TD></TR><TR CLASS="z"><TD CLASS="l">4885</TD><TD>        short checkProductState = -1; // -1 means don't check the state of the products</TD></TR><TR CLASS="z"><TD CLASS="l">4886</TD><TD>        short newState = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">4887</TD><TD>        if (underlyingProductState.productState == ProductStates.OPEN) {</TD></TR><TR CLASS="z"><TD CLASS="l">4888</TD><TD>            checkProductState = ProductStates.PRE_OPEN;</TD></TR><TR CLASS="z"><TD CLASS="l">4889</TD><TD>            newState = ProductStates.OPENING_ROTATION;</TD></TR><TR><TD CLASS="l">4890</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4891</TD><TD>        else if (underlyingProductState.productState == ProductStates.HALTED) {</TD></TR><TR CLASS="z"><TD CLASS="l">4892</TD><TD>            checkProductState = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">4893</TD><TD>            newState = ProductStates.HALTED;</TD></TR><TR><TD CLASS="l">4894</TD><TD>        }</TD></TR><TR><TD CLASS="l">4895</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">4896</TD><TD>            Log.alarm(this,&#34;Process Underlying state change :Derivative products will not change state as underlying is not halted or in open state for class/session/state: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + underlyingSession + &#34;/&#34; + underlyingProductState.productState);</TD></TR><TR CLASS="z"><TD CLASS="l">4897</TD><TD>            return;</TD></TR><TR><TD CLASS="l">4898</TD><TD>        }</TD></TR><TR><TD CLASS="l">4899</TD><TD> </TD></TR><TR><TD CLASS="l">4900</TD><TD>        // Get hold of PSS</TD></TR><TR CLASS="z"><TD CLASS="l">4901</TD><TD>        ProductStateService pss = InternalBusinessServicesHelper.getProductStateService();</TD></TR><TR><TD CLASS="l">4902</TD><TD> </TD></TR><TR><TD CLASS="l">4903</TD><TD>        // Change product states if all products for the class are in the specified state and withing the product pre-open and</TD></TR><TR><TD CLASS="l">4904</TD><TD>        // product close time range. Also make sure if the session it self is eligible for these state changes.</TD></TR><TR CLASS="z"><TD CLASS="l">4905</TD><TD>        final int len = sessionNames.size();</TD></TR><TR CLASS="z"><TD CLASS="l">4906</TD><TD>        for (int i = 0; i &lt; len; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4907</TD><TD>            String sessionName = (String)sessionNames.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">4908</TD><TD>            if (!isSessionTriggeredByUnderlyingStateChange(sessionName, underlyingProductState.productState)) {</TD></TR><TR CLASS="z"><TD CLASS="l">4909</TD><TD>                if (Log.isDebugOn()) {</TD></TR><TR CLASS="z"><TD CLASS="l">4910</TD><TD>                    Log.debug(this,&#34;:processStateChangeForDerivative: Session not configured: Unable to perform state change on Underlying product state change trigger for Underlying class/session/prod class: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + sessionName + &#34;/&#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol + &#34;)&#34; );</TD></TR><TR><TD CLASS="l">4911</TD><TD>                }</TD></TR><TR><TD CLASS="l">4912</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">4913</TD><TD>            }</TD></TR><TR><TD CLASS="l">4914</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4915</TD><TD>            if (!areAllProductsForClassInStateAndInTimeRange(sessionName, derivativeClass.classKey, checkProductState)) {</TD></TR><TR CLASS="z"><TD CLASS="l">4916</TD><TD>                Log.alarm(this,&#34;Unable to perform state change on Underlying product state change trigger for Underlying class/session/prod class: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + sessionName + &#34;/&#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol + &#34;). BECAUSE Derivative Product not configured in session OR not in product open/pre-open time range OR not all products are in product state = &#34; + checkProductState);</TD></TR><TR CLASS="z"><TD CLASS="l">4917</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">4918</TD><TD>            }</TD></TR><TR><TD CLASS="l">4919</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4920</TD><TD>            if (isHaltRequestAndPreOpenState(sessionName, derivativeClass, newState)) {</TD></TR><TR CLASS="z"><TD CLASS="l">4921</TD><TD>                Log.information(this, &#34;Unable to perform HALT state change for Underlying class/prod class: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol</TD></TR><TR><TD CLASS="l">4922</TD><TD>                        + &#34;). BECAUSE Product is in Pre-Open State&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4923</TD><TD>                return;</TD></TR><TR><TD CLASS="l">4924</TD><TD>            }</TD></TR><TR><TD CLASS="l">4925</TD><TD> </TD></TR><TR><TD CLASS="l">4926</TD><TD>            // Make the state changes now.</TD></TR><TR><TD CLASS="l">4927</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">4928</TD><TD>                Log.information(this,&#34;:processStateChangeForDerivative: Changing product states to: &#34; + newState + &#34; because underlying product state changed for Underlying class/session/prod class: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + sessionName + &#34;/&#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol + &#34;)&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">4929</TD><TD>                pss.setProductStateByClass(sessionName, derivativeClass.classKey, newState);</TD></TR><TR><TD CLASS="l">4930</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4931</TD><TD>            catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">4932</TD><TD>                Log.exception(this,&#34;ERROR in : processStateChangeForDerivative: on Underlying product state change trigger for Underlying class/session/prod class: &#34; + underlyingProductState.productKeys.classKey + &#34;/&#34; + sessionName + &#34;/&#34; + derivativeClass.classKey + &#34;(&#34; + derivativeClass.classSymbol + &#34;). Exception: &#34; + e, e);</TD></TR><TR CLASS="z"><TD CLASS="l">4933</TD><TD>            }</TD></TR><TR><TD CLASS="l">4934</TD><TD>       }</TD></TR><TR CLASS="z"><TD CLASS="l">4935</TD><TD>    }</TD></TR><TR><TD CLASS="l">4936</TD><TD> </TD></TR><TR><TD CLASS="l">4937</TD><TD> </TD></TR><TR><TD CLASS="l">4938</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4939</TD><TD>     * @param sessionName</TD></TR><TR><TD CLASS="l">4940</TD><TD>     * @param derivativeClass</TD></TR><TR><TD CLASS="l">4941</TD><TD>     * @param newState</TD></TR><TR><TD CLASS="l"><A NAME="7e">4942</A></TD><TD>     * @return true if Halt Request Received from Tips while product is in Pre Open state</TD></TR><TR><TD CLASS="l">4943</TD><TD>     */</TD></TR><TR><TD CLASS="l">4944</TD><TD>    private boolean isHaltRequestAndPreOpenState(String sessionName, ClassStruct derivativeClass, short newState)</TD></TR><TR><TD CLASS="l">4945</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4946</TD><TD>        if (!(newState == ProductStates.HALTED))</TD></TR><TR CLASS="z"><TD CLASS="l">4947</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">4948</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4949</TD><TD>        if (Log.isDebugOn())</TD></TR><TR CLASS="z"><TD CLASS="l">4950</TD><TD>            Log.information(this, &#34;Pre-Open check on Halt request&#34;);</TD></TR><TR><TD CLASS="l">4951</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4952</TD><TD>        TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">4953</TD><TD>        SessionElementClass elementClass = null;</TD></TR><TR CLASS="z"><TD CLASS="l">4954</TD><TD>        TradingSessionElement sessionElement = null;</TD></TR><TR><TD CLASS="l">4955</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4956</TD><TD>        for (int i = 0; (elements != null) &amp;&amp; (i &lt; elements.length); i++) {</TD></TR><TR><TD CLASS="l">4957</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">4958</TD><TD>                sessionElement = elements[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4959</TD><TD>                elementClass = sessionElement.findClass(derivativeClass.classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">4960</TD><TD>                break; // class can be in only one element of a session.</TD></TR><TR><TD CLASS="l">4961</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4962</TD><TD>            catch (NotFoundException e) { // may not be in this element</TD></TR><TR><TD CLASS="l">4963</TD><TD>            }</TD></TR><TR><TD CLASS="l">4964</TD><TD>        }</TD></TR><TR><TD CLASS="l">4965</TD><TD> </TD></TR><TR><TD CLASS="l">4966</TD><TD>        // if the class is not found in the session then just return now.</TD></TR><TR CLASS="z"><TD CLASS="l">4967</TD><TD>        if (elementClass == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4968</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">4969</TD><TD>        }</TD></TR><TR><TD CLASS="l">4970</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4971</TD><TD>        if (elementClass.getClassState() == ClassStates.PRE_OPEN)</TD></TR><TR><TD CLASS="l">4972</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">4973</TD><TD>            Log.information(this, &#34;Prevented state change on underlying tick for &#34; + derivativeClass.classKey + &#34; since this class is currently in a Pre-Open state.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">4974</TD><TD>            return true;</TD></TR><TR><TD CLASS="l">4975</TD><TD>        }</TD></TR><TR><TD CLASS="l">4976</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4977</TD><TD>        return false;</TD></TR><TR><TD CLASS="l"><A NAME="81">4978</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4979</TD><TD> </TD></TR><TR><TD CLASS="l">4980</TD><TD>    private boolean isSessionTriggeredByUnderlyingStateChange(String sessionName, short underlyingProductState)</TD></TR><TR><TD CLASS="l">4981</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4982</TD><TD>        switch(underlyingProductState)</TD></TR><TR><TD CLASS="l">4983</TD><TD>        {</TD></TR><TR><TD CLASS="l">4984</TD><TD>            case(ProductStates.OPEN):</TD></TR><TR><TD CLASS="l">4985</TD><TD>            {    </TD></TR><TR CLASS="z"><TD CLASS="l">4986</TD><TD>                if (underlyingStateOpenTriggeredSessions != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4987</TD><TD>                    for (int i = 0; i &lt; underlyingStateOpenTriggeredSessions.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4988</TD><TD>                        if (underlyingStateOpenTriggeredSessions[i].equals(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">4989</TD><TD>                            return true;</TD></TR><TR><TD CLASS="l">4990</TD><TD>                        }</TD></TR><TR><TD CLASS="l">4991</TD><TD>                    }</TD></TR><TR><TD CLASS="l">4992</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4993</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">4994</TD><TD>            }</TD></TR><TR><TD CLASS="l">4995</TD><TD> </TD></TR><TR><TD CLASS="l">4996</TD><TD>            case(ProductStates.HALTED):</TD></TR><TR><TD CLASS="l">4997</TD><TD>            {    </TD></TR><TR CLASS="z"><TD CLASS="l">4998</TD><TD>                if (underlyingStateHaltTriggeredSessions != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4999</TD><TD>                    for (int i = 0; i &lt; underlyingStateHaltTriggeredSessions.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">5000</TD><TD>                        if (underlyingStateHaltTriggeredSessions[i].equals(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5001</TD><TD>                            return true;</TD></TR><TR><TD CLASS="l">5002</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5003</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5004</TD><TD>                }</TD></TR><TR><TD CLASS="l">5005</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">5006</TD><TD>                if (underlyingStateHaltTriggeredSTOCKSessions != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">5007</TD><TD>                    for (int i = 0; i &lt; underlyingStateHaltTriggeredSTOCKSessions.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">5008</TD><TD>                        if (underlyingStateHaltTriggeredSTOCKSessions[i].equals(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5009</TD><TD>                            return true;</TD></TR><TR><TD CLASS="l">5010</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5011</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5012</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">5013</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">5014</TD><TD>            }</TD></TR><TR><TD CLASS="l">5015</TD><TD> </TD></TR><TR><TD CLASS="l">5016</TD><TD>            default:</TD></TR><TR CLASS="z"><TD CLASS="l">5017</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">5018</TD><TD>        }</TD></TR><TR><TD CLASS="l">5019</TD><TD>    }</TD></TR><TR><TD CLASS="l">5020</TD><TD> </TD></TR><TR><TD CLASS="l">5021</TD><TD>/**</TD></TR><TR><TD CLASS="l">5022</TD><TD> * Returns true if all products for the specified class in the spacified state</TD></TR><TR><TD CLASS="l">5023</TD><TD> * and  if the current time is between the pre-open and close time range for</TD></TR><TR><TD CLASS="l">5024</TD><TD> * the trading session element this class is part of in that session.</TD></TR><TR><TD CLASS="l">5025</TD><TD> *</TD></TR><TR><TD CLASS="l">5026</TD><TD> * @param sesionName name of session</TD></TR><TR><TD CLASS="l">5027</TD><TD> * @param int classKey the class of all products.</TD></TR><TR><TD CLASS="l"><A NAME="12">5028</A></TD><TD> * @param short state all products should be in</TD></TR><TR><TD CLASS="l">5029</TD><TD> */</TD></TR><TR><TD CLASS="l">5030</TD><TD>public boolean areAllProductsForClassInStateAndInTimeRange(String sessionName, int classKey, short state) {</TD></TR><TR><TD CLASS="l">5031</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5032</TD><TD>    TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">5033</TD><TD>    SessionElementClass elementClass = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5034</TD><TD>    TradingSessionElement sessionElement = null;</TD></TR><TR><TD CLASS="l">5035</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5036</TD><TD>    for (int i = 0; (elements != null) &amp;&amp; (i &lt; elements.length); i++) {</TD></TR><TR><TD CLASS="l">5037</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">5038</TD><TD>            sessionElement = elements[i];</TD></TR><TR CLASS="z"><TD CLASS="l">5039</TD><TD>            elementClass = sessionElement.findClass(classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5040</TD><TD>            break; // class can be in only one element of a session.</TD></TR><TR><TD CLASS="l">5041</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5042</TD><TD>        catch (NotFoundException e) { // may not be in this element</TD></TR><TR><TD CLASS="l">5043</TD><TD>        }</TD></TR><TR><TD CLASS="l">5044</TD><TD>    }</TD></TR><TR><TD CLASS="l">5045</TD><TD> </TD></TR><TR><TD CLASS="l">5046</TD><TD>    // if the class is not found in the session then just return now.</TD></TR><TR CLASS="z"><TD CLASS="l">5047</TD><TD>    if (elementClass == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">5048</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">5049</TD><TD>    }</TD></TR><TR><TD CLASS="l">5050</TD><TD> </TD></TR><TR><TD CLASS="l">5051</TD><TD>    // If the current time is not withing the product pre-open and close time then</TD></TR><TR><TD CLASS="l">5052</TD><TD>    // abort now.</TD></TR><TR CLASS="z"><TD CLASS="l">5053</TD><TD>    long currTime = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">5054</TD><TD>    if (currTime &lt;= sessionElement.getProductPreOpenTime() || currTime &gt;= sessionElement.getProductCloseTime()) {</TD></TR><TR CLASS="z"><TD CLASS="l">5055</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">5056</TD><TD>    }</TD></TR><TR><TD CLASS="l">5057</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5058</TD><TD>    if (elementClass.getClassState() == ClassStates.SUSPENDED &amp;&amp; blockAutoTransitionFromSuspended)</TD></TR><TR><TD CLASS="l">5059</TD><TD>    {</TD></TR><TR><TD CLASS="l">5060</TD><TD>        // We only bother checking for 'suspended' at the class level.</TD></TR><TR><TD CLASS="l">5061</TD><TD>        //</TD></TR><TR CLASS="z"><TD CLASS="l">5062</TD><TD>        Log.information(&#34;Prevented state change on underlying tick for &#34; + classKey + &#34; since this class is currently in a SUSPENDED state.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5063</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">5064</TD><TD>    }</TD></TR><TR><TD CLASS="l">5065</TD><TD> </TD></TR><TR><TD CLASS="l">5066</TD><TD>    // Check if all products are in the same specified state.</TD></TR><TR><TD CLASS="l">5067</TD><TD>    // Ignore this check if the 'state' is -1.</TD></TR><TR><TD CLASS="l">5068</TD><TD>    // Also the product state is ignored when this product is of BUY_WRITE strategy</TD></TR><TR><TD CLASS="l">5069</TD><TD>    // type. Added on 11/11/2004 by pyatetsk</TD></TR><TR CLASS="z"><TD CLASS="l">5070</TD><TD>    SessionElementProduct[] elementProducts = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5071</TD><TD>    Product theProduct=null;</TD></TR><TR CLASS="z"><TD CLASS="l">5072</TD><TD>    int productKey=0;</TD></TR><TR CLASS="z"><TD CLASS="l">5073</TD><TD>    if (state != -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">5074</TD><TD>        elementProducts = elementClass.getProducts();</TD></TR><TR CLASS="z"><TD CLASS="l">5075</TD><TD>        for (int j = 0; j &lt; elementProducts.length; j++) {</TD></TR><TR><TD CLASS="l">5076</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">5077</TD><TD>                productKey = elementProducts[j].getProductKey();</TD></TR><TR CLASS="z"><TD CLASS="l">5078</TD><TD>                theProduct = getProductHome().findByKey(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5079</TD><TD>                if (((ProductImpl)theProduct).getProductSubType() == StrategyTypes.BUY_WRITE )</TD></TR><TR><TD CLASS="l">5080</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5081</TD><TD>                        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">5082</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5083</TD><TD>                            Log.debug(this,&#34;Ignoring product state of BUY-WRITES for opening classes.&#34;);</TD></TR><TR><TD CLASS="l">5084</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5085</TD><TD>                }</TD></TR><TR><TD CLASS="l">5086</TD><TD>                else</TD></TR><TR><TD CLASS="l">5087</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5088</TD><TD>                        if (state != elementProducts[j].getProductState())</TD></TR><TR><TD CLASS="l">5089</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5090</TD><TD>                            if (theProduct.isProductType(ProductTypes.STRATEGY) &amp;&amp;</TD></TR><TR><TD CLASS="l">5091</TD><TD>                            ((elementProducts[j].getProductState() == ProductStates.ON_HOLD) ||</TD></TR><TR><TD CLASS="l">5092</TD><TD>                             (elementProducts[j].getProductState() == ProductStates.PRE_OPEN) ||</TD></TR><TR><TD CLASS="l">5093</TD><TD>                             (elementProducts[j].getProductState() == ProductStates.OPENING_ROTATION) ||</TD></TR><TR><TD CLASS="l">5094</TD><TD>                             (elementProducts[j].getProductState() == ProductStates.CLOSED) ||</TD></TR><TR><TD CLASS="l">5095</TD><TD>                             (elementProducts[j].getProductState() == ProductStates.NO_SESSION) ||</TD></TR><TR><TD CLASS="l">5096</TD><TD>                             (elementProducts[j].getProductState() == ProductStates.OPEN) ||</TD></TR><TR><TD CLASS="l">5097</TD><TD>                               ((elementProducts[j].getProductState() == ProductStates.NO_SESSION)&amp;&amp; elementProducts[j].getProductCreateState())  </TD></TR><TR><TD CLASS="l">5098</TD><TD>                              )    </TD></TR><TR><TD CLASS="l">5099</TD><TD>                               )</TD></TR><TR><TD CLASS="l">5100</TD><TD>                        {</TD></TR><TR><TD CLASS="l">5101</TD><TD>                            // ON_HOLD, PREOPEN, OPENING_ROTATION and OPEN are valid states for strategies to be in. We should be abel to open the strategies.</TD></TR><TR><TD CLASS="l">5102</TD><TD>                            // Also allowed is handling of the race condition between strategy creation and rotation. Global may not yet have the session </TD></TR><TR><TD CLASS="l">5103</TD><TD>                                // and product state data from the BC. </TD></TR><TR CLASS="z"><TD CLASS="l">5104</TD><TD>                            if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">5105</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">5106</TD><TD>                                   Log.debug(this,&#34;Strategy product in ON_HOLD, PREOPEN, OPENING_ROTATION, OPEN state or is NO_SESSION and just created  - Ignoring state change: Product Key =  &#34; + elementProducts[j].getProductKey());</TD></TR><TR><TD CLASS="l">5107</TD><TD>                                }</TD></TR><TR><TD CLASS="l">5108</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5109</TD><TD>                        else</TD></TR><TR><TD CLASS="l">5110</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5111</TD><TD>                            Log.information(this, &#34;areAllProductsForClassInStateAndInTimeRange &gt;&gt;&gt; Product :&#34; + elementProducts[j].getProductKey() + &#34; in state: &#34; + elementProducts[j].getProductState() + &#34;. Expecting:  &#34; + state + &#34;. Returning false.&#34; );</TD></TR><TR CLASS="z"><TD CLASS="l">5112</TD><TD>                            return false;</TD></TR><TR><TD CLASS="l">5113</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5114</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5115</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">5116</TD><TD>            } catch (NotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5117</TD><TD>                Log.exception(this, &#34;Unable to find TradingProduct for given productKey = &#34; + productKey, e);</TD></TR><TR CLASS="z"><TD CLASS="l">5118</TD><TD>            }</TD></TR><TR><TD CLASS="l">5119</TD><TD>        }</TD></TR><TR><TD CLASS="l">5120</TD><TD>    }</TD></TR><TR><TD CLASS="l">5121</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5122</TD><TD>    return true;</TD></TR><TR><TD CLASS="l">5123</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="c4">5124</A></TD><TD> </TD></TR><TR><TD CLASS="l">5125</TD><TD>    private void validateStrategy( String sessionName, StrategyRequestStruct strategyRequest )</TD></TR><TR><TD CLASS="l">5126</TD><TD>        throws DataValidationException</TD></TR><TR><TD CLASS="l">5127</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5128</TD><TD>        validateStrategySession( sessionName, strategyRequest );</TD></TR><TR CLASS="z"><TD CLASS="l">5129</TD><TD>        validateStrategyLegs( sessionName, strategyRequest );</TD></TR><TR CLASS="z"><TD CLASS="l">5130</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="c6">5131</A></TD><TD> </TD></TR><TR><TD CLASS="l">5132</TD><TD>    private void validateStrategySession( String sessionName, StrategyRequestStruct strategyRequest )</TD></TR><TR><TD CLASS="l">5133</TD><TD>        throws DataValidationException</TD></TR><TR><TD CLASS="l">5134</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5135</TD><TD>        boolean     validForSession = false;</TD></TR><TR><TD CLASS="l">5136</TD><TD> </TD></TR><TR><TD CLASS="l">5137</TD><TD>        try</TD></TR><TR><TD CLASS="l">5138</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5139</TD><TD>            TradingSessionStrategyAssignmentStrategy strategy = strategyFactory.getStrategyAssignmentStrategy( sessionName );</TD></TR><TR CLASS="z"><TD CLASS="l">5140</TD><TD>            validForSession = strategy.assignableToSession( sessionName, strategyRequest );</TD></TR><TR CLASS="z"><TD CLASS="l">5141</TD><TD>            if ( ! validForSession )</TD></TR><TR><TD CLASS="l">5142</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5143</TD><TD>                throw ExceptionBuilder.dataValidationException( &#34;Strategy request is not assignable for the given session, &#34;</TD></TR><TR><TD CLASS="l">5144</TD><TD>                                                                    + sessionName</TD></TR><TR><TD CLASS="l">5145</TD><TD>                                                                    + &#34;, and will not be created nor assigned.&#34;</TD></TR><TR><TD CLASS="l">5146</TD><TD>                                                                    , 0</TD></TR><TR><TD CLASS="l">5147</TD><TD>                                                                    );</TD></TR><TR><TD CLASS="l">5148</TD><TD>            }</TD></TR><TR><TD CLASS="l">5149</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5150</TD><TD>        catch( NotFoundException nf )</TD></TR><TR><TD CLASS="l">5151</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5152</TD><TD>            throw ExceptionBuilder.dataValidationException( &#34;Strategy request does not have an assignement strategy for the given session, &#34;</TD></TR><TR><TD CLASS="l">5153</TD><TD>                                                                + sessionName</TD></TR><TR><TD CLASS="l">5154</TD><TD>                                                                + &#34;, and will not be created nor assigned.&#34;</TD></TR><TR><TD CLASS="l">5155</TD><TD>                                                                , 0</TD></TR><TR><TD CLASS="l">5156</TD><TD>                                                                );</TD></TR><TR CLASS="z"><TD CLASS="l">5157</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="7b">5158</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5159</TD><TD> </TD></TR><TR><TD CLASS="l">5160</TD><TD>    protected ProductStateChangeStrategy instantiateProductStateChangeStrategy(String strategyImplName) throws InappropriateValueException, NoSuchPropertyException</TD></TR><TR><TD CLASS="l">5161</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5162</TD><TD>        Log.information(this,&#34;Instantiating Product State Change Strategy, Strategy = &#34; + strategyImplName);</TD></TR><TR CLASS="z"><TD CLASS="l">5163</TD><TD>        Configuration config = new Configuration(getBOHome());</TD></TR><TR><TD CLASS="l">5164</TD><TD>        ProductStateChangeStrategy productStateImplementation;</TD></TR><TR><TD CLASS="l">5165</TD><TD>        try</TD></TR><TR><TD CLASS="l">5166</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5167</TD><TD>            productStateImplementation  = (ProductStateChangeStrategy) Class.forName(strategyImplName).newInstance();</TD></TR><TR CLASS="z"><TD CLASS="l">5168</TD><TD>            productStateImplementation.initialize(config);</TD></TR><TR CLASS="z"><TD CLASS="l">5169</TD><TD>            return productStateImplementation;</TD></TR><TR><TD CLASS="l">5170</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5171</TD><TD>        catch (InstantiationException e)</TD></TR><TR><TD CLASS="l">5172</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5173</TD><TD>            throw new InappropriateValueException(&#34;Error instantiating Product State Change Strategy Implementation, InstantiationException&#34;);</TD></TR><TR><TD CLASS="l">5174</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5175</TD><TD>        catch (IllegalAccessException e)</TD></TR><TR><TD CLASS="l">5176</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5177</TD><TD>            throw new InappropriateValueException(&#34;Error instantiating Product State Change Strategy Implementation, IllegalAccessException&#34;);</TD></TR><TR><TD CLASS="l">5178</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5179</TD><TD>        catch (ClassNotFoundException e)</TD></TR><TR><TD CLASS="l">5180</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5181</TD><TD>            throw new InappropriateValueException(&#34;Error instantiating Product State Change Strategy Implementation, ClassNotFoundException&#34;);</TD></TR><TR><TD CLASS="l">5182</TD><TD>        }</TD></TR><TR><TD CLASS="l">5183</TD><TD>    }</TD></TR><TR><TD CLASS="l">5184</TD><TD> </TD></TR><TR><TD CLASS="l">5185</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5186</TD><TD>     * Gets reference to home for products.</TD></TR><TR><TD CLASS="l">5187</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="5d">5188</A></TD><TD>     * @return reference to product home</TD></TR><TR><TD CLASS="l">5189</TD><TD>     */</TD></TR><TR><TD CLASS="l">5190</TD><TD>     private ProductHome getProductHome()</TD></TR><TR><TD CLASS="l">5191</TD><TD>     {</TD></TR><TR CLASS="z"><TD CLASS="l">5192</TD><TD>        if (productHome == null)</TD></TR><TR><TD CLASS="l">5193</TD><TD>        {</TD></TR><TR><TD CLASS="l">5194</TD><TD>          try</TD></TR><TR><TD CLASS="l">5195</TD><TD>          {</TD></TR><TR CLASS="z"><TD CLASS="l">5196</TD><TD>               productHome = (ProductHome) HomeFactory.getInstance().findHome(ProductHome.HOME_NAME);</TD></TR><TR><TD CLASS="l">5197</TD><TD>          }</TD></TR><TR CLASS="z"><TD CLASS="l">5198</TD><TD>          catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e)</TD></TR><TR><TD CLASS="l">5199</TD><TD>          {</TD></TR><TR CLASS="z"><TD CLASS="l">5200</TD><TD>            throw new FatalFoundationFrameworkException(e,&#34;Cannot not find ProductHome&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5201</TD><TD>          }</TD></TR><TR><TD CLASS="l">5202</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5203</TD><TD>        return productHome;</TD></TR><TR><TD CLASS="l"><A NAME="33">5204</A></TD><TD>     }</TD></TR><TR><TD CLASS="l">5205</TD><TD> </TD></TR><TR><TD CLASS="l">5206</TD><TD>    public String[] getCachedTradingSessionsForClass(int classKey)</TD></TR><TR><TD CLASS="l">5207</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5208</TD><TD>         List sessionNames = (List)this.sessionsByClass.get(new Integer(classKey));</TD></TR><TR CLASS="z"><TD CLASS="l">5209</TD><TD>         String[] result =  new String[0];</TD></TR><TR CLASS="z"><TD CLASS="l">5210</TD><TD>         if (sessionNames == null)</TD></TR><TR><TD CLASS="l">5211</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">5212</TD><TD>             Log.information(this, &#34;No sessions found for class &#34; + classKey);</TD></TR><TR><TD CLASS="l">5213</TD><TD>         }</TD></TR><TR><TD CLASS="l">5214</TD><TD>         else</TD></TR><TR><TD CLASS="l">5215</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">5216</TD><TD>             result =  new String[sessionNames.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">5217</TD><TD>             sessionNames.toArray(result);</TD></TR><TR><TD CLASS="l">5218</TD><TD>         }</TD></TR><TR CLASS="z"><TD CLASS="l">5219</TD><TD>         return result;</TD></TR><TR><TD CLASS="l">5220</TD><TD>    }</TD></TR><TR><TD CLASS="l">5221</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5222</TD><TD>     * getCachedDerivativeClassesForProduct - get derivative classes derived from the givin underlying productKey</TD></TR><TR><TD CLASS="l">5223</TD><TD>     * @param underlyingProductKey</TD></TR><TR><TD CLASS="l">5224</TD><TD>     * @return</TD></TR><TR><TD CLASS="l"><A NAME="31">5225</A></TD><TD>     * @throws SystemException</TD></TR><TR><TD CLASS="l">5226</TD><TD>     */</TD></TR><TR><TD CLASS="l">5227</TD><TD>    public ClassStruct[] getCachedDerivativeClassesForProduct(int underlyingProductKey) throws SystemException</TD></TR><TR><TD CLASS="l">5228</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5229</TD><TD>        ClassStruct[]  result =  new ClassStruct[0];</TD></TR><TR CLASS="z"><TD CLASS="l">5230</TD><TD>        List derivativeClassStructs = (List)this.derivativesByUnderlying.get(new Integer(underlyingProductKey));</TD></TR><TR CLASS="z"><TD CLASS="l">5231</TD><TD>         if (derivativeClassStructs == null)</TD></TR><TR><TD CLASS="l">5232</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">5233</TD><TD>                Log.information(this, &#34;Received call to query underlying product that has no derivatives in any session: undly Prod&#34; + underlyingProductKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5234</TD><TD>                return result;</TD></TR><TR><TD CLASS="l">5235</TD><TD>         }</TD></TR><TR><TD CLASS="l">5236</TD><TD>         else</TD></TR><TR><TD CLASS="l">5237</TD><TD>         {</TD></TR><TR CLASS="z"><TD CLASS="l">5238</TD><TD>             result =  new ClassStruct[derivativeClassStructs.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">5239</TD><TD>             derivativeClassStructs.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">5240</TD><TD>             if  (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">5241</TD><TD>             {</TD></TR><TR CLASS="z"><TD CLASS="l">5242</TD><TD>                 String msg = &#34;For underlying prodKey: &#34; +  underlyingProductKey + &#34;,  found the derivitive classes =&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">5243</TD><TD>                 for (int i=0; i&lt; result.length; i++)</TD></TR><TR><TD CLASS="l">5244</TD><TD>                 {</TD></TR><TR CLASS="z"><TD CLASS="l">5245</TD><TD>                     msg = msg + &#34;:&#34; + result[i].classSymbol + &#34;,&#34; + result[i].classKey + &#34; &#34;;</TD></TR><TR><TD CLASS="l">5246</TD><TD>                 }</TD></TR><TR CLASS="z"><TD CLASS="l">5247</TD><TD>                 Log.debug( msg );</TD></TR><TR><TD CLASS="l">5248</TD><TD>             }</TD></TR><TR><TD CLASS="l">5249</TD><TD>         }</TD></TR><TR CLASS="z"><TD CLASS="l">5250</TD><TD>         return result;</TD></TR><TR><TD CLASS="l">5251</TD><TD>    }</TD></TR><TR><TD CLASS="l">5252</TD><TD>    </TD></TR><TR><TD CLASS="l"><A NAME="1c">5253</A></TD><TD>    // This method clears cache of products used in end of session.</TD></TR><TR><TD CLASS="l">5254</TD><TD>    // called from ProductUpdateConsumerImpl</TD></TR><TR><TD CLASS="l">5255</TD><TD>    public void clearSessionProdCache()</TD></TR><TR><TD CLASS="l">5256</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5257</TD><TD>            sessionClassCache.clear();</TD></TR><TR CLASS="z"><TD CLASS="l">5258</TD><TD>            clearElementCache();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1d">5259</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5260</TD><TD>    </TD></TR><TR><TD CLASS="l">5261</TD><TD>    private void clearSessionProdCache(String session, boolean clearElementCacheFlag)</TD></TR><TR><TD CLASS="l">5262</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5263</TD><TD>                   HashMap&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt; seInfoMap = sessionClassCache.remove(session);</TD></TR><TR><TD CLASS="l">5264</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">5265</TD><TD>            if (clearElementCacheFlag)</TD></TR><TR><TD CLASS="l">5266</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5267</TD><TD>                    clearElementCache();</TD></TR><TR><TD CLASS="l">5268</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1b">5269</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5270</TD><TD>    </TD></TR><TR><TD CLASS="l">5271</TD><TD>    private void clearElementCache()</TD></TR><TR><TD CLASS="l">5272</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5273</TD><TD>                elementCache.clear();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="32">5274</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5275</TD><TD>    </TD></TR><TR><TD CLASS="l">5276</TD><TD>    private SessionClassDetailStruct[] getCachedElementClasses(int elementKey) throws DataValidationException</TD></TR><TR><TD CLASS="l">5277</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5278</TD><TD>                SessionClassDetailStruct[] rval = elementCache.get(elementKey);</TD></TR><TR><TD CLASS="l">5279</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5280</TD><TD>                if (rval == null)</TD></TR><TR><TD CLASS="l">5281</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5282</TD><TD>                        synchronized (elementCache)</TD></TR><TR><TD CLASS="l">5283</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5284</TD><TD>                                rval = elementCache.get(elementKey);</TD></TR><TR><TD CLASS="l">5285</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5286</TD><TD>                                if (rval == null)</TD></TR><TR><TD CLASS="l">5287</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">5288</TD><TD>                                        Log.information(this.getBOHome(), Thread.currentThread().getName() + &#34; Initializing cache (SessionClassDetailStruct[]) for element : &#34; + elementKey);</TD></TR><TR><TD CLASS="l">5289</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5290</TD><TD>                                        rval = getClassesForElementPrivate(elementKey);</TD></TR><TR><TD CLASS="l">5291</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5292</TD><TD>                                        elementCache.put(elementKey, rval);</TD></TR><TR><TD CLASS="l">5293</TD><TD>                                        </TD></TR><TR CLASS="z"><TD CLASS="l">5294</TD><TD>                                        Log.information(this.getBOHome(), Thread.currentThread().getName() + &#34; Completed initializing cache (SessionClassDetailStruct[]) for element : &#34; + elementKey);</TD></TR><TR><TD CLASS="l">5295</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">5296</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5297</TD><TD>                }</TD></TR><TR><TD CLASS="l">5298</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5299</TD><TD>                return rval;</TD></TR><TR><TD CLASS="l"><A NAME="67">5300</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">5301</TD><TD>    </TD></TR><TR><TD CLASS="l">5302</TD><TD>    private HashMap&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt; getSessionProdCache(String sessionName) throws DataValidationException</TD></TR><TR><TD CLASS="l">5303</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5304</TD><TD>                HashMap&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt; seInfoMap = sessionClassCache.get(sessionName);</TD></TR><TR><TD CLASS="l">5305</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5306</TD><TD>                if (seInfoMap == null)</TD></TR><TR><TD CLASS="l">5307</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5308</TD><TD>                        Object lock = getSessionLock(sessionName);</TD></TR><TR><TD CLASS="l">5309</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5310</TD><TD>                        synchronized (lock)</TD></TR><TR><TD CLASS="l">5311</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5312</TD><TD>                                seInfoMap = sessionClassCache.get(sessionName);</TD></TR><TR><TD CLASS="l">5313</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">5314</TD><TD>                                if (seInfoMap == null)</TD></TR><TR><TD CLASS="l">5315</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">5316</TD><TD>                                        Log.information(this.getBOHome(), Thread.currentThread().getName() + &#34;Initializing product cache of hashMap(TradingSessionElement, hashMap(ClassKey, SessionClassDetailStruct)) for session: &#34; + sessionName);</TD></TR><TR><TD CLASS="l">5317</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5318</TD><TD>                                        TradingSessionElement[] elements = elementHome.findCurrentForSession(sessionName);</TD></TR><TR><TD CLASS="l">5319</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5320</TD><TD>                                        ArrayList classDetail = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">5321</TD><TD>                                        seInfoMap = new HashMap&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt;();</TD></TR><TR><TD CLASS="l">5322</TD><TD>                                        IntHashMap&lt;SessionClassDetailStruct&gt; sessionClassHash;</TD></TR><TR><TD CLASS="l">5323</TD><TD>                                        TradingSessionElementClassesDetailStruct aStruct;</TD></TR><TR CLASS="z"><TD CLASS="l">5324</TD><TD>                                        TradingSessionElementInfoStruct seInfo = new TradingSessionElementInfoStruct();</TD></TR><TR><TD CLASS="l">5325</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5326</TD><TD>                                        for (int i = 0; i &lt; elements.length; i++)</TD></TR><TR><TD CLASS="l">5327</TD><TD>                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5328</TD><TD>                                                sessionClassHash = new IntHashMap&lt;SessionClassDetailStruct&gt;();</TD></TR><TR><TD CLASS="l">5329</TD><TD> </TD></TR><TR><TD CLASS="l">5330</TD><TD>                                                /* get cached info if possible */</TD></TR><TR CLASS="z"><TD CLASS="l">5331</TD><TD>                                                SessionClassDetailStruct[] sessionElementClasses = getClassesForElement(elements[i].getElementKey());</TD></TR><TR><TD CLASS="l">5332</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5333</TD><TD>                                                seInfo = elements[i].getTradingSessionElementInfoStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5334</TD><TD>                                                for (int k = 0; k &lt; sessionElementClasses.length; k++)</TD></TR><TR><TD CLASS="l">5335</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">5336</TD><TD>                                                        sessionClassHash.put(sessionElementClasses[k].classDetail.classStruct.classKey,</TD></TR><TR><TD CLASS="l">5337</TD><TD>                                                                        sessionElementClasses[k]);</TD></TR><TR><TD CLASS="l">5338</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">5339</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5340</TD><TD>                                                seInfoMap.put(seInfo, sessionClassHash);</TD></TR><TR><TD CLASS="l">5341</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">5342</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5343</TD><TD>                                        sessionClassCache.put(sessionName, seInfoMap);</TD></TR><TR><TD CLASS="l">5344</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5345</TD><TD>                                        Log.information(this.getBOHome(), Thread.currentThread().getName() + &#34;Completed initializing product cache of hashMap(TradingSessionElement, hashMap(ClassKey, SessionClassDetailStruct)) for session: &#34; + sessionName);</TD></TR><TR><TD CLASS="l">5346</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">5347</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5348</TD><TD>                }</TD></TR><TR><TD CLASS="l">5349</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5350</TD><TD>                return seInfoMap;</TD></TR><TR><TD CLASS="l"><A NAME="66">5351</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">5352</TD><TD>    </TD></TR><TR><TD CLASS="l">5353</TD><TD>    private Object getSessionLock (String sessionName)</TD></TR><TR><TD CLASS="l">5354</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5355</TD><TD>                Object lock = sessionLockMap.get(sessionName);</TD></TR><TR><TD CLASS="l">5356</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">5357</TD><TD>            if (lock == null)</TD></TR><TR><TD CLASS="l">5358</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5359</TD><TD>                    synchronized (sessionLockMap)</TD></TR><TR><TD CLASS="l">5360</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5361</TD><TD>                            lock = sessionLockMap.get(sessionName);</TD></TR><TR><TD CLASS="l">5362</TD><TD>                            </TD></TR><TR CLASS="z"><TD CLASS="l">5363</TD><TD>                            if (lock == null)</TD></TR><TR><TD CLASS="l">5364</TD><TD>                            {</TD></TR><TR CLASS="z"><TD CLASS="l">5365</TD><TD>                                    lock = new Object();</TD></TR><TR><TD CLASS="l">5366</TD><TD>                                    </TD></TR><TR CLASS="z"><TD CLASS="l">5367</TD><TD>                                    sessionLockMap.put(sessionName, lock);</TD></TR><TR><TD CLASS="l">5368</TD><TD>                            }</TD></TR><TR CLASS="z"><TD CLASS="l">5369</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5370</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">5371</TD><TD>            return lock;</TD></TR><TR><TD CLASS="l">5372</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="48">5373</A></TD><TD> </TD></TR><TR><TD CLASS="l">5374</TD><TD>    public TradingSessionElementClassesDetailStruct[] getElementClassesForSessionByGroup(String sessionName, String groupName)</TD></TR><TR><TD CLASS="l">5375</TD><TD>                        throws SystemException, DataValidationException, CommunicationException, AuthorizationException</TD></TR><TR><TD CLASS="l">5376</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5377</TD><TD>                verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">5378</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5379</TD><TD>                int[] classesInGroup = getProductConfigurationService().getProductClassesForGroup(groupName);</TD></TR><TR CLASS="z"><TD CLASS="l">5380</TD><TD>                HashMap&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt; seInfoMap = this.getSessionProdCache(sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">5381</TD><TD>                HashMap&lt;TradingSessionElementInfoStruct, ArrayList&lt;SessionClassDetailStruct&gt;&gt; rtnSEInfoMap = new HashMap&lt;TradingSessionElementInfoStruct, ArrayList&lt;SessionClassDetailStruct&gt;&gt;();</TD></TR><TR><TD CLASS="l">5382</TD><TD>                HashMap sessionClassHash;</TD></TR><TR><TD CLASS="l">5383</TD><TD>                TradingSessionElementClassesDetailStruct aStruct;</TD></TR><TR CLASS="z"><TD CLASS="l">5384</TD><TD>                TradingSessionElementInfoStruct seInfo = null;</TD></TR><TR><TD CLASS="l">5385</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5386</TD><TD>                int i = 0;</TD></TR><TR><TD CLASS="l">5387</TD><TD>                ArrayList&lt;SessionClassDetailStruct&gt; rtnList;</TD></TR><TR CLASS="z"><TD CLASS="l">5388</TD><TD>                for (int m = 0; m &lt; classesInGroup.length; m++)</TD></TR><TR><TD CLASS="l">5389</TD><TD>                {</TD></TR><TR><TD CLASS="l">5390</TD><TD>                        IntHashMap&lt;SessionClassDetailStruct&gt; value;</TD></TR><TR><TD CLASS="l">5391</TD><TD>                        Map.Entry&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt; mapEntry;</TD></TR><TR CLASS="z"><TD CLASS="l">5392</TD><TD>                        for (Iterator&lt;Map.Entry&lt;TradingSessionElementInfoStruct, IntHashMap&lt;SessionClassDetailStruct&gt;&gt;&gt; it = seInfoMap.entrySet().iterator(); it.hasNext(); i++)</TD></TR><TR><TD CLASS="l">5393</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5394</TD><TD>                                mapEntry = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">5395</TD><TD>                                value = mapEntry.getValue();</TD></TR><TR><TD CLASS="l">5396</TD><TD> </TD></TR><TR><TD CLASS="l">5397</TD><TD>                                // check to see if the class is in the element.</TD></TR><TR CLASS="z"><TD CLASS="l">5398</TD><TD>                                SessionClassDetailStruct classDetailStruct = value.get(classesInGroup[m]);</TD></TR><TR CLASS="z"><TD CLASS="l">5399</TD><TD>                                if (null != classDetailStruct)</TD></TR><TR><TD CLASS="l">5400</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">5401</TD><TD>                                        seInfo = mapEntry.getKey();</TD></TR><TR><TD CLASS="l">5402</TD><TD>                                        </TD></TR><TR><TD CLASS="l">5403</TD><TD>                                        // if it is then it will be returned from this method </TD></TR><TR CLASS="z"><TD CLASS="l">5404</TD><TD>                                        rtnList = rtnSEInfoMap.get(seInfo);</TD></TR><TR CLASS="z"><TD CLASS="l">5405</TD><TD>                                        if (null == rtnList)</TD></TR><TR><TD CLASS="l">5406</TD><TD>                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">5407</TD><TD>                                                rtnList = new ArrayList&lt;SessionClassDetailStruct&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">5408</TD><TD>                                                rtnSEInfoMap.put(seInfo, rtnList);</TD></TR><TR><TD CLASS="l">5409</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">5410</TD><TD>                                        rtnList.add(classDetailStruct);</TD></TR><TR><TD CLASS="l">5411</TD><TD>                                        </TD></TR><TR CLASS="z"><TD CLASS="l">5412</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">5413</TD><TD>                                }</TD></TR><TR><TD CLASS="l">5414</TD><TD>                        }</TD></TR><TR><TD CLASS="l">5415</TD><TD>                }</TD></TR><TR><TD CLASS="l">5416</TD><TD> </TD></TR><TR><TD CLASS="l">5417</TD><TD>                // we have classes grouped by session elements in rtnSEInfoMap.</TD></TR><TR><TD CLASS="l">5418</TD><TD>                ArrayList&lt;SessionClassDetailStruct&gt; valueList;</TD></TR><TR CLASS="z"><TD CLASS="l">5419</TD><TD>                ArrayList&lt;TradingSessionElementClassesDetailStruct&gt; finalList = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">5420</TD><TD>                for (Iterator&lt;Entry&lt;TradingSessionElementInfoStruct, ArrayList&lt;SessionClassDetailStruct&gt;&gt;&gt; it = rtnSEInfoMap.entrySet().iterator(); it.hasNext(); i++)</TD></TR><TR><TD CLASS="l">5421</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5422</TD><TD>                        aStruct = new TradingSessionElementClassesDetailStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5423</TD><TD>                        Entry&lt;TradingSessionElementInfoStruct, ArrayList&lt;SessionClassDetailStruct&gt;&gt; mapEntry = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">5424</TD><TD>                        valueList = mapEntry.getValue();</TD></TR><TR><TD CLASS="l">5425</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5426</TD><TD>                        aStruct.sessionClassesDetail = valueList.toArray(new SessionClassDetailStruct[valueList.size()]);</TD></TR><TR CLASS="z"><TD CLASS="l">5427</TD><TD>                        aStruct.tradingSessionElementInfo = mapEntry.getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">5428</TD><TD>                        finalList.add(aStruct);</TD></TR><TR><TD CLASS="l">5429</TD><TD>                }</TD></TR><TR><TD CLASS="l">5430</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5431</TD><TD>                TradingSessionElementClassesDetailStruct[] result = new TradingSessionElementClassesDetailStruct[finalList.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">5432</TD><TD>                finalList.toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l">5433</TD><TD>                return result;</TD></TR><TR><TD CLASS="l">5434</TD><TD>        }</TD></TR><TR><TD CLASS="l">5435</TD><TD>    </TD></TR><TR><TD CLASS="l">5436</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5437</TD><TD>         * Invoke the startEndOfSales when user wants to enable end of sale for the</TD></TR><TR><TD CLASS="l">5438</TD><TD>         * day.</TD></TR><TR><TD CLASS="l">5439</TD><TD>         * </TD></TR><TR><TD CLASS="l">5440</TD><TD>         * @param sessionName</TD></TR><TR><TD CLASS="l">5441</TD><TD>         *            session name</TD></TR><TR><TD CLASS="l">5442</TD><TD>         * @param activeClients</TD></TR><TR><TD CLASS="l">5443</TD><TD>         *            active servers</TD></TR><TR><TD CLASS="l">5444</TD><TD>         * @param inactiveClients</TD></TR><TR><TD CLASS="l">5445</TD><TD>         *            inactive servers</TD></TR><TR><TD CLASS="l">5446</TD><TD>         * @param forceStart</TD></TR><TR><TD CLASS="l">5447</TD><TD>         *            force start flag</TD></TR><TR><TD CLASS="l">5448</TD><TD>         * @param abortOnError</TD></TR><TR><TD CLASS="l">5449</TD><TD>         *            abort on first error flag</TD></TR><TR><TD CLASS="l">5450</TD><TD>         * @throws DataValidationException</TD></TR><TR><TD CLASS="l">5451</TD><TD>         *             Data validation fails then throws</TD></TR><TR><TD CLASS="l">5452</TD><TD>         * @throws TransactionFailedException</TD></TR><TR><TD CLASS="l">5453</TD><TD>         *             Transaction failed then throws</TD></TR><TR><TD CLASS="l">5454</TD><TD>         * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l">5455</TD><TD>         */</TD></TR><TR><TD CLASS="l">5456</TD><TD>    private void startEndOfSales(String sessionName, String[] activeClients, String[] inactiveClients, boolean forceStart, boolean abortOnError) throws DataValidationException, </TD></TR><TR><TD CLASS="l">5457</TD><TD>            TransactionFailedException</TD></TR><TR><TD CLASS="l">5458</TD><TD>    {</TD></TR><TR><TD CLASS="l">5459</TD><TD>        // Create a new thread to start the session.</TD></TR><TR><TD CLASS="l">5460</TD><TD>        // So as to not hold up other timers from dequeing.</TD></TR><TR><TD CLASS="l">5461</TD><TD>        class StartEndOfSalesThread implements Runnable</TD></TR><TR><TD CLASS="l">5462</TD><TD>        {</TD></TR><TR><TD CLASS="l">5463</TD><TD>            TradingSession session;</TD></TR><TR><TD CLASS="l">5464</TD><TD>            String[] activeClients;</TD></TR><TR><TD CLASS="l">5465</TD><TD>            String[] inactiveClients;</TD></TR><TR><TD CLASS="l">5466</TD><TD>            boolean abortOnError;</TD></TR><TR><TD CLASS="l"><A NAME="d5">5467</A></TD><TD>            boolean forceStart;</TD></TR><TR><TD CLASS="l">5468</TD><TD> </TD></TR><TR><TD CLASS="l">5469</TD><TD>            StartEndOfSalesThread(TradingSession aSession, boolean forceStartFlag, </TD></TR><TR><TD CLASS="l">5470</TD><TD>                    boolean abortOnErrorFlag, String[] active, String[] inactive)</TD></TR><TR CLASS="z"><TD CLASS="l">5471</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5472</TD><TD>                this.session = aSession;</TD></TR><TR CLASS="z"><TD CLASS="l">5473</TD><TD>                this.activeClients = active;</TD></TR><TR CLASS="z"><TD CLASS="l">5474</TD><TD>                this.inactiveClients = inactive;</TD></TR><TR CLASS="z"><TD CLASS="l">5475</TD><TD>                this.forceStart = forceStartFlag;</TD></TR><TR CLASS="z"><TD CLASS="l">5476</TD><TD>                this.abortOnError = abortOnErrorFlag;</TD></TR><TR CLASS="z"><TD CLASS="l">5477</TD><TD>            }</TD></TR><TR><TD CLASS="l"><A NAME="d7">5478</A></TD><TD>            public void run()</TD></TR><TR><TD CLASS="l">5479</TD><TD>            {</TD></TR><TR><TD CLASS="l">5480</TD><TD>                // send notice to clients</TD></TR><TR><TD CLASS="l">5481</TD><TD>                TradingSessionClientAction action;</TD></TR><TR CLASS="z"><TD CLASS="l">5482</TD><TD>                TradingSessionStruct sessionStruct = sessionHome.toStruct(session);</TD></TR><TR CLASS="z"><TD CLASS="l">5483</TD><TD>                action = new TradingSessionClientAction(TradingSessionServiceLocalImpl.this, </TD></TR><TR><TD CLASS="l">5484</TD><TD>                        TradingSessionEventType.START_END_OF_SALES,sessionStruct,null, activeClients, </TD></TR><TR><TD CLASS="l">5485</TD><TD>                        inactiveClients);</TD></TR><TR><TD CLASS="l">5486</TD><TD> </TD></TR><TR><TD CLASS="l">5487</TD><TD>                // Wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">5488</TD><TD>                execute(true,action);</TD></TR><TR><TD CLASS="l">5489</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">5490</TD><TD>                if (!action.allClientsComplete())</TD></TR><TR><TD CLASS="l">5491</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5492</TD><TD>                    if (action.nbrExceptions != action.nbrCalled) // at least one was successful.</TD></TR><TR><TD CLASS="l">5493</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5494</TD><TD>                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;End of sale started &#34; +</TD></TR><TR><TD CLASS="l">5495</TD><TD>                                &#34;(but not all servers completed) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">5496</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5497</TD><TD>                    else</TD></TR><TR><TD CLASS="l">5498</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5499</TD><TD>                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Error starting end of sale &#34; +</TD></TR><TR><TD CLASS="l">5500</TD><TD>                                &#34;(ALL SERVERS ARE DOWN) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">5501</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5502</TD><TD>                }</TD></TR><TR><TD CLASS="l">5503</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="b4">5504</A></TD><TD>                releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">5505</TD><TD>            }</TD></TR><TR><TD CLASS="l">5506</TD><TD>        }</TD></TR><TR><TD CLASS="l">5507</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5508</TD><TD>        logMessage(&#34;active servers are&#34;,&#34;&#34;, activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">5509</TD><TD>        logMessage(&#34;inactive servers are&#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">5510</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5511</TD><TD>        TradingSession tradingSession = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">5512</TD><TD> </TD></TR><TR><TD CLASS="l">5513</TD><TD> </TD></TR><TR><TD CLASS="l">5514</TD><TD>        // Sessions only used for underlying products do not have a product state service </TD></TR><TR><TD CLASS="l">5515</TD><TD>        // configured for them, so those sessions cannot be started.</TD></TR><TR CLASS="z"><TD CLASS="l">5516</TD><TD>        if (TradingSessionNameHelper.isUnderlyingSession(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5517</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Cannot start end of sale as session &#34; +</TD></TR><TR><TD CLASS="l">5518</TD><TD>                    &#34;is not used for underlying products&#34;, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">5519</TD><TD>        }</TD></TR><TR><TD CLASS="l">5520</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5521</TD><TD>        if (TradingSessionNameHelper.isNotApplicableSession(sessionName))</TD></TR><TR><TD CLASS="l">5522</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5523</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Cannot start a NOT_APPLICABLE session: &#34; + </TD></TR><TR><TD CLASS="l">5524</TD><TD>                    sessionName, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">5525</TD><TD>        }</TD></TR><TR><TD CLASS="l">5526</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5527</TD><TD>        if (getBusinessDayHome().findCurrent().getState() == BusinessDayStates.STARTED)</TD></TR><TR><TD CLASS="l">5528</TD><TD>        {</TD></TR><TR><TD CLASS="l">5529</TD><TD>            // Need to lock service before starting thread so user will get error if other update </TD></TR><TR><TD CLASS="l">5530</TD><TD>            // in progress Release will be done at end of processing by thread.</TD></TR><TR CLASS="z"><TD CLASS="l">5531</TD><TD>            lockServiceForUpdates(activeClients, &#34;Starting end of sale for session &#34; + sessionName); // LOCK BY CLIENT</TD></TR><TR><TD CLASS="l">5532</TD><TD> </TD></TR><TR><TD CLASS="l">5533</TD><TD>            // Log and tell everyone.</TD></TR><TR CLASS="z"><TD CLASS="l">5534</TD><TD>            Log.information(this,&#34;Starting end of sale : Session(&#34; + tradingSession.getSessionName() + </TD></TR><TR><TD CLASS="l">5535</TD><TD>                    &#34;), Start end of sale timer will be deleted.&#34;);</TD></TR><TR><TD CLASS="l">5536</TD><TD> </TD></TR><TR><TD CLASS="l">5537</TD><TD>            // Create thread and start it.</TD></TR><TR CLASS="z"><TD CLASS="l">5538</TD><TD>            Thread t = new Thread(new StartEndOfSalesThread(tradingSession, forceStart, abortOnError, </TD></TR><TR><TD CLASS="l">5539</TD><TD>                    activeClients, inactiveClients));</TD></TR><TR CLASS="z"><TD CLASS="l">5540</TD><TD>            t.start();</TD></TR><TR CLASS="z"><TD CLASS="l">5541</TD><TD>        }</TD></TR><TR><TD CLASS="l">5542</TD><TD>        else</TD></TR><TR><TD CLASS="l">5543</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5544</TD><TD>            String errorMessage = &#34;End of sale for Session &#34; + sessionName + &#34; could not be started &#34; +</TD></TR><TR><TD CLASS="l">5545</TD><TD>                    &#34;- business day (&#34; + TimeHelper.toDateString(getBusinessDayHome().</TD></TR><TR><TD CLASS="l">5546</TD><TD>                            findCurrent().getDate().getTime()) + &#34;) is not started&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">5547</TD><TD>            Log.alarm(this, errorMessage);</TD></TR><TR CLASS="z"><TD CLASS="l">5548</TD><TD>            throw ExceptionBuilder.dataValidationException(errorMessage, 0);</TD></TR><TR><TD CLASS="l">5549</TD><TD>        }</TD></TR><TR><TD CLASS="l">5550</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5551</TD><TD>    }</TD></TR><TR><TD CLASS="l">5552</TD><TD> </TD></TR><TR><TD CLASS="l">5553</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5554</TD><TD>     * Invoke the startClearEndOfSales when user wants to disable end of sale for the day.</TD></TR><TR><TD CLASS="l">5555</TD><TD>     * @param sessionName session name</TD></TR><TR><TD CLASS="l">5556</TD><TD>     * @param activeClients active servers</TD></TR><TR><TD CLASS="l">5557</TD><TD>     * @param inactiveClients inactive servers</TD></TR><TR><TD CLASS="l">5558</TD><TD>     * @param forceStart force start flag</TD></TR><TR><TD CLASS="l">5559</TD><TD>     * @param abortOnError abort on first error flag</TD></TR><TR><TD CLASS="l">5560</TD><TD>     * @throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">5561</TD><TD>     * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l">5562</TD><TD>     */</TD></TR><TR><TD CLASS="l">5563</TD><TD>    private void startClearEndOfSales(String sessionName, String[] activeClients, </TD></TR><TR><TD CLASS="l">5564</TD><TD>            String[] inactiveClients, boolean forceStart, boolean abortOnError) throws </TD></TR><TR><TD CLASS="l">5565</TD><TD>            DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">5566</TD><TD>    {</TD></TR><TR><TD CLASS="l">5567</TD><TD>        // Create a new thread to start the session.</TD></TR><TR><TD CLASS="l">5568</TD><TD>        // So as to not hold up other timers from dequeing.</TD></TR><TR><TD CLASS="l">5569</TD><TD>        class StartClearEndOfSalesThread implements Runnable</TD></TR><TR><TD CLASS="l">5570</TD><TD>        {</TD></TR><TR><TD CLASS="l">5571</TD><TD>            TradingSession session;</TD></TR><TR><TD CLASS="l">5572</TD><TD>            String[] activeClients;</TD></TR><TR><TD CLASS="l">5573</TD><TD>            String[] inactiveClients;</TD></TR><TR><TD CLASS="l">5574</TD><TD>            boolean abortOnError;</TD></TR><TR><TD CLASS="l"><A NAME="d2">5575</A></TD><TD>            boolean forceStart;</TD></TR><TR><TD CLASS="l">5576</TD><TD> </TD></TR><TR><TD CLASS="l">5577</TD><TD>            StartClearEndOfSalesThread(TradingSession aSession, boolean forceStartFlag, </TD></TR><TR><TD CLASS="l">5578</TD><TD>                    boolean abortOnErrorFlag, String[] active, String[] inactive)</TD></TR><TR CLASS="z"><TD CLASS="l">5579</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5580</TD><TD>                this.session = aSession;</TD></TR><TR CLASS="z"><TD CLASS="l">5581</TD><TD>                this.activeClients = active;</TD></TR><TR CLASS="z"><TD CLASS="l">5582</TD><TD>                this.inactiveClients = inactive;</TD></TR><TR CLASS="z"><TD CLASS="l">5583</TD><TD>                this.forceStart = forceStartFlag;</TD></TR><TR CLASS="z"><TD CLASS="l">5584</TD><TD>                this.abortOnError = abortOnErrorFlag;</TD></TR><TR CLASS="z"><TD CLASS="l">5585</TD><TD>            }</TD></TR><TR><TD CLASS="l"><A NAME="d4">5586</A></TD><TD>            public void run()</TD></TR><TR><TD CLASS="l">5587</TD><TD>            {</TD></TR><TR><TD CLASS="l">5588</TD><TD>                // send notice to clients</TD></TR><TR><TD CLASS="l">5589</TD><TD>                TradingSessionClientAction action;</TD></TR><TR CLASS="z"><TD CLASS="l">5590</TD><TD>                TradingSessionStruct sessionStruct = sessionHome.toStruct(session);</TD></TR><TR CLASS="z"><TD CLASS="l">5591</TD><TD>                action = new TradingSessionClientAction(TradingSessionServiceLocalImpl.this, </TD></TR><TR><TD CLASS="l">5592</TD><TD>                        TradingSessionEventType.START_CLEAR_END_OF_SALES,sessionStruct,null, </TD></TR><TR><TD CLASS="l">5593</TD><TD>                        activeClients, inactiveClients);</TD></TR><TR><TD CLASS="l">5594</TD><TD> </TD></TR><TR><TD CLASS="l">5595</TD><TD>                // Wait for completion.</TD></TR><TR CLASS="z"><TD CLASS="l">5596</TD><TD>                execute(true,action);</TD></TR><TR><TD CLASS="l">5597</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">5598</TD><TD>                if (!action.allClientsComplete())</TD></TR><TR><TD CLASS="l">5599</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5600</TD><TD>                    if (action.nbrExceptions != action.nbrCalled) // at least one was successful.</TD></TR><TR><TD CLASS="l">5601</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5602</TD><TD>                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Clear End of sale started &#34; +</TD></TR><TR><TD CLASS="l">5603</TD><TD>                                &#34;(but not all servers completed) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">5604</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5605</TD><TD>                    else</TD></TR><TR><TD CLASS="l">5606</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5607</TD><TD>                        Log.alarm(TradingSessionServiceLocalImpl.this,&#34;Error starting &#34; +</TD></TR><TR><TD CLASS="l">5608</TD><TD>                                &#34;clear end of sale (ALL SERVERS ARE DOWN) : &#34; + action.toString());</TD></TR><TR><TD CLASS="l">5609</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5610</TD><TD>                }</TD></TR><TR><TD CLASS="l">5611</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="ae">5612</A></TD><TD>                releaseUpdateLock(activeClients); // RELEASE BY CLIENT</TD></TR><TR CLASS="z"><TD CLASS="l">5613</TD><TD>            }</TD></TR><TR><TD CLASS="l">5614</TD><TD>        }</TD></TR><TR><TD CLASS="l">5615</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5616</TD><TD>        logMessage(&#34;active servers are&#34;,&#34;&#34;, activeClients);</TD></TR><TR CLASS="z"><TD CLASS="l">5617</TD><TD>        logMessage(&#34;inactive servers are&#34;, &#34;&#34;, inactiveClients);</TD></TR><TR><TD CLASS="l">5618</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5619</TD><TD>        TradingSession session = verifySessionName(sessionName);</TD></TR><TR><TD CLASS="l">5620</TD><TD> </TD></TR><TR><TD CLASS="l">5621</TD><TD> </TD></TR><TR><TD CLASS="l">5622</TD><TD>        // Sessions only used for underlying products do not have a product state service </TD></TR><TR><TD CLASS="l">5623</TD><TD>        // configured for them, so those sessions cannot be started.</TD></TR><TR CLASS="z"><TD CLASS="l">5624</TD><TD>        if (TradingSessionNameHelper.isUnderlyingSession(sessionName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5625</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Cannot start clear end of sale as &#34; +</TD></TR><TR><TD CLASS="l">5626</TD><TD>                &#34;session is not used for underlying products&#34;, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">5627</TD><TD>        }</TD></TR><TR><TD CLASS="l">5628</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5629</TD><TD>        if (TradingSessionNameHelper.isNotApplicableSession(sessionName))</TD></TR><TR><TD CLASS="l">5630</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5631</TD><TD>            throw ExceptionBuilder.dataValidationException(&#34;Cannot start a NOT_APPLICABLE session: &#34; + </TD></TR><TR><TD CLASS="l">5632</TD><TD>                    sessionName, DataValidationCodes.INVALID_SESSION);</TD></TR><TR><TD CLASS="l">5633</TD><TD>        }</TD></TR><TR><TD CLASS="l">5634</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5635</TD><TD>        if (getBusinessDayHome().findCurrent().getState() == BusinessDayStates.STARTED)</TD></TR><TR><TD CLASS="l">5636</TD><TD>        {</TD></TR><TR><TD CLASS="l">5637</TD><TD>            // Need to lock service before starting thread so user will get error if other update </TD></TR><TR><TD CLASS="l">5638</TD><TD>            // in progress Release will be done at end of processing by thread.</TD></TR><TR CLASS="z"><TD CLASS="l">5639</TD><TD>            lockServiceForUpdates(activeClients, &#34;Starting clear end of sale &#34; + sessionName); // LOCK BY CLIENT</TD></TR><TR><TD CLASS="l">5640</TD><TD> </TD></TR><TR><TD CLASS="l">5641</TD><TD>            // Log and tell everyone.</TD></TR><TR CLASS="z"><TD CLASS="l">5642</TD><TD>            Log.information(this,&#34;Starting clear end of sale : Session(&#34; + session.getSessionName() + </TD></TR><TR><TD CLASS="l">5643</TD><TD>                    &#34;), Start clear end of sale timer will be deleted.&#34;);</TD></TR><TR><TD CLASS="l">5644</TD><TD> </TD></TR><TR><TD CLASS="l">5645</TD><TD>            // Create thread and start it.</TD></TR><TR CLASS="z"><TD CLASS="l">5646</TD><TD>            Thread t = new Thread(new StartClearEndOfSalesThread(session, forceStart, abortOnError, </TD></TR><TR><TD CLASS="l">5647</TD><TD>                    activeClients, inactiveClients));</TD></TR><TR CLASS="z"><TD CLASS="l">5648</TD><TD>            t.start();</TD></TR><TR CLASS="z"><TD CLASS="l">5649</TD><TD>        }</TD></TR><TR><TD CLASS="l">5650</TD><TD>        else</TD></TR><TR><TD CLASS="l">5651</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5652</TD><TD>            String errorMessage = &#34;End of sale for Session &#34; + sessionName + &#34; could not be started &#34; +</TD></TR><TR><TD CLASS="l">5653</TD><TD>                    &#34;- business day (&#34; + TimeHelper.toDateString(getBusinessDayHome()</TD></TR><TR><TD CLASS="l">5654</TD><TD>                            .findCurrent().getDate().getTime()) + &#34;) is not started&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">5655</TD><TD>            Log.alarm(this, errorMessage);</TD></TR><TR CLASS="z"><TD CLASS="l">5656</TD><TD>            throw ExceptionBuilder.dataValidationException(errorMessage, 0);</TD></TR><TR><TD CLASS="l">5657</TD><TD>        }</TD></TR><TR><TD CLASS="l">5658</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5659</TD><TD>    }</TD></TR><TR><TD CLASS="l">5660</TD><TD>    </TD></TR><TR><TD CLASS="l">5661</TD><TD>   /**</TD></TR><TR><TD CLASS="l">5662</TD><TD>    * This method invoked when serverNames are available for end of sale. Active clients are </TD></TR><TR><TD CLASS="l">5663</TD><TD>    * considered as servernames and Inactive clients are not available.</TD></TR><TR><TD CLASS="l">5664</TD><TD>    * @param String sessionName  </TD></TR><TR><TD CLASS="l">5665</TD><TD>    * @param String[] serverNames </TD></TR><TR><TD CLASS="l">5666</TD><TD>    * @param boolean forceStart </TD></TR><TR><TD CLASS="l">5667</TD><TD>    * @param boolean abortOnError </TD></TR><TR><TD CLASS="l">5668</TD><TD>    * @throws DataValidationException,TransactionFailedException</TD></TR><TR><TD CLASS="l">5669</TD><TD>    * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l">5670</TD><TD>    */</TD></TR><TR><TD CLASS="l"><A NAME="b6">5671</A></TD><TD>   public void startEndOfSalesForServers(String sessionName, boolean forceStart, </TD></TR><TR><TD CLASS="l">5672</TD><TD>           boolean abortOnError, String[] serverNames) throws DataValidationException, </TD></TR><TR><TD CLASS="l">5673</TD><TD>           TransactionFailedException</TD></TR><TR><TD CLASS="l">5674</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">5675</TD><TD>       logMessage(&#34;startEndOfSalesForServers is called. With session/servernames: &#34;, sessionName, </TD></TR><TR><TD CLASS="l">5676</TD><TD>               serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">5677</TD><TD>       validateServerNamesWithSession(sessionName, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">5678</TD><TD>       startEndOfSales(sessionName, serverNames, new String[0], forceStart, abortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">5679</TD><TD>   }</TD></TR><TR><TD CLASS="l">5680</TD><TD>   </TD></TR><TR><TD CLASS="l">5681</TD><TD>   /**</TD></TR><TR><TD CLASS="l">5682</TD><TD>    * This method invoked when serverNames are available for clear end of sale. Active clients are </TD></TR><TR><TD CLASS="l">5683</TD><TD>    * considered as servernames and Inactive clients are not available.</TD></TR><TR><TD CLASS="l">5684</TD><TD>    * @param String sessionName </TD></TR><TR><TD CLASS="l">5685</TD><TD>    * @param String[] serverNames </TD></TR><TR><TD CLASS="l">5686</TD><TD>    * @param boolean forceStart </TD></TR><TR><TD CLASS="l">5687</TD><TD>    * @param boolean abortOnError </TD></TR><TR><TD CLASS="l">5688</TD><TD>    * @throws DataValidationException,TransactionFailedException</TD></TR><TR><TD CLASS="l">5689</TD><TD>    * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l">5690</TD><TD>    */</TD></TR><TR><TD CLASS="l"><A NAME="b0">5691</A></TD><TD>   public void startClearEndOfSalesForServers(String sessionName, boolean forceStart, </TD></TR><TR><TD CLASS="l">5692</TD><TD>           boolean abortOnError, String[] serverNames) throws DataValidationException, </TD></TR><TR><TD CLASS="l">5693</TD><TD>           TransactionFailedException</TD></TR><TR><TD CLASS="l">5694</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">5695</TD><TD>       logMessage(&#34;startClearEndOfSalesForServers is called.With session/servernames: &#34;, sessionName, </TD></TR><TR><TD CLASS="l">5696</TD><TD>               serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">5697</TD><TD>       validateServerNamesWithSession(sessionName, serverNames);</TD></TR><TR CLASS="z"><TD CLASS="l">5698</TD><TD>       startClearEndOfSales(sessionName, serverNames, new String[0], forceStart, abortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">5699</TD><TD>   }</TD></TR><TR><TD CLASS="l">5700</TD><TD>   </TD></TR><TR><TD CLASS="l">5701</TD><TD>   /**</TD></TR><TR><TD CLASS="l">5702</TD><TD>    * This method invoked when serverNames are not passed/available for end of sale. Active and </TD></TR><TR><TD CLASS="l">5703</TD><TD>    * inactive clients are evaluated from RegistrationMapHome.</TD></TR><TR><TD CLASS="l">5704</TD><TD>    * @param sessionName session name </TD></TR><TR><TD CLASS="l">5705</TD><TD>    * @param forceStart force start flag</TD></TR><TR><TD CLASS="l">5706</TD><TD>    * @param abortOnError abort on first error flag</TD></TR><TR><TD CLASS="l">5707</TD><TD>    * @throws DataValidationException,TransactionFailedException</TD></TR><TR><TD CLASS="l">5708</TD><TD>    * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l"><A NAME="b5">5709</A></TD><TD>    */</TD></TR><TR><TD CLASS="l">5710</TD><TD>   public void startEndOfSales(String sessionName, boolean forceStart, boolean abortOnError) throws </TD></TR><TR><TD CLASS="l">5711</TD><TD>                                                   DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">5712</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">5713</TD><TD>       logMessage(&#34;startEndOfSale is called with session &#34;, sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">5714</TD><TD>       startEndOfSales(sessionName, </TD></TR><TR><TD CLASS="l">5715</TD><TD>               registrationMapHome.getActiveClientsForSession(sessionName), </TD></TR><TR><TD CLASS="l">5716</TD><TD>               registrationMapHome.getInactiveClientsForSession(sessionName),</TD></TR><TR><TD CLASS="l">5717</TD><TD>               forceStart, abortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">5718</TD><TD>   }</TD></TR><TR><TD CLASS="l">5719</TD><TD>   </TD></TR><TR><TD CLASS="l">5720</TD><TD>   /**</TD></TR><TR><TD CLASS="l">5721</TD><TD>    * This method invoked when serverNames are not passed/available for clear end of sale. Active and </TD></TR><TR><TD CLASS="l">5722</TD><TD>    * inactive clients are evaluated from RegistrationMapHome.</TD></TR><TR><TD CLASS="l">5723</TD><TD>    * @param String sessionName </TD></TR><TR><TD CLASS="l">5724</TD><TD>    * @param String forceStart </TD></TR><TR><TD CLASS="l">5725</TD><TD>    * @param boolean abortOnError </TD></TR><TR><TD CLASS="l">5726</TD><TD>    * @throws DataValidationException,TransactionFailedException</TD></TR><TR><TD CLASS="l">5727</TD><TD>    * @author Cognizant Technology Solutions</TD></TR><TR><TD CLASS="l"><A NAME="af">5728</A></TD><TD>    */</TD></TR><TR><TD CLASS="l">5729</TD><TD>   public void startClearEndOfSales(String sessionName, boolean forceStart, boolean abortOnError) </TD></TR><TR><TD CLASS="l">5730</TD><TD>                                       throws DataValidationException, TransactionFailedException</TD></TR><TR><TD CLASS="l">5731</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">5732</TD><TD>       logMessage(&#34;startClearEndOfSale is called with session &#34;, sessionName);</TD></TR><TR CLASS="z"><TD CLASS="l">5733</TD><TD>       startClearEndOfSales(sessionName, </TD></TR><TR><TD CLASS="l">5734</TD><TD>               registrationMapHome.getActiveClientsForSession(sessionName),</TD></TR><TR><TD CLASS="l">5735</TD><TD>               registrationMapHome.getInactiveClientsForSession(sessionName), </TD></TR><TR><TD CLASS="l">5736</TD><TD>               forceStart, abortOnError);</TD></TR><TR CLASS="z"><TD CLASS="l">5737</TD><TD>   }</TD></TR><TR><TD CLASS="l">5738</TD><TD>   </TD></TR><TR><TD CLASS="l">5739</TD><TD>   /**</TD></TR><TR><TD CLASS="l">5740</TD><TD>    * Method checks the status for all the sessions i.e CLOSED or OPEN.</TD></TR><TR><TD CLASS="l">5741</TD><TD>    * Retruns back the session status true(all sessions CLOSED) or false(any session is OPEN).</TD></TR><TR><TD CLASS="l">5742</TD><TD>    * </TD></TR><TR><TD CLASS="l">5743</TD><TD>    * @return boolean (sessionClosedFlag)</TD></TR><TR><TD CLASS="l">5744</TD><TD>    * </TD></TR><TR><TD CLASS="l"><A NAME="14">5745</A></TD><TD>    * @author Cognizant Technology Solutions.</TD></TR><TR><TD CLASS="l">5746</TD><TD>    */</TD></TR><TR><TD CLASS="l">5747</TD><TD>   public boolean areAllSessionsClosedOptimized()</TD></TR><TR><TD CLASS="l">5748</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">5749</TD><TD>       if(sessionClosedFlag==null)</TD></TR><TR><TD CLASS="l">5750</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5751</TD><TD>            sessionClosedFlag = areAllSessionsClosed();</TD></TR><TR CLASS="z"><TD CLASS="l">5752</TD><TD>            return sessionClosedFlag;</TD></TR><TR><TD CLASS="l">5753</TD><TD>        }</TD></TR><TR><TD CLASS="l">5754</TD><TD>        else</TD></TR><TR><TD CLASS="l">5755</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5756</TD><TD>            return sessionClosedFlag;</TD></TR><TR><TD CLASS="l">5757</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="56">5758</A></TD><TD>   }</TD></TR><TR><TD CLASS="l">5759</TD><TD>     </TD></TR><TR><TD CLASS="l">5760</TD><TD>    public PendingOrderStruct[] getPendingAdjustmentOrders(String p_sessionName) throws SystemException, CommunicationException, DataValidationException, AuthorizationException</TD></TR><TR><TD CLASS="l">5761</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5762</TD><TD>        PendingAdjustmentStruct[] pendingAdjustments = getPendingAdjustments();</TD></TR><TR CLASS="z"><TD CLASS="l">5763</TD><TD>        PriceAdjustmentStruct anAdjustmentStruct = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5764</TD><TD>        OrderStruct[] currentOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5765</TD><TD>        OrderStruct[] adjustedProductOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5766</TD><TD>        PendingOrderStruct[] adjustedOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5767</TD><TD>        PendingOrderStruct[] filteredAdjustedOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5768</TD><TD>        PendingOrderReportStruct[] adjustedReportOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5769</TD><TD>        PendingOrderStruct[] totalOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5770</TD><TD>        PendingOrderReportStruct[] totalReportOrders = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5771</TD><TD>        List&lt;PendingOrderStruct[]&gt; allAdjustedOrders = new ArrayList&lt;PendingOrderStruct[]&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">5772</TD><TD>        List&lt;PendingOrderReportStruct[]&gt; allAdjustedReportOrders = new ArrayList&lt;PendingOrderReportStruct[]&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">5773</TD><TD>        int totalOrdersSize = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">5774</TD><TD>        List&lt;Integer&gt; pendingSpreadKeys =  new ArrayList&lt;Integer&gt;(1024);</TD></TR><TR><TD CLASS="l">5775</TD><TD>        </TD></TR><TR><TD CLASS="l">5776</TD><TD>        // build Pending Spread Product Keys</TD></TR><TR CLASS="z"><TD CLASS="l">5777</TD><TD>        for(int i =0; i &lt; pendingAdjustments.length; i++) </TD></TR><TR><TD CLASS="l">5778</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5779</TD><TD>            pendingSpreadKeys = buildPendingStrategyProductKeys(pendingAdjustments[i], pendingSpreadKeys);</TD></TR><TR><TD CLASS="l">5780</TD><TD>        }</TD></TR><TR><TD CLASS="l">5781</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5782</TD><TD>        for(int i=0; i &lt; pendingAdjustments.length; i++) </TD></TR><TR><TD CLASS="l">5783</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5784</TD><TD>            boolean timeToApply = isTimetoApply(pendingAdjustments[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">5785</TD><TD>            if(pendingAdjustments[i].active &amp;&amp; timeToApply)</TD></TR><TR><TD CLASS="l">5786</TD><TD>            {</TD></TR><TR><TD CLASS="l">5787</TD><TD>                try</TD></TR><TR><TD CLASS="l">5788</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5789</TD><TD>                    ProductStruct products[] = getProductQueryService().getProductsByClass(pendingAdjustments[i].classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5790</TD><TD>                    if (products.length == 0) { </TD></TR><TR CLASS="z"><TD CLASS="l">5791</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">5792</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">5793</TD><TD>                    anAdjustmentStruct = getProductMaintenanceService().getPriceAdjustment(pendingAdjustments[i].classKey, true);</TD></TR><TR CLASS="z"><TD CLASS="l">5794</TD><TD>                    if (anAdjustmentStruct == null)</TD></TR><TR><TD CLASS="l">5795</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">5796</TD><TD>                        Log.information(&#34;no priceAdjustments found for PendingAdjustment on class &#34; + pendingAdjustments[i].classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5797</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">5798</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5799</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">5800</TD><TD>                catch (NotFoundException e)</TD></TR><TR><TD CLASS="l">5801</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5802</TD><TD>                    Log.information(this, &#34;No price adjustments pending for class&#34; + pendingAdjustments[i].classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5803</TD><TD>                    continue;</TD></TR><TR CLASS="z"><TD CLASS="l">5804</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">5805</TD><TD>                adjustedOrders = getOrderHandlingService().getPendingAdjustmentOrders(p_sessionName, pendingAdjustments[i].classKey);                                </TD></TR><TR><TD CLASS="l">5806</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">5807</TD><TD>               if( (!getEnabledOrderCancelling() &amp; pendingAdjustments[i].type == PriceAdjustmentTypes.LEAP_ROLLOVER)</TD></TR><TR><TD CLASS="l">5808</TD><TD>                    || pendingAdjustments[i].type == PriceAdjustmentTypes.SYMBOL_CHANGE) </TD></TR><TR><TD CLASS="l">5809</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5810</TD><TD>                     filteredAdjustedOrders = filterOrdersWithNonAdjustedProducts(adjustedOrders, pendingAdjustments[i], pendingSpreadKeys);</TD></TR><TR><TD CLASS="l">5811</TD><TD>                }                </TD></TR><TR><TD CLASS="l">5812</TD><TD>                else</TD></TR><TR><TD CLASS="l">5813</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">5814</TD><TD>                    filteredAdjustedOrders = adjustedOrders; // process order for class.</TD></TR><TR><TD CLASS="l">5815</TD><TD>                }</TD></TR><TR><TD CLASS="l">5816</TD><TD>               </TD></TR><TR CLASS="z"><TD CLASS="l">5817</TD><TD>                adjustedReportOrders = getAdjustedReportOrders(filteredAdjustedOrders, anAdjustmentStruct, pendingAdjustments[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">5818</TD><TD>                if(adjustedReportOrders != null &amp;&amp; adjustedOrders.length &gt; 0 ) {</TD></TR><TR CLASS="z"><TD CLASS="l">5819</TD><TD>                    totalOrdersSize += filteredAdjustedOrders.length;</TD></TR><TR CLASS="z"><TD CLASS="l">5820</TD><TD>                    allAdjustedOrders.add(filteredAdjustedOrders);</TD></TR><TR CLASS="z"><TD CLASS="l">5821</TD><TD>                    allAdjustedReportOrders.add(adjustedReportOrders);</TD></TR><TR><TD CLASS="l">5822</TD><TD>                }</TD></TR><TR><TD CLASS="l">5823</TD><TD>            }</TD></TR><TR><TD CLASS="l">5824</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5825</TD><TD>        if(allAdjustedOrders.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">5826</TD><TD>            totalOrders = getTotalPendingOrders(allAdjustedOrders, totalOrdersSize);</TD></TR><TR CLASS="z"><TD CLASS="l">5827</TD><TD>            totalReportOrders = getTotalPendingReportOrders(allAdjustedReportOrders, totalOrdersSize);</TD></TR><TR CLASS="z"><TD CLASS="l">5828</TD><TD>            if(totalOrders != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">5829</TD><TD>                adjustedOrdersLogger.logAdjustedOrdersByFirm(p_sessionName, totalReportOrders);</TD></TR><TR><TD CLASS="l">5830</TD><TD>            }</TD></TR><TR><TD CLASS="l">5831</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5832</TD><TD>        return totalOrders;</TD></TR><TR><TD CLASS="l">5833</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="28">5834</A></TD><TD>   </TD></TR><TR><TD CLASS="l">5835</TD><TD>    private PendingOrderStruct[] filterOrdersWithNonAdjustedProducts( PendingOrderStruct[] adjustedOrders,</TD></TR><TR><TD CLASS="l">5836</TD><TD>            PendingAdjustmentStruct pendingAdjustmentStruct, List&lt;Integer&gt; pendingSpreadKeys) </TD></TR><TR><TD CLASS="l">5837</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5838</TD><TD>        List&lt;PendingOrderStruct&gt; filteredList = new ArrayList&lt;PendingOrderStruct&gt;();        </TD></TR><TR CLASS="z"><TD CLASS="l">5839</TD><TD>        int productKey = 0;</TD></TR><TR><TD CLASS="l">5840</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">5841</TD><TD>        for(int i =0; i&lt; adjustedOrders.length; i++)</TD></TR><TR><TD CLASS="l">5842</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5843</TD><TD>            productKey = adjustedOrders[i].currentOrder.productKey;</TD></TR><TR><TD CLASS="l">5844</TD><TD>            // Is complex order, check productKey is a pending product</TD></TR><TR CLASS="z"><TD CLASS="l">5845</TD><TD>            if(adjustedOrders[i].currentOrder.productType == ProductTypes.STRATEGY)</TD></TR><TR><TD CLASS="l">5846</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5847</TD><TD>                if(pendingSpreadKeys.contains(productKey) == false) {</TD></TR><TR CLASS="z"><TD CLASS="l">5848</TD><TD>                    continue;</TD></TR><TR><TD CLASS="l">5849</TD><TD>                }</TD></TR><TR><TD CLASS="l">5850</TD><TD>            }</TD></TR><TR><TD CLASS="l">5851</TD><TD>            else </TD></TR><TR><TD CLASS="l">5852</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5853</TD><TD>                if(isPendingProduct(pendingAdjustmentStruct, productKey) == false) {</TD></TR><TR CLASS="z"><TD CLASS="l">5854</TD><TD>                    continue; //Implies this product is not adjusted in the pending product list, ignore it.</TD></TR><TR><TD CLASS="l">5855</TD><TD>                }</TD></TR><TR><TD CLASS="l">5856</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">5857</TD><TD>            filteredList.add(adjustedOrders[i]);</TD></TR><TR><TD CLASS="l">5858</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5859</TD><TD>        return filteredList.toArray(new PendingOrderStruct[filteredList.size()]);</TD></TR><TR><TD CLASS="l"><A NAME="1f">5860</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5861</TD><TD> </TD></TR><TR><TD CLASS="l">5862</TD><TD>    private PendingOrderStruct[] convertToPendingOrderStruct(PendingNameStruct pendingNameStruct, OrderStruct[] currentOrders, OrderStruct[] adjustedProductOrders) </TD></TR><TR><TD CLASS="l">5863</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5864</TD><TD>        PendingOrderStruct[] returnOrders = new PendingOrderStruct[adjustedProductOrders.length]; ;</TD></TR><TR CLASS="z"><TD CLASS="l">5865</TD><TD>        for(int i=0; i&lt; adjustedProductOrders.length; i++) </TD></TR><TR><TD CLASS="l">5866</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5867</TD><TD>            returnOrders[i] = buildPendingOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5868</TD><TD>            returnOrders[i].currentOrder = currentOrders[i];</TD></TR><TR CLASS="z"><TD CLASS="l">5869</TD><TD>            returnOrders[i].pendingOrder = adjustedProductOrders[i];</TD></TR><TR CLASS="z"><TD CLASS="l">5870</TD><TD>            returnOrders[i].pendingProductName = pendingNameStruct;</TD></TR><TR><TD CLASS="l">5871</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5872</TD><TD>        return returnOrders;</TD></TR><TR><TD CLASS="l"><A NAME="16">5873</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5874</TD><TD> </TD></TR><TR><TD CLASS="l">5875</TD><TD>    private PendingOrderStruct buildPendingOrderStruct() </TD></TR><TR><TD CLASS="l">5876</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5877</TD><TD>        PendingOrderStruct pendingOrder = new PendingOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5878</TD><TD>        pendingOrder.currentOrder = OrderStructBuilder.buildOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5879</TD><TD>        pendingOrder.pendingOrder = OrderStructBuilder.buildOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5880</TD><TD>        pendingOrder.pendingProductName = new PendingNameStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5881</TD><TD>        pendingOrder.pendingProductName.productStruct = ProductStructBuilder.buildProductStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5882</TD><TD>        pendingOrder.pendingProductName.pendingProductName = ProductStructBuilder.buildProductNameStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5883</TD><TD>        return pendingOrder;</TD></TR><TR><TD CLASS="l"><A NAME="2e">5884</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5885</TD><TD> </TD></TR><TR><TD CLASS="l">5886</TD><TD>    private PendingOrderReportStruct[] getAdjustedReportOrders(PendingOrderStruct[] p_adjustedOrders, PriceAdjustmentStruct p_anAdjustmentStruct, PendingAdjustmentStruct pendingAdjustmentStruct) throws SystemException, CommunicationException, DataValidationException, AuthorizationException </TD></TR><TR><TD CLASS="l">5887</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5888</TD><TD>        if(p_adjustedOrders == null){</TD></TR><TR CLASS="z"><TD CLASS="l">5889</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">5890</TD><TD>        }</TD></TR><TR><TD CLASS="l">5891</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5892</TD><TD>        PendingOrderReportStruct[] returnOrders = new PendingOrderReportStruct[p_adjustedOrders.length];</TD></TR><TR CLASS="z"><TD CLASS="l">5893</TD><TD>        for (int i = 0; i&lt; p_adjustedOrders.length; i++)</TD></TR><TR><TD CLASS="l">5894</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5895</TD><TD>            returnOrders[i] = buildPendingOrderReportStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">5896</TD><TD>            returnOrders[i].currentOrder = p_adjustedOrders[i].currentOrder;</TD></TR><TR CLASS="z"><TD CLASS="l">5897</TD><TD>            returnOrders[i].pendingOrder = p_adjustedOrders[i].pendingOrder;</TD></TR><TR CLASS="z"><TD CLASS="l">5898</TD><TD>            fillPendingProductName(returnOrders[i], pendingAdjustmentStruct);</TD></TR><TR CLASS="z"><TD CLASS="l">5899</TD><TD>            returnOrders[i].priceAdjustment = populatePriceAdjustment(p_anAdjustmentStruct);</TD></TR><TR CLASS="z"><TD CLASS="l">5900</TD><TD>            int[] prodKeys = new int [1];</TD></TR><TR CLASS="z"><TD CLASS="l">5901</TD><TD>            prodKeys[0] = p_adjustedOrders[i].currentOrder.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">5902</TD><TD>            PriceAdjustmentClassStruct[] adjustedClasses = new PriceAdjustmentClassStruct[1];            </TD></TR><TR CLASS="z"><TD CLASS="l">5903</TD><TD>            returnOrders[i].priceAdjustment.adjustedClasses = adjustedClasses;                </TD></TR><TR CLASS="z"><TD CLASS="l">5904</TD><TD>            adjustedClasses[0] = ProductStructBuilder.buildPriceAdjustmentClassStruct();</TD></TR><TR><TD CLASS="l">5905</TD><TD>            </TD></TR><TR CLASS="z"><TD CLASS="l">5906</TD><TD>            int productRCKey = getProductQueryService().getProductsByKey(prodKeys)[0].productKeys.reportingClass;</TD></TR><TR CLASS="z"><TD CLASS="l">5907</TD><TD>            for(int j=0; j &lt; p_anAdjustmentStruct.adjustedClasses.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">5908</TD><TD>                                if(p_anAdjustmentStruct.adjustedClasses[j].classKey == productRCKey) {</TD></TR><TR CLASS="z"><TD CLASS="l">5909</TD><TD>                            adjustedClasses[0] = p_anAdjustmentStruct.adjustedClasses[j];</TD></TR><TR CLASS="z"><TD CLASS="l">5910</TD><TD>                                                returnOrders[i].priceAdjustment.adjustedClasses = adjustedClasses;</TD></TR><TR CLASS="z"><TD CLASS="l">5911</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">5912</TD><TD>                    }</TD></TR><TR><TD CLASS="l">5913</TD><TD>            }</TD></TR><TR><TD CLASS="l">5914</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5915</TD><TD>        return returnOrders;</TD></TR><TR><TD CLASS="l"><A NAME="27">5916</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5917</TD><TD> </TD></TR><TR><TD CLASS="l">5918</TD><TD>    private void fillPendingProductName(PendingOrderReportStruct pendingOrderReportStruct, PendingAdjustmentStruct pendingAdjustments)</TD></TR><TR><TD CLASS="l">5919</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5920</TD><TD>            for(int i =0; i&lt; pendingAdjustments.productsPending.length; i++)</TD></TR><TR><TD CLASS="l">5921</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5922</TD><TD>            if(pendingAdjustments.productsPending[i].productStruct.productKeys.productKey == pendingOrderReportStruct.pendingOrder.productKey) </TD></TR><TR><TD CLASS="l">5923</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5924</TD><TD>                    pendingOrderReportStruct.pendingProductName.pendingProductName = pendingAdjustments.productsPending[i].pendingProductName;</TD></TR><TR CLASS="z"><TD CLASS="l">5925</TD><TD>                    pendingOrderReportStruct.pendingProductName.productStruct = pendingAdjustments.productsPending[i].productStruct ;</TD></TR><TR><TD CLASS="l">5926</TD><TD>            }</TD></TR><TR><TD CLASS="l">5927</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="80">5928</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">5929</TD><TD> </TD></TR><TR><TD CLASS="l">5930</TD><TD>        private boolean isPendingProduct(PendingAdjustmentStruct pendingAdjustments, int productKey) </TD></TR><TR><TD CLASS="l">5931</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5932</TD><TD>        boolean isPending = false;</TD></TR><TR CLASS="z"><TD CLASS="l">5933</TD><TD>        for(int i =0; i&lt; pendingAdjustments.productsPending.length; i++)</TD></TR><TR><TD CLASS="l">5934</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5935</TD><TD>            if(pendingAdjustments.productsPending[i].productStruct.productKeys.productKey == productKey) </TD></TR><TR><TD CLASS="l">5936</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5937</TD><TD>                isPending = true;</TD></TR><TR CLASS="z"><TD CLASS="l">5938</TD><TD>                break;</TD></TR><TR><TD CLASS="l">5939</TD><TD>            }</TD></TR><TR><TD CLASS="l">5940</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5941</TD><TD>        return isPending;</TD></TR><TR><TD CLASS="l"><A NAME="17">5942</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5943</TD><TD>    </TD></TR><TR><TD CLASS="l">5944</TD><TD>    private List&lt;Integer&gt; buildPendingStrategyProductKeys(PendingAdjustmentStruct pendingAdjustments, List&lt;Integer&gt; fileteredPendingStrategyKeys)</TD></TR><TR><TD CLASS="l">5945</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5946</TD><TD>        List&lt;StrategyStruct[]&gt; allPendingStrategies = new ArrayList&lt;StrategyStruct[]&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">5947</TD><TD>        StrategyStruct[] strategiesByComponent = null;</TD></TR><TR CLASS="z"><TD CLASS="l">5948</TD><TD>        int totalStrategiesCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">5949</TD><TD>        int productKey = 0;</TD></TR><TR><TD CLASS="l">5950</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">5951</TD><TD>        for(int i =0; i &lt; pendingAdjustments.productsPending.length; i++)</TD></TR><TR><TD CLASS="l">5952</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5953</TD><TD>            productKey = pendingAdjustments.productsPending[i].productStruct.productKeys.productKey;</TD></TR><TR><TD CLASS="l">5954</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">5955</TD><TD>                strategiesByComponent = getProductQueryService().getStrategiesByComponent(productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">5956</TD><TD>                totalStrategiesCount = totalStrategiesCount + strategiesByComponent.length;</TD></TR><TR CLASS="z"><TD CLASS="l">5957</TD><TD>                allPendingStrategies.add(strategiesByComponent);</TD></TR><TR CLASS="z"><TD CLASS="l">5958</TD><TD>            } catch (SystemException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5959</TD><TD>                Log.information(&#34;Couldn't find Strategies for Pending Product[&#34; + productKey + &#34;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5960</TD><TD>            } catch (CommunicationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5961</TD><TD>                Log.information(&#34;Couldn't find Strategies for Pending Product[&#34; + productKey + &#34;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5962</TD><TD>            } catch (AuthorizationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5963</TD><TD>                Log.information(&#34;Couldn't find Strategies for Pending Product[&#34; + productKey + &#34;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5964</TD><TD>            } catch (DataValidationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5965</TD><TD>                Log.information(&#34;Couldn't find Strategies for Pending Product[&#34; + productKey + &#34;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5966</TD><TD>            }</TD></TR><TR><TD CLASS="l">5967</TD><TD>        }</TD></TR><TR><TD CLASS="l">5968</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">5969</TD><TD>        StrategyStruct[] allStrategies = new StrategyStruct[totalStrategiesCount]; </TD></TR><TR CLASS="z"><TD CLASS="l">5970</TD><TD>        int totalOrdersSize = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">5971</TD><TD>        for (int l = 0; l &lt; allPendingStrategies.size(); l++)</TD></TR><TR><TD CLASS="l">5972</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5973</TD><TD>            System.arraycopy(allPendingStrategies.get(l), 0, allStrategies, totalOrdersSize, allPendingStrategies.get(l).length);</TD></TR><TR CLASS="z"><TD CLASS="l">5974</TD><TD>            totalOrdersSize += allPendingStrategies.get(l).length;</TD></TR><TR><TD CLASS="l">5975</TD><TD>        }</TD></TR><TR><TD CLASS="l">5976</TD><TD>        </TD></TR><TR><TD CLASS="l">5977</TD><TD>        // filter duplicate spread keys.</TD></TR><TR CLASS="z"><TD CLASS="l">5978</TD><TD>        for(int j = 0; j &lt; allStrategies.length; j++)</TD></TR><TR><TD CLASS="l">5979</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">5980</TD><TD>            Integer sKey = 0;</TD></TR><TR><TD CLASS="l">5981</TD><TD>            Boolean isVisited;</TD></TR><TR CLASS="z"><TD CLASS="l">5982</TD><TD>            sKey = allStrategies[j].product.productKeys.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">5983</TD><TD>            if(!fileteredPendingStrategyKeys.contains(sKey))</TD></TR><TR><TD CLASS="l">5984</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">5985</TD><TD>                fileteredPendingStrategyKeys.add(sKey);</TD></TR><TR><TD CLASS="l">5986</TD><TD>            }</TD></TR><TR><TD CLASS="l">5987</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5988</TD><TD>        return fileteredPendingStrategyKeys;</TD></TR><TR><TD CLASS="l"><A NAME="8d">5989</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5990</TD><TD> </TD></TR><TR><TD CLASS="l">5991</TD><TD>    private PriceAdjustmentStruct populatePriceAdjustment(PriceAdjustmentStruct p_anAdjustmentStruct)</TD></TR><TR><TD CLASS="l">5992</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">5993</TD><TD>        PriceAdjustmentStruct retStruct = ProductStructBuilder.buildPriceAdjustmentStruct();        </TD></TR><TR CLASS="z"><TD CLASS="l">5994</TD><TD>        retStruct.adjustmentNumber = p_anAdjustmentStruct.adjustmentNumber;</TD></TR><TR CLASS="z"><TD CLASS="l">5995</TD><TD>        retStruct.type = p_anAdjustmentStruct.type;</TD></TR><TR CLASS="z"><TD CLASS="l">5996</TD><TD>        retStruct.source = p_anAdjustmentStruct.source;</TD></TR><TR CLASS="z"><TD CLASS="l">5997</TD><TD>        retStruct.productKey = p_anAdjustmentStruct.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">5998</TD><TD>        retStruct.productSymbol = p_anAdjustmentStruct.productSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">5999</TD><TD>        retStruct.newProductSymbol = p_anAdjustmentStruct.newProductSymbol;</TD></TR><TR CLASS="z"><TD CLASS="l">6000</TD><TD>        retStruct.effectiveDate = p_anAdjustmentStruct.effectiveDate;</TD></TR><TR CLASS="z"><TD CLASS="l">6001</TD><TD>        retStruct.runDate = p_anAdjustmentStruct.runDate;</TD></TR><TR CLASS="z"><TD CLASS="l">6002</TD><TD>        retStruct.splitNumerator = p_anAdjustmentStruct.splitNumerator;</TD></TR><TR CLASS="z"><TD CLASS="l">6003</TD><TD>        retStruct.splitDenominator = p_anAdjustmentStruct.splitDenominator;</TD></TR><TR CLASS="z"><TD CLASS="l">6004</TD><TD>        retStruct.cashDividend = p_anAdjustmentStruct.cashDividend;</TD></TR><TR CLASS="z"><TD CLASS="l">6005</TD><TD>        retStruct.stockDividend = p_anAdjustmentStruct.stockDividend;</TD></TR><TR CLASS="z"><TD CLASS="l">6006</TD><TD>        retStruct.lowRange  = p_anAdjustmentStruct.lowRange;</TD></TR><TR CLASS="z"><TD CLASS="l">6007</TD><TD>        retStruct.highRange = p_anAdjustmentStruct.highRange;</TD></TR><TR CLASS="z"><TD CLASS="l">6008</TD><TD>        retStruct.adjustedClasses = new PriceAdjustmentClassStruct[1];</TD></TR><TR CLASS="z"><TD CLASS="l">6009</TD><TD>        retStruct.createdTime = p_anAdjustmentStruct.createdTime;</TD></TR><TR CLASS="z"><TD CLASS="l">6010</TD><TD>        retStruct.lastModifiedTime  = p_anAdjustmentStruct.lastModifiedTime;</TD></TR><TR CLASS="z"><TD CLASS="l">6011</TD><TD>        retStruct.orderAction = p_anAdjustmentStruct.orderAction;</TD></TR><TR CLASS="z"><TD CLASS="l">6012</TD><TD>        return retStruct;</TD></TR><TR><TD CLASS="l"><A NAME="15">6013</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6014</TD><TD>    </TD></TR><TR><TD CLASS="l">6015</TD><TD>    private PendingOrderReportStruct buildPendingOrderReportStruct() </TD></TR><TR><TD CLASS="l">6016</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6017</TD><TD>        PendingOrderReportStruct  pendingOrder = new PendingOrderReportStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6018</TD><TD>        pendingOrder.currentOrder = OrderStructBuilder.buildOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6019</TD><TD>        pendingOrder.pendingOrder = OrderStructBuilder.buildOrderStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6020</TD><TD>        pendingOrder.pendingProductName = new PendingNameStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6021</TD><TD>        pendingOrder.pendingProductName.productStruct = ProductStructBuilder.buildProductStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6022</TD><TD>        pendingOrder.pendingProductName.pendingProductName = ProductStructBuilder.buildProductNameStruct();</TD></TR><TR CLASS="z"><TD CLASS="l">6023</TD><TD>        return pendingOrder;</TD></TR><TR><TD CLASS="l"><A NAME="6e">6024</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6025</TD><TD> </TD></TR><TR><TD CLASS="l">6026</TD><TD>    private PendingOrderStruct[] getTotalPendingOrders(List&lt;PendingOrderStruct[]&gt; orders, int totalOrdersSize) throws SystemException, CommunicationException, DataValidationException, AuthorizationException</TD></TR><TR><TD CLASS="l">6027</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6028</TD><TD>        PendingOrderStruct[] returnOrders = new PendingOrderStruct[totalOrdersSize]; </TD></TR><TR CLASS="z"><TD CLASS="l">6029</TD><TD>        totalOrdersSize = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">6030</TD><TD>        for (int l = 0; l &lt; orders.size(); l++)</TD></TR><TR><TD CLASS="l">6031</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6032</TD><TD>            System.arraycopy(orders.get(l), 0, returnOrders, totalOrdersSize, orders.get(l).length);</TD></TR><TR CLASS="z"><TD CLASS="l">6033</TD><TD>            totalOrdersSize += orders.get(l).length;</TD></TR><TR><TD CLASS="l">6034</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6035</TD><TD>        boolean pendingNameExists = false;</TD></TR><TR CLASS="z"><TD CLASS="l">6036</TD><TD>        int[] productKeys = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">6037</TD><TD>        for (int i=0; i &lt; returnOrders.length; i++) </TD></TR><TR><TD CLASS="l">6038</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6039</TD><TD>            if(returnOrders[i] != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">6040</TD><TD>                productKeys = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">6041</TD><TD>                productKeys[0] = returnOrders[i].currentOrder.productKey;</TD></TR><TR><TD CLASS="l">6042</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">6043</TD><TD>                if (returnOrders[i].currentOrder.productType == ProductTypes.OPTION) {</TD></TR><TR><TD CLASS="l">6044</TD><TD>                    try</TD></TR><TR><TD CLASS="l">6045</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">6046</TD><TD>                        returnOrders[i].pendingProductName = getProductQueryService()</TD></TR><TR><TD CLASS="l">6047</TD><TD>                                .getPendingAdjustmentNameByProduct(returnOrders[i].currentOrder.productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">6048</TD><TD>                        pendingNameExists = true;</TD></TR><TR><TD CLASS="l">6049</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">6050</TD><TD>                    catch (NotFoundException e){ } // Don't do anything</TD></TR><TR><TD CLASS="l">6051</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">6052</TD><TD>                if(!pendingNameExists) {</TD></TR><TR CLASS="z"><TD CLASS="l">6053</TD><TD>                    returnOrders[i].pendingProductName.pendingProductName = getProductQueryService().getProductsByKey(productKeys)[0].productName;</TD></TR><TR><TD CLASS="l">6054</TD><TD>                }</TD></TR><TR><TD CLASS="l">6055</TD><TD>            }</TD></TR><TR><TD CLASS="l">6056</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6057</TD><TD>        return returnOrders;  </TD></TR><TR><TD CLASS="l"><A NAME="6f">6058</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6059</TD><TD> </TD></TR><TR><TD CLASS="l">6060</TD><TD>    private PendingOrderReportStruct[] getTotalPendingReportOrders(List&lt;PendingOrderReportStruct[]&gt; orders, int totalOrdersSize) throws SystemException, CommunicationException, DataValidationException, AuthorizationException</TD></TR><TR><TD CLASS="l">6061</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6062</TD><TD>        PendingOrderReportStruct[] returnOrders = new PendingOrderReportStruct[totalOrdersSize]; </TD></TR><TR CLASS="z"><TD CLASS="l">6063</TD><TD>        totalOrdersSize = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">6064</TD><TD>        for (int l = 0; l &lt; orders.size(); l++)</TD></TR><TR><TD CLASS="l">6065</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6066</TD><TD>            System.arraycopy(orders.get(l), 0, returnOrders, totalOrdersSize, orders.get(l).length);</TD></TR><TR CLASS="z"><TD CLASS="l">6067</TD><TD>            totalOrdersSize += orders.get(l).length;</TD></TR><TR><TD CLASS="l">6068</TD><TD>        }</TD></TR><TR><TD CLASS="l">6069</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">6070</TD><TD>        boolean pendingNameExists = false;</TD></TR><TR CLASS="z"><TD CLASS="l">6071</TD><TD>        int[] productKeys = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">6072</TD><TD>        for (int i=0; i &lt; returnOrders.length; i++) </TD></TR><TR><TD CLASS="l">6073</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6074</TD><TD>            if(returnOrders[i] != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">6075</TD><TD>                productKeys = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">6076</TD><TD>                productKeys[0] = returnOrders[i].currentOrder.productKey;</TD></TR><TR CLASS="z"><TD CLASS="l">6077</TD><TD>                returnOrders[i].currentProductName = getProductQueryService().getProductsByKey(productKeys)[0].productName;</TD></TR><TR CLASS="z"><TD CLASS="l">6078</TD><TD>                if (returnOrders[i].currentOrder.productType == ProductTypes.OPTION) {</TD></TR><TR><TD CLASS="l">6079</TD><TD>                    try</TD></TR><TR><TD CLASS="l">6080</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">6081</TD><TD>                        returnOrders[i].pendingProductName = getProductQueryService().getPendingAdjustmentNameByProduct(returnOrders[i].currentOrder.productKey);</TD></TR><TR CLASS="z"><TD CLASS="l">6082</TD><TD>                        pendingNameExists = true;</TD></TR><TR><TD CLASS="l">6083</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">6084</TD><TD>                    catch (NotFoundException e){ } // Don't do anything</TD></TR><TR><TD CLASS="l">6085</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">6086</TD><TD>                if(!pendingNameExists) {</TD></TR><TR CLASS="z"><TD CLASS="l">6087</TD><TD>                    returnOrders[i].pendingProductName.pendingProductName = getProductQueryService().getProductsByKey(productKeys)[0].productName;</TD></TR><TR><TD CLASS="l">6088</TD><TD>                }</TD></TR><TR><TD CLASS="l">6089</TD><TD>            }</TD></TR><TR><TD CLASS="l">6090</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6091</TD><TD>        return returnOrders;         </TD></TR><TR><TD CLASS="l"><A NAME="5e">6092</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6093</TD><TD>    </TD></TR><TR><TD CLASS="l">6094</TD><TD>    private ProductMaintenanceService getProductMaintenanceService() throws SystemException</TD></TR><TR><TD CLASS="l">6095</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6096</TD><TD>        if (productMaintenanceService == null) {</TD></TR><TR><TD CLASS="l">6097</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">6098</TD><TD>                ProductMaintenanceServiceHome pqsHome = (ProductMaintenanceServiceHome) HomeFactory.getInstance().findHome(ProductMaintenanceServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">6099</TD><TD>                productMaintenanceService = pqsHome.find();</TD></TR><TR><TD CLASS="l">6100</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">6101</TD><TD>            catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">6102</TD><TD>                throw ExceptionBuilder.systemException(&#34;Unable to get ProductMaintenanceService&#34;, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">6103</TD><TD>            }</TD></TR><TR><TD CLASS="l">6104</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6105</TD><TD>        return productMaintenanceService;</TD></TR><TR><TD CLASS="l">6106</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="55">6107</A></TD><TD> </TD></TR><TR><TD CLASS="l">6108</TD><TD>    //Get handle to OHS.OHS</TD></TR><TR><TD CLASS="l">6109</TD><TD>    private OrderHandlingService getOrderHandlingService() throws SystemException </TD></TR><TR><TD CLASS="l">6110</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6111</TD><TD>        if (orderHandlingService == null) {</TD></TR><TR><TD CLASS="l">6112</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">6113</TD><TD>                OrderHandlingServiceHome orderHandlingServiceHome = (OrderHandlingServiceHome) HomeFactory</TD></TR><TR><TD CLASS="l">6114</TD><TD>                        .getInstance().findHome(OrderHandlingServiceHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">6115</TD><TD>                orderHandlingService = orderHandlingServiceHome.find();</TD></TR><TR CLASS="z"><TD CLASS="l">6116</TD><TD>            } catch (com.cboe.infrastructureServices.foundationFramework.exceptionHandling.CBOELoggableException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">6117</TD><TD>                throw ExceptionBuilder.systemException(&#34;Unable to find OrderHandlingService, giving up&#34;, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">6118</TD><TD>            }</TD></TR><TR><TD CLASS="l">6119</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6120</TD><TD>        return orderHandlingService;</TD></TR><TR><TD CLASS="l">6121</TD><TD>    }</TD></TR><TR><TD CLASS="l">6122</TD><TD>    </TD></TR><TR><TD CLASS="l">6123</TD><TD>    /**</TD></TR><TR><TD CLASS="l">6124</TD><TD>     * Retrieve all pending adjustments from ProductQueryService.</TD></TR><TR><TD CLASS="l"><A NAME="57">6125</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">6126</TD><TD>     */</TD></TR><TR><TD CLASS="l">6127</TD><TD>    private PendingAdjustmentStruct[] getPendingAdjustments()</TD></TR><TR><TD CLASS="l">6128</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6129</TD><TD>        PendingAdjustmentStruct[] pendingAdjustments = null;</TD></TR><TR><TD CLASS="l">6130</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">6131</TD><TD>        if (Log.isDebugOn())</TD></TR><TR><TD CLASS="l">6132</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6133</TD><TD>            Log.information(&#34;retrieving all pending adjustments: &#34;);</TD></TR><TR><TD CLASS="l">6134</TD><TD>        }</TD></TR><TR><TD CLASS="l">6135</TD><TD>        try</TD></TR><TR><TD CLASS="l">6136</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6137</TD><TD>            pendingAdjustments = getProductQueryService().getPendingAdjustments();</TD></TR><TR><TD CLASS="l">6138</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6139</TD><TD>        catch (Exception e)</TD></TR><TR><TD CLASS="l">6140</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">6141</TD><TD>            Log.alarm(this,&#34;ProductQueryService didnot find any pending adjustments: &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">6142</TD><TD>            return new PendingAdjustmentStruct[0];</TD></TR><TR CLASS="z"><TD CLASS="l">6143</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6144</TD><TD>        return pendingAdjustments;</TD></TR><TR><TD CLASS="l"><A NAME="82">6145</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6146</TD><TD> </TD></TR><TR><TD CLASS="l">6147</TD><TD>    private boolean isTimetoApply(PendingAdjustmentStruct pendingAdjustment)</TD></TR><TR><TD CLASS="l">6148</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">6149</TD><TD>            return pendingAdjustment.active &amp;&amp; </TD></TR><TR><TD CLASS="l">6150</TD><TD>                            (DateWrapper.convertToMillis(pendingAdjustment.submittedDate) &lt; System.currentTimeMillis());</TD></TR><TR><TD CLASS="l">6151</TD><TD>    }</TD></TR><TR><TD CLASS="l">6152</TD><TD>   </TD></TR><TR><TD CLASS="l">6153</TD><TD>   /**</TD></TR><TR><TD CLASS="l"><A NAME="53">6154</A></TD><TD>    * Market Data Summary Home accessor</TD></TR><TR><TD CLASS="l">6155</TD><TD>    */</TD></TR><TR><TD CLASS="l">6156</TD><TD>   public synchronized MarketDataSummaryHome getMarketDataSummaryHome()</TD></TR><TR><TD CLASS="l">6157</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">6158</TD><TD>        if (marketDataSummaryHome == null) </TD></TR><TR><TD CLASS="l">6159</TD><TD>        {</TD></TR><TR><TD CLASS="l">6160</TD><TD>            try </TD></TR><TR><TD CLASS="l">6161</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">6162</TD><TD>                BOHome aHome = HomeFactory.getInstance().findHome(</TD></TR><TR><TD CLASS="l">6163</TD><TD>                                              MarketDataSummaryHome.HOME_NAME);</TD></TR><TR CLASS="z"><TD CLASS="l">6164</TD><TD>                marketDataSummaryHome = (MarketDataSummaryHome) aHome;</TD></TR><TR><TD CLASS="l">6165</TD><TD>            } </TD></TR><TR CLASS="z"><TD CLASS="l">6166</TD><TD>            catch (CBOELoggableException e) </TD></TR><TR><TD CLASS="l">6167</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">6168</TD><TD>                throw new FatalFoundationFrameworkException(</TD></TR><TR><TD CLASS="l">6169</TD><TD>                                   &#34;Could not find Market Data Summary Home&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">6170</TD><TD>            }</TD></TR><TR><TD CLASS="l">6171</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">6172</TD><TD>        return marketDataSummaryHome;</TD></TR><TR><TD CLASS="l"><A NAME="4b">6173</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">6174</TD><TD>   </TD></TR><TR><TD CLASS="l">6175</TD><TD>   public boolean getEnabledOrderCancelling()</TD></TR><TR><TD CLASS="l">6176</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">6177</TD><TD>       return enabledOrderCancelling;</TD></TR><TR><TD CLASS="l"><A NAME="63">6178</A></TD><TD>   }</TD></TR><TR><TD CLASS="l">6179</TD><TD>   </TD></TR><TR><TD CLASS="l">6180</TD><TD>   public boolean getQuickStartSessionFlag()</TD></TR><TR><TD CLASS="l">6181</TD><TD>   {</TD></TR><TR CLASS="z"><TD CLASS="l">6182</TD><TD>       return startSessionQuickFlag;</TD></TR><TR><TD CLASS="l">6183</TD><TD>   }</TD></TR><TR><TD CLASS="l">6184</TD><TD> </TD></TR><TR><TD CLASS="l">6185</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1e.html">com.cboe.businessServices.tradingSessionService</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>