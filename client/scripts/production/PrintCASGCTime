#! /usr/xpg4/bin/awk -f

# Copyright 1998-2002 Sun Microsystems, Inc.  All rights reserved.

BEGIN {
  firstTimeStamp = 0;
  prevTimeStamp = lastTimeStamp = firstTimeStamp;
  applicationTime = 0;
  gcPauseTime = 0;
  pauseTimeStamp = 0;
  parNewTimeStamp = 0;
  fullGCTimeStamp = 0;
  fullGCTime = 0;
  appThreadStopTime = 0;
  parNew_count = 0;
  prevParNew_count = 0;
  oldGenSize = 0;
  baseTimeInSecs = "";

  #Initialize
  IS_ParNew15="FALSE";
  IS_FullGC="FALSE";
  IS_FullGCCompleted="FALSE";
  FULLGC_STRING=""

  #GC Ranges
  GCRangeDAY_0_20=0;
  GCRangeDAY_21_30=0;
  GCRangeDAY_31_40=0;
  GCRangeDAY_41_50=0;
  GCRangeDAY_51_100=0;
  GCRangeDAY_101_200=0;
  GCRangeDAY_201_500=0;
  GCRangeDAY_501_1000=0;

  GCRangeSTART_0_20=0;
  GCRangeSTART_21_30=0;
  GCRangeSTART_31_40=0;
  GCRangeSTART_41_50=0;
  GCRangeSTART_51_100=0;
  GCRangeSTART_101_200=0;
  GCRangeSTART_201_500=0;
  GCRangeSTART_501_1000=0;

  GCRange_2_3=0;
  GCRange_3_5=0;
  GCRange_5_10=0;
  GCRange_10_15=0;
  GCRange_15_20=0;
  GCRange_20_25=0;
  GCRange_25_30=0;
  GCRange_30_35=0;
  GCRange_35_40=0;
  GCRange_40_50=0;
  GCRange_50=0;

  FullGC_Range=0;
 
  datafmtDAY = "GCSUMDAY: %-22s" " %5d" " %5d" " %5d" " %5d" " %5d" " %6d" " %6d" " %6d" " %6d" "\n";
  datafmtSTART = "GCSUMSTART: %-22s" " %5d" " %5d" " %5d" " %5d" " %5d" " %6d" " %6d" " %6d" " %6d" "\n";
}

#Extract Time
function extractTime() {
  pi_tmp_str = $0;
  #print "pi_tmp_str="pi_tmp_str;

#Handle following 2 cases for CMS Remark
#, 0.0782226 secs]4371.579: [weak refs processing, 0.0023094 secs] [1 CMS-remark: 1799325K(2739200K)] 1843441K(3058176K), 0.0811074 s
#and
#6700.490: [GC[YG occupancy: 53685 K (102336 K)]6700.490: [Rescan (non-parallel) 6700.490: [grey object rescan, 0.0023868 secs]6700.493: [root rescan, 0.0983509 secs], 0.1008611 secs]6700.591: [weak refs processing, 0.0001040 secs] [1 CMS-remark: 590891K(1208320K)] 644577K(1310656K), 0.1014182 secs]
 
  if (match(pi_tmp_str, "20[0-9][0-9]\-[01][0-9]-[0-3][0-9]T")) {
	split (pi_tmp_str, t, ": ");
    	lastTimeStamp = t[2];
    	return; 
  }
  if (match(pi_tmp_str, "\[[0-9] CMS-remark: ")) {
    if (match(pi_tmp_str, "\[GC\[YG occupancy: ")) {
      tInt = sub(/.*root rescan, [0-9.]+ secs\]/, "", pi_tmp_str);
      tInt = sub(/, [0-9.]+ secs\]/, "", pi_tmp_str);
      tInt = sub(/: \[weak.*/, "", pi_tmp_str);
      #print "1 CMS-remark pi_tmp_str="pi_tmp_str;
    }
    else {
      tInt = sub(/, [0-9.]+ secs\]/, "", pi_tmp_str);
      tInt = sub(/: \[weak.*/, "", pi_tmp_str);
      #print "2 CMS-remark pi_tmp_str="pi_tmp_str;
    }
  }
  else
  {
    #First if for JDK 1.6, second if for JDK 1.5 for Young Gen Collection
    if (! match(pi_tmp_str, "[0-9.]+: \[[(GC|CMS|Full GC)]")) { 
      if (! match(pi_tmp_str, "[0-9.]+: \[(Def|Par)New")) {
        return;
      }
      else {
        tInt = sub(/: \[(Def|Par)New.*/, "", pi_tmp_str);
      }
    }
    else {
      tInt = sub(/: \[(GC|CMS|Full GC).*/, "", pi_tmp_str);
    }
  }

 #print "Before pi_tmp_str="pi_tmp_str;
  prevTimeStamp = lastTimeStamp;
  if (match(pi_tmp_str, "^ CMS: abort preclean due to time  \[.*\] ")) {
    #This takes care of string
    # CMS: abort preclean due to time  [70 iterations, 0 waits, 50634 cards)] 5145.411: [CMS-concurrent-abortable-preclean: 1.138/5.032 secs]
    lastTimeStamp = substr(pi_tmp_str, RSTART + RLENGTH);
    #print "lastTimeStamp="lastTimeStamp;
    return;
  }
  else if (match(pi_tmp_str, "^ CMS: abort preclean due to time ")) {
    #This takes care of string
    # CMS: abort preclean due to time 13170.134: [CMS-concurrent-abortable-preclean: 0.170/5.063 secs]
    lastTimeStamp = substr(pi_tmp_str, RSTART + RLENGTH);
    #print "lastTimeStamp="lastTimeStamp;
    return;
  }
  else if (! match(pi_tmp_str, "^ \[.*\] ")) {
    #print "Between, pi_tmp_str="pi_tmp_str;
    lastTimeStamp = pi_tmp_str + 0.0;
    return; 
  }

  #print "pi_tmp_str="pi_tmp_str;
  lastTimeStamp = substr(pi_tmp_str, RSTART + RLENGTH);
#  print "Extracting lastTimeStamp=10%d"lastTimeStamp
#  print "lastTimeStamp="lastTimeStamp;
}

function getTimestamp(timeAppRelTime)
{
  timeValue = timeAppRelTime;
  #Add Timestamp
  if (timestamp != "") {
    if (baseTimeInSecs == "") {
      split(timestamp, timeArr, ":");
      baseTimeInSecs=(timeArr[1]*3600) + (timeArr[2]*60) + timeArr[3];
    }

    timeInSecs=baseTimeInSecs + timeAppRelTime;

    #Convert secs back to timestamp
    timeHrs=timeInSecs % 3600;
    timeHrs=(timeInSecs - timeHrs) / 3600;
    timeMins=timeInSecs - (timeHrs * 3600);
    timeMins=timeMins - (timeMins % 60);
    timeMins=timeMins / 60;
    timeSecs=timeInSecs - ((timeHrs * 3600) + (timeMins * 60));
    timeValue=(timeHrs)(":")(timeMins)(":")(timeSecs);
  }
  #print "timeValue="timeValue;
  return timeValue;
}

# Full GC Entry
# IS_FullGC is set to true the moment Full GC string is encountered. IS_FullGCCompleted is set to true when the closing brace of
# Full GC is encountered. Now IS_FullGC flag is set to false the moment some other GC type is encountered which is **not between
# Full GC braces** Hence we need IS_FullGCCompleted flag also.
/^[0-9.]+: \[Full GC.*/ {
  IS_FullGC="TRUE";
  IS_FullGCCompleted="FALSE";
  extractTime();
  fullGCTimeStamp = lastTimeStamp;
  FULLGC_STRING="Full GC"
  next;
}

# Application Thread Stop Time
/Total time for which application threads were stopped: / {
  tString = $0;
  tInt = sub(/ seconds/, "", tString);
  tInt = sub(/.*Total time for which application threads were stopped: /, "", tString);
  appThreadStopTime = tString + 0;
  tempTimeVal=getTimestamp(lastTimeStamp);
split(tempTimeVal,timearr,":")
hour=timearr[1]
min=timearr[2]
if ( int(hour) >= 8  && int(hour)<16 && !(int(hour)==15 && int(min)>=30))
{
  if (appThreadStopTime >= maxLimit)
    print "GCRPT: "process" = "appThreadStopTime" at "tempTimeVal 

  if (appThreadStopTime >= 0 && appThreadStopTime <= 0.02)
    GCRangeDAY_0_20 = GCRangeDAY_0_20 + 1;
  else if (appThreadStopTime > 0.02 && appThreadStopTime <= 0.03)
    GCRangeDAY_21_30 = GCRangeDAY_21_30 + 1;
  else if (appThreadStopTime > 0.03 && appThreadStopTime <= 0.04)
    GCRangeDAY_31_40 = GCRangeDAY_31_40 + 1;
  else if (appThreadStopTime > 0.04 && appThreadStopTime <= 0.05)
    GCRangeDAY_41_50 = GCRangeDAY_41_50 + 1;
  else if (appThreadStopTime > 0.05 && appThreadStopTime <= 0.1)
    GCRangeDAY_51_100 = GCRangeDAY_51_100 + 1;
  else if (appThreadStopTime > 0.1 && appThreadStopTime <= 0.2)
    GCRangeDAY_101_200 = GCRangeDAY_101_200 + 1;
  else if (appThreadStopTime > 0.2 && appThreadStopTime <= 0.5)
    GCRangeDAY_201_500 = GCRangeDAY_201_500 + 1;
  else if (appThreadStopTime > 0.5)
    GCRangeDAY_501_1000 = GCRangeDAY_501_1000 + 1;
}

if (  int(hour)<8 )
{
  if (appThreadStopTime >= maxLimit)
    print "GCRPT: "process" = "appThreadStopTime" at "tempTimeVal 

  if (appThreadStopTime >= 0 && appThreadStopTime <= 0.02)
    GCRangeSTART_0_20 = GCRangeSTART_0_20 + 1;
  else if (appThreadStopTime > 0.02 && appThreadStopTime <= 0.03)
    GCRangeSTART_21_30 = GCRangeSTART_21_30 + 1;
  else if (appThreadStopTime > 0.03 && appThreadStopTime <= 0.04)
    GCRangeSTART_31_40 = GCRangeSTART_31_40 + 1;
  else if (appThreadStopTime > 0.04 && appThreadStopTime <= 0.05)
    GCRangeSTART_41_50 = GCRangeSTART_41_50 + 1;
  else if (appThreadStopTime > 0.05 && appThreadStopTime <= 0.1)
    GCRangeSTART_51_100 = GCRangeSTART_51_100 + 1;
  else if (appThreadStopTime > 0.1 && appThreadStopTime <= 0.2)
    GCRangeSTART_101_200 = GCRangeSTART_101_200 + 1;
  else if (appThreadStopTime > 0.2 && appThreadStopTime <= 0.5)
    GCRangeSTART_201_500 = GCRangeSTART_201_500 + 1;
  else if (appThreadStopTime > 0.5)
    GCRangeSTART_501_1000 = GCRangeSTART_501_1000 + 1;
}

  next;
}

# Match CMS initial mark output
/\[1 CMS-initial-mark: [0-9]+K\([0-9]+K\)\] [0-9]+K\([0-9]+K\), [0-9][0-9.]* secs\]/ {
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

# Match cms remark output
/\[1 CMS-remark.*, [0-9][0-9.]*\ secs\]/ {
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

# Match cms concurrent phase output
/\[CMS-concurrent-(mark|preclean|abortable-preclean|sweep|reset): [0-9.]+\/[0-9.]+ secs\]/ {
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

# ParNew Entry for JDK 1.5 without tenuring distribution
/[0-9.]+: \[ParNew: [0-9]+K->[0-9]+K\([0-9]+K\),.*secs\] [0-9]+K->[0-9]+K\([0-9]+K\).*Heap after [gG][cC] invocations=[0-9]+:/ {
  IS_ParNew15="TRUE";
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

#Occurence of Promotion Failed
/\[GC.*\[(Def|Par)New.*promotion failed/ {
  IS_FullGC="TRUE";
  IS_FullGCCompleted="FALSE";
  extractTime();
  fullGCTimeStamp = lastTimeStamp;
  FULLGC_STRING="Promotion Failed";
  next;
}

#Occurence of Promotion Failed in seperate line
/\(promotion failed\)/ {
  IS_FullGC="TRUE";
  IS_FullGCCompleted="FALSE";
  FULLGC_STRING="Promotion Failed";
  next;
}


# Match PrintGCDetails output for DefNew or ParNew for JDK 1.6
/\[GC.*\[(Def|Par)New/ {
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

# Match PrintGCDetails output for DefNew or ParNew for JDK 1.5
/\[(Def|Par)New/ {
  IS_ParNew15="TRUE";
  extractTime();
  if (IS_FullGC == "TRUE" && IS_FullGCCompleted == "TRUE")
    IS_FullGC = "FALSE";
  next;
}

/concurrent mode failure.*, [0-9.]+ secs\]$/ {
  #If IS_FullGC is TRUE then we already had 'promotion failed' message and hence this Full GC will be tagged as
  #'promotion failed' and not as 'concurrent mode failure'
  if (IS_FullGC != "TRUE")
  {
    IS_FullGC="TRUE";
    IS_FullGCCompleted="FALSE";
    fullGCTimeStamp = lastTimeStamp;
    FULLGC_STRING="Concurrent Mode Failure";
  }
}

/.*, [0-9.]+ secs\]$/ {
  tString = $0;
  tInt = sub(/ secs\]/, "", tString);
  tInt = sub(/.*, /, "", tString);
  secs = tString +0;

  if (IS_ParNew15 == "TRUE") {
    IS_ParNew15="FALSE";
  } else if (IS_FullGC == "TRUE")
  {
    tempTimeVal=getTimestamp(fullGCTimeStamp);
    ##print "Full GC occured for "process" for time = "secs" secs at "tempTimeVal >> "GCMailBody_t.txt"
    print "GCRPT:Full GC occured for "process" for time = "secs" secs at "tempTimeVal" "FULLGC_STRING 
    FullGC_Range = FullGC_Range + 1;
    IS_FullGCCompleted="TRUE";
  }
  next;
}

END {
  if (GCRangeDAY_0_20 != 0 || GCRangeDAY_21_30 != 0 || GCRangeDAY_31_40 != 0 || GCRangeDAY_41_50 != 0 || GCRangeDAY_51_100 != 0 || GCRangeDAY_101_200 != 0 || GCRangeDAY_201_500 != 0 || GCRangeDAY_501_1000 != 0 || FullGC_Range != 0)
    printf(datafmtDAY, process, GCRangeDAY_0_20, GCRangeDAY_21_30, GCRangeDAY_31_40, GCRangeDAY_41_50, GCRangeDAY_51_100, GCRangeDAY_101_200, GCRangeDAY_201_500, GCRangeDAY_501_1000,      FullGC_Range) ;

  if (GCRangeSTART_0_20 != 0 || GCRangeSTART_21_30 != 0 || GCRangeSTART_31_40 != 0 || GCRangeSTART_41_50 != 0 || GCRangeSTART_51_100 != 0 || GCRangeSTART_101_200 != 0 || GCRangeSTART_201_500 != 0 || GCRangeSTART_501_1000 != 0 || FullGC_Range != 0)
    printf(datafmtSTART, process, GCRangeSTART_0_20, GCRangeSTART_21_30, GCRangeSTART_31_40, GCRangeSTART_41_50, GCRangeSTART_51_100, GCRangeSTART_101_200, GCRangeSTART_201_500, GCRangeSTART_501_1000,      FullGC_Range) ;
}
