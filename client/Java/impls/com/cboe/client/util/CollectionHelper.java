package com.cboe.client.util;

/**
 * CollectionHelper.java
 *
 * @author Dmitry Volpyansky
 *
 * FILE GENERATED BY VELOCITY TEMPLATE ENGINE FROM /vobs/dte/client/generator/DV_CollectionHelper.java
 *
 */

import java.util.*;

import com.cboe.idl.cmiMarketData.*;
import com.cboe.idl.cmiProduct.*;
import com.cboe.idl.cmiSession.*;
import com.cboe.domain.util.RecapContainerV4;
import com.cboe.interfaces.domain.RecapContainerV4IF;

public final class CollectionHelper
{
    public static final BookDepthStruct[]              EMPTY_BookDepthStruct_ARRAY              = new BookDepthStruct[0];
    public static final CurrentMarketStruct[]          EMPTY_CurrentMarketStruct_ARRAY          = new CurrentMarketStruct[0];
    public static final CurrentMarketStructV4[]        EMPTY_CurrentMarketStructV4_ARRAY        = new CurrentMarketStructV4[0];

    public static final ExpectedOpeningPriceStruct[]   EMPTY_ExpectedOpeningPriceStruct_ARRAY   = new ExpectedOpeningPriceStruct[0];
    public static final NBBOStruct[]                   EMPTY_NBBOStruct_ARRAY                   = new NBBOStruct[0];
    
    public static final RecapStruct[]                  EMPTY_RecapStruct_ARRAY                  = new RecapStruct[0];
    public static final RecapStructV4[]                EMPTY_RecapStructV4_ARRAY                = new RecapStructV4[0];
    public static final RecapContainerV4IF[]           EMPTY_RecapContainerV4_ARRAY             = new RecapContainerV4[0];

    public static final TickerStruct[]                 EMPTY_TickerStruct_ARRAY                 = new TickerStruct[0];
    public static final TickerStructV4[]               EMPTY_TickerStructV4_ARRAY               = new TickerStructV4[0];

    public static final SessionProductStruct[]         EMPTY_SessionProductStruct_ARRAY         = new SessionProductStruct[0];
    public static final SessionClassStruct[]           EMPTY_SessionClassStruct_ARRAY           = new SessionClassStruct[0];
    public static final ProductStruct[]                EMPTY_ProductStruct_ARRAY                = new ProductStruct[0];
    public static final ClassStruct[]                  EMPTY_ClassStruct_ARRAY                  = new ClassStruct[0];

    public static final Object[]                       EMPTY_Object_ARRAY                       = new Object[0];
    public static final String[]                       EMPTY_String_ARRAY                       = new String[0];
    public static final Integer[]                      EMPTY_Integer_ARRAY                      = new Integer[0];
    public static final Long[]                         EMPTY_Long_ARRAY                         = new Long[0];
    public static final Short[]                        EMPTY_Short_ARRAY                        = new Short[0];
    public static final Byte[]                         EMPTY_Byte_ARRAY                         = new Byte[0];
    public static final Character[]                    EMPTY_Character_ARRAY                    = new Character[0];
    public static final char[]                         EMPTY_char_ARRAY                         = new char[0];
    public static final int[]                          EMPTY_int_ARRAY                          = new int[0];
    public static final long[]                         EMPTY_long_ARRAY                         = new long[0];

    //public static final Set                          EMPTY_SET                                = Collections.EMPTY_SET;
    //public static final Map                          EMPTY_MAP                                = Collections.EMPTY_MAP;
    //public static final List                         EMPTY_LIST                               = Collections.EMPTY_LIST;

    public static int normalizeBinarySearchPosition(int position)
    {
        return position >= 0 ? position : -(position + 1);
    }


    public static final AscendingBookDepthStructByProductKeyComparator BookDepthStructByProductKeyComparator = new AscendingBookDepthStructByProductKeyComparator();
    public static class AscendingBookDepthStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((BookDepthStruct) objectA).productKeys.productKey - ((BookDepthStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(BookDepthStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(BookDepthStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static BookDepthStruct[] sort(BookDepthStruct[] array)
    {
        Arrays.sort(array, BookDepthStructByProductKeyComparator);

        return array;
    }
    public static BookDepthStruct[] arrayclone(BookDepthStruct from)
    {
        BookDepthStruct[] to = new BookDepthStruct[1];

        to[0] = from;

        return to;
    }

    public static BookDepthStruct[] arrayclone(BookDepthStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (BookDepthStruct[]) from.clone();
    }

    public static BookDepthStruct[] arrayclone(BookDepthStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[] to = new BookDepthStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static BookDepthStruct[] arrayclone(BookDepthStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[] to = new BookDepthStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static BookDepthStruct[] arraycloneCombine(BookDepthStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[] to = new BookDepthStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static BookDepthStruct[] arraycloneExpandGap(BookDepthStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[] to = new BookDepthStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static BookDepthStruct[][] arrayclone(BookDepthStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (BookDepthStruct[][]) from.clone();
    }

    public static BookDepthStruct[][] arraycloneDimensions(BookDepthStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static BookDepthStruct[][] arrayclone(BookDepthStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static BookDepthStruct[][] arrayclone(BookDepthStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static BookDepthStruct[][] arraycloneCombine(BookDepthStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static BookDepthStruct[][] arraycloneExpandGap(BookDepthStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static BookDepthStruct[] arraycloneShrinkGap(BookDepthStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[] to = new BookDepthStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static BookDepthStruct[][] arraycloneShrinkGap(BookDepthStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        BookDepthStruct[][] to = new BookDepthStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingCurrentMarketStructByProductKeyComparator CurrentMarketStructByProductKeyComparator = new AscendingCurrentMarketStructByProductKeyComparator();
    public static class AscendingCurrentMarketStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((CurrentMarketStruct) objectA).productKeys.productKey - ((CurrentMarketStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(CurrentMarketStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(CurrentMarketStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static CurrentMarketStruct[] sort(CurrentMarketStruct[] array)
    {
        Arrays.sort(array, CurrentMarketStructByProductKeyComparator);

        return array;
    }
    public static CurrentMarketStruct[] arrayclone(CurrentMarketStruct from)
    {
        CurrentMarketStruct[] to = new CurrentMarketStruct[1];

        to[0] = from;

        return to;
    }

    public static CurrentMarketStruct[] arrayclone(CurrentMarketStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (CurrentMarketStruct[]) from.clone();
    }

    public static CurrentMarketStruct[] arrayclone(CurrentMarketStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[] to = new CurrentMarketStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static CurrentMarketStruct[] arrayclone(CurrentMarketStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[] to = new CurrentMarketStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static CurrentMarketStruct[] arraycloneCombine(CurrentMarketStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[] to = new CurrentMarketStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static CurrentMarketStruct[] arraycloneExpandGap(CurrentMarketStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[] to = new CurrentMarketStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static CurrentMarketStruct[][] arrayclone(CurrentMarketStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (CurrentMarketStruct[][]) from.clone();
    }

    public static CurrentMarketStruct[][] arraycloneDimensions(CurrentMarketStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static CurrentMarketStruct[][] arrayclone(CurrentMarketStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static CurrentMarketStruct[][] arrayclone(CurrentMarketStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static CurrentMarketStruct[][] arraycloneCombine(CurrentMarketStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static CurrentMarketStruct[][] arraycloneExpandGap(CurrentMarketStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static CurrentMarketStruct[] arraycloneShrinkGap(CurrentMarketStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[] to = new CurrentMarketStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static CurrentMarketStruct[][] arraycloneShrinkGap(CurrentMarketStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStruct[][] to = new CurrentMarketStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingCurrentMarketStructV4ByProductKeyComparator CurrentMarketStructV4ByProductKeyComparator = new AscendingCurrentMarketStructV4ByProductKeyComparator();
    public static class AscendingCurrentMarketStructV4ByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((CurrentMarketStructV4) objectA).productKey - ((CurrentMarketStructV4) objectB).productKey;
        }
    }
    public static int binarySearch(CurrentMarketStructV4[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(CurrentMarketStructV4[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static CurrentMarketStructV4[] sort(CurrentMarketStructV4[] array)
    {
        Arrays.sort(array, CurrentMarketStructV4ByProductKeyComparator);

        return array;
    }
    public static CurrentMarketStructV4[] arrayclone(CurrentMarketStructV4 from)
    {
        CurrentMarketStructV4[] to = new CurrentMarketStructV4[1];

        to[0] = from;

        return to;
    }

    public static CurrentMarketStructV4[] arrayclone(CurrentMarketStructV4[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (CurrentMarketStructV4[]) from.clone();
    }

    public static CurrentMarketStructV4[] arrayclone(CurrentMarketStructV4[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[] to = new CurrentMarketStructV4[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static CurrentMarketStructV4[] arrayclone(CurrentMarketStructV4[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[] to = new CurrentMarketStructV4[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static CurrentMarketStructV4[] arraycloneCombine(CurrentMarketStructV4[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[] to = new CurrentMarketStructV4[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static CurrentMarketStructV4[] arraycloneExpandGap(CurrentMarketStructV4[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[] to = new CurrentMarketStructV4[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static CurrentMarketStructV4[][] arrayclone(CurrentMarketStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (CurrentMarketStructV4[][]) from.clone();
    }

    public static CurrentMarketStructV4[][] arraycloneDimensions(CurrentMarketStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static CurrentMarketStructV4[][] arrayclone(CurrentMarketStructV4[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static CurrentMarketStructV4[][] arrayclone(CurrentMarketStructV4[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static CurrentMarketStructV4[][] arraycloneCombine(CurrentMarketStructV4[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static CurrentMarketStructV4[][] arraycloneExpandGap(CurrentMarketStructV4[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static CurrentMarketStructV4[] arraycloneShrinkGap(CurrentMarketStructV4[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[] to = new CurrentMarketStructV4[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static CurrentMarketStructV4[][] arraycloneShrinkGap(CurrentMarketStructV4[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        CurrentMarketStructV4[][] to = new CurrentMarketStructV4[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingRecapStructByProductKeyComparator RecapStructByProductKeyComparator = new AscendingRecapStructByProductKeyComparator();
    public static class AscendingRecapStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((RecapStruct) objectA).productKeys.productKey - ((RecapStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(RecapStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(RecapStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static RecapStruct[] sort(RecapStruct[] array)
    {
        Arrays.sort(array, RecapStructByProductKeyComparator);

        return array;
    }
    public static RecapStruct[] arrayclone(RecapStruct from)
    {
        RecapStruct[] to = new RecapStruct[1];

        to[0] = from;

        return to;
    }

    public static RecapStruct[] arrayclone(RecapStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapStruct[]) from.clone();
    }

    public static RecapStruct[] arrayclone(RecapStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[] to = new RecapStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapStruct[] arrayclone(RecapStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[] to = new RecapStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapStruct[] arraycloneCombine(RecapStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[] to = new RecapStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapStruct[] arraycloneExpandGap(RecapStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[] to = new RecapStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapStruct[][] arrayclone(RecapStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapStruct[][]) from.clone();
    }

    public static RecapStruct[][] arraycloneDimensions(RecapStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static RecapStruct[][] arrayclone(RecapStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapStruct[][] arrayclone(RecapStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapStruct[][] arraycloneCombine(RecapStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapStruct[][] arraycloneExpandGap(RecapStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapStruct[] arraycloneShrinkGap(RecapStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[] to = new RecapStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static RecapStruct[][] arraycloneShrinkGap(RecapStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStruct[][] to = new RecapStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingRecapStructV4ByProductKeyComparator RecapStructV4ByProductKeyComparator = new AscendingRecapStructV4ByProductKeyComparator();
    public static class AscendingRecapStructV4ByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((RecapStructV4) objectA).productKey - ((RecapStructV4) objectB).productKey;
        }
    }
    public static int binarySearch(RecapStructV4[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(RecapStructV4[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static RecapStructV4[] sort(RecapStructV4[] array)
    {
        Arrays.sort(array, RecapStructV4ByProductKeyComparator);

        return array;
    }
    public static RecapStructV4[] arrayclone(RecapStructV4 from)
    {
        RecapStructV4[] to = new RecapStructV4[1];

        to[0] = from;

        return to;
    }

    public static RecapStructV4[] arrayclone(RecapStructV4[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapStructV4[]) from.clone();
    }

    public static RecapStructV4[] arrayclone(RecapStructV4[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[] to = new RecapStructV4[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapStructV4[] arrayclone(RecapStructV4[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[] to = new RecapStructV4[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapStructV4[] arraycloneCombine(RecapStructV4[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[] to = new RecapStructV4[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapStructV4[] arraycloneExpandGap(RecapStructV4[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[] to = new RecapStructV4[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapStructV4[][] arrayclone(RecapStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapStructV4[][]) from.clone();
    }

    public static RecapStructV4[][] arraycloneDimensions(RecapStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static RecapStructV4[][] arrayclone(RecapStructV4[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapStructV4[][] arrayclone(RecapStructV4[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapStructV4[][] arraycloneCombine(RecapStructV4[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapStructV4[][] arraycloneExpandGap(RecapStructV4[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapStructV4[] arraycloneShrinkGap(RecapStructV4[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[] to = new RecapStructV4[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static RecapStructV4[][] arraycloneShrinkGap(RecapStructV4[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapStructV4[][] to = new RecapStructV4[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }


    public static final AscendingRecapContainerV4ByProductKeyComparator RecapContainerV4ByProductKeyComparator = new AscendingRecapContainerV4ByProductKeyComparator();
    public static class AscendingRecapContainerV4ByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((RecapContainerV4) objectA).getProductKey() - ((RecapContainerV4) objectB).getProductKey();
        }
    }
    public static int binarySearch(RecapContainerV4IF[] array, int key)
    {
        int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

        int low  = 0;
        int mid;
        int midVal;

        while (low <= high)
        {
            mid    = (low + high) >> 1;
            midVal = array[mid].getProductKey();

            if (midVal < key)
            {
                low = mid + 1;
            }
            else if (midVal > key)
            {
                high = mid - 1;
            }
            else
            {
                return mid; // key found
            }
        }

        return -(low + 1);  // key not found.
    }
    public static int binarySearch(RecapContainerV4IF[] array, int key, int length)
    {
        int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

        int low  = 0;
        int mid;
        int midVal;

        while (low <= high)
        {
            mid    = (low + high) >> 1;
            midVal = array[mid].getProductKey();

            if (midVal < key)
            {
                low = mid + 1;
            }
            else if (midVal > key)
            {
                high = mid - 1;
            }
            else
            {
                return mid; // key found
            }
        }

        return -(low + 1);  // key not found.
    }
    public static RecapContainerV4IF[] sort(RecapContainerV4IF[] array)
    {
        Arrays.sort(array, RecapContainerV4ByProductKeyComparator);

        return array;
    }
    public static RecapContainerV4IF[] arrayclone(RecapContainerV4IF from)
    {
        RecapContainerV4IF[] to = new RecapContainerV4[1];

        to[0] = from;

        return to;
    }

    public static RecapContainerV4IF[] arrayclone(RecapContainerV4IF[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapContainerV4IF[]) from.clone();
    }

    public static RecapContainerV4IF[] arrayclone(RecapContainerV4IF[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[] to = new RecapContainerV4[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapContainerV4IF[] arrayclone(RecapContainerV4IF[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[] to = new RecapContainerV4[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapContainerV4IF[] arraycloneCombine(RecapContainerV4IF[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[] to = new RecapContainerV4[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapContainerV4IF[] arraycloneExpandGap(RecapContainerV4IF[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[] to = new RecapContainerV4[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapContainerV4IF[][] arrayclone(RecapContainerV4IF[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (RecapContainerV4IF[][]) from.clone();
    }

    public static RecapContainerV4IF[][] arraycloneDimensions(RecapContainerV4IF[][] from)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[][] to = new RecapContainerV4[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static RecapContainerV4IF[][] arrayclone(RecapContainerV4IF[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[][] to = new RecapContainerV4[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static RecapContainerV4IF[][] arrayclone(RecapContainerV4IF[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[][] to = new RecapContainerV4[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static RecapContainerV4IF[][] arraycloneCombine(RecapContainerV4IF[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[][] to = new RecapContainerV4[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static RecapContainerV4IF[][] arraycloneExpandGap(RecapContainerV4IF[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[][] to = new RecapContainerV4[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static RecapContainerV4IF[] arraycloneShrinkGap(RecapContainerV4IF[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        RecapContainerV4IF[] to = new RecapContainerV4[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static RecapContainerV4IF[][] arraycloneShrinkGap(RecapContainerV4IF[][] from, int gapOffset, int gapLength)
    {
            if (from == null)
            {
                return null;
            }

            RecapContainerV4IF[][] to = new RecapContainerV4[from.length - gapLength][];
            System.arraycopy(from, 0,                     to, 0,         gapOffset);
            System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
            return to;
    }


    public static final AscendingTickerStructByProductKeyComparator TickerStructByProductKeyComparator = new AscendingTickerStructByProductKeyComparator();
    public static class AscendingTickerStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((TickerStruct) objectA).productKeys.productKey - ((TickerStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(TickerStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(TickerStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static TickerStruct[] sort(TickerStruct[] array)
    {
        Arrays.sort(array, TickerStructByProductKeyComparator);

        return array;
    }
    public static TickerStruct[] arrayclone(TickerStruct from)
    {
        TickerStruct[] to = new TickerStruct[1];

        to[0] = from;

        return to;
    }

    public static TickerStruct[] arrayclone(TickerStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (TickerStruct[]) from.clone();
    }

    public static TickerStruct[] arrayclone(TickerStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[] to = new TickerStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static TickerStruct[] arrayclone(TickerStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[] to = new TickerStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static TickerStruct[] arraycloneCombine(TickerStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[] to = new TickerStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static TickerStruct[] arraycloneExpandGap(TickerStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[] to = new TickerStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static TickerStruct[][] arrayclone(TickerStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (TickerStruct[][]) from.clone();
    }

    public static TickerStruct[][] arraycloneDimensions(TickerStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static TickerStruct[][] arrayclone(TickerStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static TickerStruct[][] arrayclone(TickerStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static TickerStruct[][] arraycloneCombine(TickerStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static TickerStruct[][] arraycloneExpandGap(TickerStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static TickerStruct[] arraycloneShrinkGap(TickerStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[] to = new TickerStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static TickerStruct[][] arraycloneShrinkGap(TickerStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStruct[][] to = new TickerStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingTickerStructV4ByProductKeyComparator TickerStructV4ByProductKeyComparator = new AscendingTickerStructV4ByProductKeyComparator();
    public static class AscendingTickerStructV4ByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((TickerStructV4) objectA).productKey - ((TickerStructV4) objectB).productKey;
        }
    }
    public static int binarySearch(TickerStructV4[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(TickerStructV4[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static TickerStructV4[] sort(TickerStructV4[] array)
    {
        Arrays.sort(array, TickerStructV4ByProductKeyComparator);

        return array;
    }
    public static TickerStructV4[] arrayclone(TickerStructV4 from)
    {
        TickerStructV4[] to = new TickerStructV4[1];

        to[0] = from;

        return to;
    }

    public static TickerStructV4[] arrayclone(TickerStructV4[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (TickerStructV4[]) from.clone();
    }

    public static TickerStructV4[] arrayclone(TickerStructV4[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[] to = new TickerStructV4[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static TickerStructV4[] arrayclone(TickerStructV4[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[] to = new TickerStructV4[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static TickerStructV4[] arraycloneCombine(TickerStructV4[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[] to = new TickerStructV4[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static TickerStructV4[] arraycloneExpandGap(TickerStructV4[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[] to = new TickerStructV4[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static TickerStructV4[][] arrayclone(TickerStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (TickerStructV4[][]) from.clone();
    }

    public static TickerStructV4[][] arraycloneDimensions(TickerStructV4[][] from)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static TickerStructV4[][] arrayclone(TickerStructV4[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static TickerStructV4[][] arrayclone(TickerStructV4[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static TickerStructV4[][] arraycloneCombine(TickerStructV4[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static TickerStructV4[][] arraycloneExpandGap(TickerStructV4[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static TickerStructV4[] arraycloneShrinkGap(TickerStructV4[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[] to = new TickerStructV4[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static TickerStructV4[][] arraycloneShrinkGap(TickerStructV4[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        TickerStructV4[][] to = new TickerStructV4[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingExpectedOpeningPriceStructByProductKeyComparator ExpectedOpeningPriceStructByProductKeyComparator = new AscendingExpectedOpeningPriceStructByProductKeyComparator();
    public static class AscendingExpectedOpeningPriceStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((ExpectedOpeningPriceStruct) objectA).productKeys.productKey - ((ExpectedOpeningPriceStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(ExpectedOpeningPriceStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(ExpectedOpeningPriceStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static ExpectedOpeningPriceStruct[] sort(ExpectedOpeningPriceStruct[] array)
    {
        Arrays.sort(array, ExpectedOpeningPriceStructByProductKeyComparator);

        return array;
    }
    public static ExpectedOpeningPriceStruct[] arrayclone(ExpectedOpeningPriceStruct from)
    {
        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[1];

        to[0] = from;

        return to;
    }

    public static ExpectedOpeningPriceStruct[] arrayclone(ExpectedOpeningPriceStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ExpectedOpeningPriceStruct[]) from.clone();
    }

    public static ExpectedOpeningPriceStruct[] arrayclone(ExpectedOpeningPriceStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ExpectedOpeningPriceStruct[] arrayclone(ExpectedOpeningPriceStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ExpectedOpeningPriceStruct[] arraycloneCombine(ExpectedOpeningPriceStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ExpectedOpeningPriceStruct[] arraycloneExpandGap(ExpectedOpeningPriceStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arrayclone(ExpectedOpeningPriceStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ExpectedOpeningPriceStruct[][]) from.clone();
    }

    public static ExpectedOpeningPriceStruct[][] arraycloneDimensions(ExpectedOpeningPriceStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arrayclone(ExpectedOpeningPriceStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arrayclone(ExpectedOpeningPriceStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arraycloneCombine(ExpectedOpeningPriceStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arraycloneExpandGap(ExpectedOpeningPriceStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ExpectedOpeningPriceStruct[] arraycloneShrinkGap(ExpectedOpeningPriceStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[] to = new ExpectedOpeningPriceStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static ExpectedOpeningPriceStruct[][] arraycloneShrinkGap(ExpectedOpeningPriceStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ExpectedOpeningPriceStruct[][] to = new ExpectedOpeningPriceStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingNBBOStructByProductKeyComparator NBBOStructByProductKeyComparator = new AscendingNBBOStructByProductKeyComparator();
    public static class AscendingNBBOStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((NBBOStruct) objectA).productKeys.productKey - ((NBBOStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(NBBOStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(NBBOStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static NBBOStruct[] sort(NBBOStruct[] array)
    {
        Arrays.sort(array, NBBOStructByProductKeyComparator);

        return array;
    }
    public static NBBOStruct[] arrayclone(NBBOStruct from)
    {
        NBBOStruct[] to = new NBBOStruct[1];

        to[0] = from;

        return to;
    }

    public static NBBOStruct[] arrayclone(NBBOStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (NBBOStruct[]) from.clone();
    }

    public static NBBOStruct[] arrayclone(NBBOStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[] to = new NBBOStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static NBBOStruct[] arrayclone(NBBOStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[] to = new NBBOStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static NBBOStruct[] arraycloneCombine(NBBOStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[] to = new NBBOStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static NBBOStruct[] arraycloneExpandGap(NBBOStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[] to = new NBBOStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static NBBOStruct[][] arrayclone(NBBOStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (NBBOStruct[][]) from.clone();
    }

    public static NBBOStruct[][] arraycloneDimensions(NBBOStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static NBBOStruct[][] arrayclone(NBBOStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static NBBOStruct[][] arrayclone(NBBOStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static NBBOStruct[][] arraycloneCombine(NBBOStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static NBBOStruct[][] arraycloneExpandGap(NBBOStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static NBBOStruct[] arraycloneShrinkGap(NBBOStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[] to = new NBBOStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static NBBOStruct[][] arraycloneShrinkGap(NBBOStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        NBBOStruct[][] to = new NBBOStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingSessionProductStructByProductKeyComparator SessionProductStructByProductKeyComparator = new AscendingSessionProductStructByProductKeyComparator();
    public static class AscendingSessionProductStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((SessionProductStruct) objectA).productStruct.productKeys.productKey - ((SessionProductStruct) objectB).productStruct.productKeys.productKey;
        }
    }

    public static final AscendingSessionProductStructByClassAndProductKeyComparator SessionProductStructByClassAndProductKeyComparator = new AscendingSessionProductStructByClassAndProductKeyComparator();
    public static class AscendingSessionProductStructByClassAndProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            int c = ((SessionClassStruct) objectA).classStruct.classKey - ((SessionClassStruct) objectB).classStruct.classKey;
            if (c != 0)
            {
                return c;
            }
            return ((SessionProductStruct) objectA).productStruct.productKeys.productKey - ((SessionProductStruct) objectB).productStruct.productKeys.productKey;
        }
    }
    public static int binarySearch(SessionProductStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productStruct.productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(SessionProductStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productStruct.productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static SessionProductStruct[] sort(SessionProductStruct[] array)
    {
        Arrays.sort(array, SessionProductStructByProductKeyComparator);

        return array;
    }
    public static SessionProductStruct[] arrayclone(SessionProductStruct from)
    {
        SessionProductStruct[] to = new SessionProductStruct[1];

        to[0] = from;

        return to;
    }

    public static SessionProductStruct[] arrayclone(SessionProductStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (SessionProductStruct[]) from.clone();
    }

    public static SessionProductStruct[] arrayclone(SessionProductStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[] to = new SessionProductStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static SessionProductStruct[] arrayclone(SessionProductStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[] to = new SessionProductStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static SessionProductStruct[] arraycloneCombine(SessionProductStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[] to = new SessionProductStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static SessionProductStruct[] arraycloneExpandGap(SessionProductStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[] to = new SessionProductStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static SessionProductStruct[][] arrayclone(SessionProductStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (SessionProductStruct[][]) from.clone();
    }

    public static SessionProductStruct[][] arraycloneDimensions(SessionProductStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static SessionProductStruct[][] arrayclone(SessionProductStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static SessionProductStruct[][] arrayclone(SessionProductStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static SessionProductStruct[][] arraycloneCombine(SessionProductStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static SessionProductStruct[][] arraycloneExpandGap(SessionProductStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static SessionProductStruct[] arraycloneShrinkGap(SessionProductStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[] to = new SessionProductStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static SessionProductStruct[][] arraycloneShrinkGap(SessionProductStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionProductStruct[][] to = new SessionProductStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingSessionClassStructByClassKeyComparator SessionClassStructByClassKeyComparator = new AscendingSessionClassStructByClassKeyComparator();
    public static class AscendingSessionClassStructByClassKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((SessionClassStruct) objectA).classStruct.classKey - ((SessionClassStruct) objectB).classStruct.classKey;
        }
    }
    public static int binarySearch(SessionClassStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].classStruct.classKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(SessionClassStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].classStruct.classKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static SessionClassStruct[] sort(SessionClassStruct[] array)
    {
        Arrays.sort(array, SessionClassStructByClassKeyComparator);

        return array;
    }
    public static SessionClassStruct[] arrayclone(SessionClassStruct from)
    {
        SessionClassStruct[] to = new SessionClassStruct[1];

        to[0] = from;

        return to;
    }

    public static SessionClassStruct[] arrayclone(SessionClassStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (SessionClassStruct[]) from.clone();
    }

    public static SessionClassStruct[] arrayclone(SessionClassStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[] to = new SessionClassStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static SessionClassStruct[] arrayclone(SessionClassStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[] to = new SessionClassStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static SessionClassStruct[] arraycloneCombine(SessionClassStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[] to = new SessionClassStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static SessionClassStruct[] arraycloneExpandGap(SessionClassStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[] to = new SessionClassStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static SessionClassStruct[][] arrayclone(SessionClassStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (SessionClassStruct[][]) from.clone();
    }

    public static SessionClassStruct[][] arraycloneDimensions(SessionClassStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static SessionClassStruct[][] arrayclone(SessionClassStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static SessionClassStruct[][] arrayclone(SessionClassStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static SessionClassStruct[][] arraycloneCombine(SessionClassStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static SessionClassStruct[][] arraycloneExpandGap(SessionClassStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static SessionClassStruct[] arraycloneShrinkGap(SessionClassStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[] to = new SessionClassStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static SessionClassStruct[][] arraycloneShrinkGap(SessionClassStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        SessionClassStruct[][] to = new SessionClassStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingProductStructByProductKeyComparator ProductStructByProductKeyComparator = new AscendingProductStructByProductKeyComparator();
    public static class AscendingProductStructByProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((ProductStruct) objectA).productKeys.productKey - ((ProductStruct) objectB).productKeys.productKey;
        }
    }

    public static final AscendingProductStructByClassAndProductKeyComparator ProductStructByClassAndProductKeyComparator = new AscendingProductStructByClassAndProductKeyComparator();
    public static class AscendingProductStructByClassAndProductKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            int c = ((ClassStruct) objectA).classKey - ((ClassStruct) objectB).classKey;
            if (c != 0)
            {
                return c;
            }
            return ((ProductStruct) objectA).productKeys.productKey - ((ProductStruct) objectB).productKeys.productKey;
        }
    }
    public static int binarySearch(ProductStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(ProductStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].productKeys.productKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static ProductStruct[] sort(ProductStruct[] array)
    {
        Arrays.sort(array, ProductStructByProductKeyComparator);

        return array;
    }
    public static ProductStruct[] arrayclone(ProductStruct from)
    {
        ProductStruct[] to = new ProductStruct[1];

        to[0] = from;

        return to;
    }

    public static ProductStruct[] arrayclone(ProductStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ProductStruct[]) from.clone();
    }

    public static ProductStruct[] arrayclone(ProductStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[] to = new ProductStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ProductStruct[] arrayclone(ProductStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[] to = new ProductStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ProductStruct[] arraycloneCombine(ProductStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[] to = new ProductStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ProductStruct[] arraycloneExpandGap(ProductStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[] to = new ProductStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ProductStruct[][] arrayclone(ProductStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ProductStruct[][]) from.clone();
    }

    public static ProductStruct[][] arraycloneDimensions(ProductStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static ProductStruct[][] arrayclone(ProductStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ProductStruct[][] arrayclone(ProductStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ProductStruct[][] arraycloneCombine(ProductStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ProductStruct[][] arraycloneExpandGap(ProductStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ProductStruct[] arraycloneShrinkGap(ProductStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[] to = new ProductStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static ProductStruct[][] arraycloneShrinkGap(ProductStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ProductStruct[][] to = new ProductStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static final AscendingClassStructByClassKeyComparator ClassStructByClassKeyComparator = new AscendingClassStructByClassKeyComparator();
    public static class AscendingClassStructByClassKeyComparator implements Comparator
    {
        public int compare(Object objectA, Object objectB)
        {
            return ((ClassStruct) objectA).classKey - ((ClassStruct) objectB).classKey;
        }
    }
    public static ClassStruct[] sort(ClassStruct[] array)
    {
        Arrays.sort(array, ClassStructByClassKeyComparator);

        return array;
    }
    public static int binarySearch(ClassStruct[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].classKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(ClassStruct[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid].classKey;

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static ClassStruct[] arrayclone(ClassStruct from)
    {
        ClassStruct[] to = new ClassStruct[1];

        to[0] = from;

        return to;
    }

    public static ClassStruct[] arrayclone(ClassStruct[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ClassStruct[]) from.clone();
    }

    public static ClassStruct[] arrayclone(ClassStruct[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[] to = new ClassStruct[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ClassStruct[] arrayclone(ClassStruct[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[] to = new ClassStruct[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ClassStruct[] arraycloneCombine(ClassStruct[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[] to = new ClassStruct[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ClassStruct[] arraycloneExpandGap(ClassStruct[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[] to = new ClassStruct[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ClassStruct[][] arrayclone(ClassStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (ClassStruct[][]) from.clone();
    }

    public static ClassStruct[][] arraycloneDimensions(ClassStruct[][] from)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static ClassStruct[][] arrayclone(ClassStruct[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static ClassStruct[][] arrayclone(ClassStruct[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static ClassStruct[][] arraycloneCombine(ClassStruct[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static ClassStruct[][] arraycloneExpandGap(ClassStruct[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static ClassStruct[] arraycloneShrinkGap(ClassStruct[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[] to = new ClassStruct[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static ClassStruct[][] arraycloneShrinkGap(ClassStruct[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        ClassStruct[][] to = new ClassStruct[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }


    public static int binarySearch(int[] array, int key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid];

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(int[] array, int key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    int midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid];

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static int[] arrayclone(int from)
    {
        int[] to = new int[1];

        to[0] = from;

        return to;
    }

    public static int[] arrayclone(int[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (int[]) from.clone();
    }

    public static int[] arrayclone(int[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[] to = new int[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static int[] arrayclone(int[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[] to = new int[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static int[] arraycloneCombine(int[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[] to = new int[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static int[] arraycloneExpandGap(int[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        int[] to = new int[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static int[][] arrayclone(int[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (int[][]) from.clone();
    }

    public static int[][] arraycloneDimensions(int[][] from)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static int[][] arrayclone(int[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static int[][] arrayclone(int[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static int[][] arraycloneCombine(int[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static int[][] arraycloneExpandGap(int[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static int[] arraycloneShrinkGap(int[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        int[] to = new int[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static int[][] arraycloneShrinkGap(int[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        int[][] to = new int[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static int binarySearch(long[] array, long key)
    {
	    int high = array.length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    long midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid];

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }

    public static int binarySearch(long[] array, long key, int length)
    {
	    int high = length - 1;
        if (high < 0)
        {
            return -1;
        }

	    int low  = 0;
	    int mid;
	    long midVal;

	    while (low <= high)
        {
	        mid    = (low + high) >> 1;
	        midVal = array[mid];

	        if (midVal < key)
            {
		        low = mid + 1;
            }
	        else if (midVal > key)
            {
		        high = mid - 1;
            }
	        else
            {
		        return mid; // key found
            }
	    }

	    return -(low + 1);  // key not found.
    }
    public static long[] arrayclone(long from)
    {
        long[] to = new long[1];

        to[0] = from;

        return to;
    }

    public static long[] arrayclone(long[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (long[]) from.clone();
    }

    public static long[] arrayclone(long[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[] to = new long[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static long[] arrayclone(long[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[] to = new long[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static long[] arraycloneCombine(long[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[] to = new long[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static long[] arraycloneExpandGap(long[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        long[] to = new long[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static long[][] arrayclone(long[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (long[][]) from.clone();
    }

    public static long[][] arraycloneDimensions(long[][] from)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static long[][] arrayclone(long[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static long[][] arrayclone(long[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static long[][] arraycloneCombine(long[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static long[][] arraycloneExpandGap(long[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static long[] arraycloneShrinkGap(long[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        long[] to = new long[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static long[][] arraycloneShrinkGap(long[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        long[][] to = new long[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Object[] arrayclone(Object from)
    {
        Object[] to = new Object[1];

        to[0] = from;

        return to;
    }

    public static Object[] arrayclone(Object[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Object[]) from.clone();
    }

    public static Object[] arrayclone(Object[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[] to = new Object[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Object[] arrayclone(Object[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[] to = new Object[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Object[] arraycloneCombine(Object[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[] to = new Object[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Object[] arraycloneExpandGap(Object[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Object[] to = new Object[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Object[][] arrayclone(Object[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Object[][]) from.clone();
    }

    public static Object[][] arraycloneDimensions(Object[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Object[][] arrayclone(Object[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Object[][] arrayclone(Object[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Object[][] arraycloneCombine(Object[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Object[][] arraycloneExpandGap(Object[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Object[] arraycloneShrinkGap(Object[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Object[] to = new Object[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Object[][] arraycloneShrinkGap(Object[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Object[][] to = new Object[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static String[] arrayclone(String from)
    {
        String[] to = new String[1];

        to[0] = from;

        return to;
    }

    public static String[] arrayclone(String[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (String[]) from.clone();
    }

    public static String[] arrayclone(String[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[] to = new String[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static String[] arrayclone(String[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[] to = new String[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static String[] arraycloneCombine(String[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[] to = new String[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static String[] arraycloneExpandGap(String[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        String[] to = new String[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static String[][] arrayclone(String[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (String[][]) from.clone();
    }

    public static String[][] arraycloneDimensions(String[][] from)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static String[][] arrayclone(String[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static String[][] arrayclone(String[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static String[][] arraycloneCombine(String[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static String[][] arraycloneExpandGap(String[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static String[] arraycloneShrinkGap(String[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        String[] to = new String[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static String[][] arraycloneShrinkGap(String[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        String[][] to = new String[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Comparable[] arrayclone(Comparable from)
    {
        Comparable[] to = new Comparable[1];

        to[0] = from;

        return to;
    }

    public static Comparable[] arrayclone(Comparable[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Comparable[]) from.clone();
    }

    public static Comparable[] arrayclone(Comparable[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[] to = new Comparable[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Comparable[] arrayclone(Comparable[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[] to = new Comparable[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Comparable[] arraycloneCombine(Comparable[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[] to = new Comparable[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Comparable[] arraycloneExpandGap(Comparable[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[] to = new Comparable[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Comparable[][] arrayclone(Comparable[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Comparable[][]) from.clone();
    }

    public static Comparable[][] arraycloneDimensions(Comparable[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Comparable[][] arrayclone(Comparable[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Comparable[][] arrayclone(Comparable[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Comparable[][] arraycloneCombine(Comparable[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Comparable[][] arraycloneExpandGap(Comparable[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Comparable[] arraycloneShrinkGap(Comparable[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[] to = new Comparable[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Comparable[][] arraycloneShrinkGap(Comparable[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Comparable[][] to = new Comparable[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Integer[] arrayclone(Integer from)
    {
        Integer[] to = new Integer[1];

        to[0] = from;

        return to;
    }

    public static Integer[] arrayclone(Integer[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Integer[]) from.clone();
    }

    public static Integer[] arrayclone(Integer[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[] to = new Integer[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Integer[] arrayclone(Integer[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[] to = new Integer[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Integer[] arraycloneCombine(Integer[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[] to = new Integer[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Integer[] arraycloneExpandGap(Integer[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Integer[] to = new Integer[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Integer[][] arrayclone(Integer[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Integer[][]) from.clone();
    }

    public static Integer[][] arraycloneDimensions(Integer[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Integer[][] arrayclone(Integer[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Integer[][] arrayclone(Integer[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Integer[][] arraycloneCombine(Integer[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Integer[][] arraycloneExpandGap(Integer[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Integer[] arraycloneShrinkGap(Integer[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Integer[] to = new Integer[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Integer[][] arraycloneShrinkGap(Integer[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Integer[][] to = new Integer[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Long[] arrayclone(Long from)
    {
        Long[] to = new Long[1];

        to[0] = from;

        return to;
    }

    public static Long[] arrayclone(Long[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Long[]) from.clone();
    }

    public static Long[] arrayclone(Long[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[] to = new Long[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Long[] arrayclone(Long[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[] to = new Long[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Long[] arraycloneCombine(Long[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[] to = new Long[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Long[] arraycloneExpandGap(Long[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Long[] to = new Long[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Long[][] arrayclone(Long[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Long[][]) from.clone();
    }

    public static Long[][] arraycloneDimensions(Long[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Long[][] arrayclone(Long[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Long[][] arrayclone(Long[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Long[][] arraycloneCombine(Long[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Long[][] arraycloneExpandGap(Long[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Long[] arraycloneShrinkGap(Long[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Long[] to = new Long[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Long[][] arraycloneShrinkGap(Long[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Long[][] to = new Long[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Short[] arrayclone(Short from)
    {
        Short[] to = new Short[1];

        to[0] = from;

        return to;
    }

    public static Short[] arrayclone(Short[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Short[]) from.clone();
    }

    public static Short[] arrayclone(Short[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[] to = new Short[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Short[] arrayclone(Short[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[] to = new Short[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Short[] arraycloneCombine(Short[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[] to = new Short[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Short[] arraycloneExpandGap(Short[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Short[] to = new Short[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Short[][] arrayclone(Short[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Short[][]) from.clone();
    }

    public static Short[][] arraycloneDimensions(Short[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Short[][] arrayclone(Short[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Short[][] arrayclone(Short[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Short[][] arraycloneCombine(Short[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Short[][] arraycloneExpandGap(Short[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Short[] arraycloneShrinkGap(Short[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Short[] to = new Short[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Short[][] arraycloneShrinkGap(Short[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Short[][] to = new Short[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static short[] arrayclone(short from)
    {
        short[] to = new short[1];

        to[0] = from;

        return to;
    }

    public static short[] arrayclone(short[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (short[]) from.clone();
    }

    public static short[] arrayclone(short[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[] to = new short[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static short[] arrayclone(short[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[] to = new short[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static short[] arraycloneCombine(short[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[] to = new short[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static short[] arraycloneExpandGap(short[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        short[] to = new short[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static short[][] arrayclone(short[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (short[][]) from.clone();
    }

    public static short[][] arraycloneDimensions(short[][] from)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static short[][] arrayclone(short[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static short[][] arrayclone(short[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static short[][] arraycloneCombine(short[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static short[][] arraycloneExpandGap(short[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static short[] arraycloneShrinkGap(short[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        short[] to = new short[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static short[][] arraycloneShrinkGap(short[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        short[][] to = new short[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Byte[] arrayclone(Byte from)
    {
        Byte[] to = new Byte[1];

        to[0] = from;

        return to;
    }

    public static Byte[] arrayclone(Byte[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Byte[]) from.clone();
    }

    public static Byte[] arrayclone(Byte[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[] to = new Byte[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Byte[] arrayclone(Byte[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[] to = new Byte[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Byte[] arraycloneCombine(Byte[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[] to = new Byte[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Byte[] arraycloneExpandGap(Byte[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Byte[] to = new Byte[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Byte[][] arrayclone(Byte[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Byte[][]) from.clone();
    }

    public static Byte[][] arraycloneDimensions(Byte[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Byte[][] arrayclone(Byte[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Byte[][] arrayclone(Byte[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Byte[][] arraycloneCombine(Byte[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Byte[][] arraycloneExpandGap(Byte[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Byte[] arraycloneShrinkGap(Byte[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Byte[] to = new Byte[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Byte[][] arraycloneShrinkGap(Byte[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Byte[][] to = new Byte[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static byte[] arrayclone(byte from)
    {
        byte[] to = new byte[1];

        to[0] = from;

        return to;
    }

    public static byte[] arrayclone(byte[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (byte[]) from.clone();
    }

    public static byte[] arrayclone(byte[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[] to = new byte[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static byte[] arrayclone(byte[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[] to = new byte[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static byte[] arraycloneCombine(byte[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[] to = new byte[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static byte[] arraycloneExpandGap(byte[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        byte[] to = new byte[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static byte[][] arrayclone(byte[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (byte[][]) from.clone();
    }

    public static byte[][] arraycloneDimensions(byte[][] from)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static byte[][] arrayclone(byte[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static byte[][] arrayclone(byte[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static byte[][] arraycloneCombine(byte[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static byte[][] arraycloneExpandGap(byte[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static byte[] arraycloneShrinkGap(byte[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        byte[] to = new byte[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static byte[][] arraycloneShrinkGap(byte[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        byte[][] to = new byte[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Character[] arrayclone(Character from)
    {
        Character[] to = new Character[1];

        to[0] = from;

        return to;
    }

    public static Character[] arrayclone(Character[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Character[]) from.clone();
    }

    public static Character[] arrayclone(Character[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[] to = new Character[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Character[] arrayclone(Character[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[] to = new Character[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Character[] arraycloneCombine(Character[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[] to = new Character[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Character[] arraycloneExpandGap(Character[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Character[] to = new Character[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Character[][] arrayclone(Character[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (Character[][]) from.clone();
    }

    public static Character[][] arraycloneDimensions(Character[][] from)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static Character[][] arrayclone(Character[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static Character[][] arrayclone(Character[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static Character[][] arraycloneCombine(Character[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static Character[][] arraycloneExpandGap(Character[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static Character[] arraycloneShrinkGap(Character[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Character[] to = new Character[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static Character[][] arraycloneShrinkGap(Character[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        Character[][] to = new Character[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static char[] arrayclone(char from)
    {
        char[] to = new char[1];

        to[0] = from;

        return to;
    }

    public static char[] arrayclone(char[] from)
    {
        if (from == null)
        {
            return null;
        }

        return (char[]) from.clone();
    }

    public static char[] arrayclone(char[] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[] to = new char[toSize];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static char[] arrayclone(char[] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[] to = new char[toSize];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static char[] arraycloneCombine(char[] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[] to = new char[toSize];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static char[] arraycloneExpandGap(char[] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        char[] to = new char[toSize];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static char[][] arrayclone(char[][] from)
    {
        if (from == null)
        {
            return null;
        }

        return (char[][]) from.clone();
    }

    public static char[][] arraycloneDimensions(char[][] from)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[from.length][];
        System.arraycopy(from, 0, to, 0, from.length);
        for (int i = 0; i < from.length; i++)
        {
            to[i] = arrayclone(from[i]);
        }
        return to;
    }

    public static char[][] arrayclone(char[][] from, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[toSize][];
        System.arraycopy(from, 0, to, 0, from.length);
        return to;
    }

    public static char[][] arrayclone(char[][] from, int fromOffset, int fromSize, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[toSize][];
        System.arraycopy(from, fromOffset, to, 0, fromSize);
        return to;
    }

    public static char[][] arraycloneCombine(char[][] from, int startOffset, int endOffset, int toSize)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[toSize][];
        int firstPortion = from.length - startOffset;
        System.arraycopy(from, startOffset, to, 0,            firstPortion);
        System.arraycopy(from, 0,           to, firstPortion, endOffset);
        return to;
    }

    public static char[][] arraycloneExpandGap(char[][] from, int fromOffset, int fromSize, int toSize, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[toSize][];
        int gap = gapOffset + gapLength;
        System.arraycopy(from, fromOffset, to, 0,   gapOffset);
        System.arraycopy(from, gapOffset,  to, gap, fromSize - gapOffset);
        return to;
    }

    public static char[] arraycloneShrinkGap(char[] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        char[] to = new char[from.length - gapLength];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }

    public static char[][] arraycloneShrinkGap(char[][] from, int gapOffset, int gapLength)
    {
        if (from == null)
        {
            return null;
        }

        char[][] to = new char[from.length - gapLength][];
        System.arraycopy(from, 0,                     to, 0,         gapOffset);
        System.arraycopy(from, gapOffset + gapLength, to, gapOffset, to.length - gapOffset);
        return to;
    }
}

