#if ( ${KEY_TYPE} == "Int" )
#set ( $KEY_TYPE = "int" )
#elseif ( ${KEY_TYPE} == "Long" )
#set ( $KEY_TYPE = "long" )
#end
#if ( ${VALUE_TYPE} == "Int" )
#set ( $VALUE_TYPE = "int" )
#elseif ( ${VALUE_TYPE} == "Long" )
#set ( $VALUE_TYPE = "long" )
#end
#if ( ${KEY_TYPE} == "int" )
    #set ( $__dont_fill_in_key_hashcode       = "key" )
    #set ( $__dont_fill_in_key_name           = "Int" )
    #set ( $__dont_fill_in_key_holder_name    = "Int" )
    #set ( $__dont_fill_in_key_visitor_name   = "Int" )
#elseif ( ${KEY_TYPE} == "long" )
    #set ( $__dont_fill_in_key_hashcode       = "key" )
    #set ( $__dont_fill_in_key_name           = "Long" )
    #set ( $__dont_fill_in_key_holder_name    = "Long" )
    #set ( $__dont_fill_in_key_visitor_name   = "Long" )
#else
    #set ( $__dont_fill_in_key_hashcode       = "key.hashCode()" )
    #set ( $__dont_fill_in_key_name           = "${KEY_TYPE}" )
    #set ( $__dont_fill_in_key_holder_name    = "Object" )
    #set ( $__dont_fill_in_key_visitor_name   = "Object" )
#end
#if ( ${VALUE_TYPE} == "int" )
    #set ( $__dont_fill_in_value_name         = "Int" )
    #set ( $__dont_fill_in_value_holder_name  = "Int" )
    #set ( $__dont_fill_in_value_visitor_name = "Int" )
    #set ( $__dont_fill_in_value_equality     = "if (value == local_multivalues[multiIndex])" )
#elseif ( ${VALUE_TYPE} == "long" )
    #set ( $__dont_fill_in_value_name         = "Long" )
    #set ( $__dont_fill_in_value_holder_name  = "Long" )
    #set ( $__dont_fill_in_value_visitor_name = "Long" )
    #set ( $__dont_fill_in_value_equality     = "if (value == local_multivalues[multiIndex])" )
#elseif ( ${VALUE_TYPE} == "String" )
    #set ( $__dont_fill_in_value_name         = "${VALUE_TYPE}" )
    #set ( $__dont_fill_in_value_holder_name  = "String" )
    #set ( $__dont_fill_in_value_visitor_name = "Object" )
    #set ( $__dont_fill_in_value_equality     = "if (value == local_multivalues[multiIndex] || value.compareTo(local_multivalues[multiIndex]) == 0)" )
#else
    #set ( $__dont_fill_in_value_name         = "${VALUE_TYPE}" )
    #set ( $__dont_fill_in_value_holder_name  = "Object" )
    #set ( $__dont_fill_in_value_visitor_name = "Object" )
    #set ( $__dont_fill_in_value_equality     = "if (value == local_multivalues[multiIndex] || value.equals(local_multivalues[multiIndex]))" )
#end
#set ( $__dont_fill_in_visitor     = "${__dont_fill_in_key_visitor_name}${__dont_fill_in_value_visitor_name}VisitorIF" )
#set ( $__dont_fill_in_policy      = "${__dont_fill_in_key_visitor_name}${__dont_fill_in_value_visitor_name}KeyValuePolicyIF" )
#set ( $__dont_fill_in_class_name  = "${__dont_fill_in_key_name}${__dont_fill_in_value_name}MultipleValuesMap" )
package com.cboe.client.util.collections;

/**
 * ${__dont_fill_in_class_name}.java
 *
 * @author Dmitry Volpyansky
 *
 * FILE GENERATED BY VELOCITY TEMPLATE ENGINE FROM /vobs/dte/client/generator/DV_XYMultipleValuesMap.java (KEY_TYPE=${KEY_TYPE}, VALUE_TYPE=${VALUE_TYPE}, THIRD_TYPE=${THIRD_TYPE})
 *
 */

import com.cboe.client.util.*;

public class ${__dont_fill_in_class_name} implements HasSizeIF
{
    protected ${KEY_TYPE}[][]   keys;
    protected ${VALUE_TYPE}[][][] values;
    protected int[]        numberKeys;
    protected int          tableHighestIndex;
    protected volatile int size;

#if ( ${VALUE_TYPE} == "int" || ${VALUE_TYPE} == "long" )
    public ${VALUE_TYPE} ValueNotFound = IntegerHelper.INVALID_VALUE;
#else
    public ${VALUE_TYPE} ValueNotFound;
#end

    public static final int VALUE_ADDED     = -12345;
    public static final int VALUE_REPLACED  = -23456;
    public static final int VALUE_UNCHANGED = -34567;
    public static final int VALUE_REMOVED   = -45678;

    public static final int DEFAULT_INITIAL_CAPACITY       = 256;
    public static final int DEFAULT_ENTRY_LIST_CAPACITY    = 16;
    public static final int MAXIMUM_CAPACITY               = 1024 * 16;

    public static final ${__dont_fill_in_class_name} unsynchronizedMap()             {return new ${__dont_fill_in_class_name}();}
    public static final ${__dont_fill_in_class_name} unsynchronizedMap(int capacity) {return new ${__dont_fill_in_class_name}(capacity);}
    public static final ${__dont_fill_in_class_name} synchronizedMap()               {return new ${__dont_fill_in_class_name}MT();}
    public static final ${__dont_fill_in_class_name} synchronizedMap(int capacity)   {return new ${__dont_fill_in_class_name}MT(capacity);}

    public static class ${__dont_fill_in_class_name}MT extends ${__dont_fill_in_class_name}
    {
        public ${__dont_fill_in_class_name}MT()
        {
            super();
        }
        public ${__dont_fill_in_class_name}MT(int capacity)
        {
            super(capacity);
        }
        public synchronized int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value)
        {
            return super.putKeyValue(key, value);
        }
        public synchronized int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, ${__dont_fill_in_policy} policy)
        {
            return super.putKeyValue(key, value, policy);
        }
        public synchronized boolean containsKey(${KEY_TYPE} key)
        {
            return super.containsKey(key);
        }
        public synchronized boolean containsValue(${VALUE_TYPE} value)
        {
            return super.containsValue(value);
        }
        public synchronized int countValues(${KEY_TYPE} key)
        {
            return super.countValues(key);
        }
        public synchronized ${VALUE_TYPE} getValueForKeyAt(${KEY_TYPE} key, int multiIndex)
        {
            return super.getValueForKeyAt(key, multiIndex);
        }
        public synchronized void getValuesForKey(${KEY_TYPE} key, ${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
        {
            super.getValuesForKey(key, arrayHolder);
        }
        public synchronized void getKeysForValue(${VALUE_TYPE} value, ${__dont_fill_in_key_holder_name}ArrayHolderIF arrayHolder)
        {
            super.getKeysForValue(value, arrayHolder);
        }
        public synchronized void getData(${__dont_fill_in_key_holder_name}${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
        {
            super.getData(arrayHolder);
        }
        public synchronized int removeKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value)
        {
            return super.removeKeyValue(key, value);
        }
        public int removeKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, MutableInteger mutableInteger)
        {
            return super.removeKeyValue(key, value, mutableInteger);
        }
        public synchronized void removeKey(${KEY_TYPE} key)
        {
            super.removeKey(key);
        }
        public synchronized void removeKey(${KEY_TYPE} key, ${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
        {
            super.removeKey(key, arrayHolder);
        }
        public synchronized void removeValue(${VALUE_TYPE} value)
        {
            super.removeValue(value);
        }
        public synchronized void removeValue(${VALUE_TYPE} value, ${__dont_fill_in_key_holder_name}ArrayHolderIF arrayHolder)
        {
            super.removeValue(value, arrayHolder);
        }
        public synchronized ${__dont_fill_in_visitor} acceptVisitor(${__dont_fill_in_visitor} visitor)
        {
            return super.acceptVisitor(visitor);
        }
        public synchronized ${__dont_fill_in_class_name} clear()
        {
            return super.clear();
        }
        public synchronized ${__dont_fill_in_class_name} clear(${__dont_fill_in_key_holder_name}${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
        {
            return super.clear(arrayHolder);
        }
    };

    public ${__dont_fill_in_class_name}()
    {
        this(DEFAULT_INITIAL_CAPACITY);
    }

    public ${__dont_fill_in_class_name}(int capacity)
    {
        if (capacity < 2)
        {
            capacity = DEFAULT_INITIAL_CAPACITY;
        }
        else if (capacity > MAXIMUM_CAPACITY)
        {
            capacity = MAXIMUM_CAPACITY;
        }
        else
        {
            capacity = IntegerHelper.higherPowerOf2(capacity);
        }

        keys              = new ${KEY_TYPE}[capacity][];
        values            = new ${VALUE_TYPE}[capacity][][];
        numberKeys        = new int[capacity];
        tableHighestIndex = capacity - 1;
    }

    public ${VALUE_TYPE} getValueNotFound()
    {
        return ValueNotFound;
    }

    public ${__dont_fill_in_class_name} setValueNotFound(${VALUE_TYPE} ValueNotFound)
    {
        this.ValueNotFound = ValueNotFound;

        return this;
    }

    public int size()
    {
        return size;
    }

    public boolean isEmpty()
    {
        return size == 0;
    }

    public int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (keys[bucketIndex] == null)
        {
            keys[bucketIndex]       = new ${KEY_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY];
            values[bucketIndex]     = new ${VALUE_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY][];
            keys[bucketIndex][0]    = key;
            values[bucketIndex][0]  = new ${VALUE_TYPE}[] {value};
            numberKeys[bucketIndex] = 1;
            size++;

            return VALUE_ADDED;
        }

        ${KEY_TYPE}[]     local_keys   = keys[bucketIndex];
        ${VALUE_TYPE}[][] local_values = values[bucketIndex];
        int        local_size   = numberKeys[bucketIndex];
        int        keyIndex     = -1;

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.binarySearch(local_keys, key, local_size);
        if (keyIndex >= 0)
        {
            ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
            int multiIndex;

            for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    return VALUE_UNCHANGED;
                }
            }

            local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

            local_values[keyIndex][multiIndex] = value;

            size++;

            return VALUE_ADDED;
	    }
#else
        for (keyIndex = 0; keyIndex < local_size; keyIndex++)
        {
            if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
            {
                ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
                int multiIndex;

                for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
                {
                    ${__dont_fill_in_value_equality}
                    {
                        return VALUE_UNCHANGED;
                    }
                }

                local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

                local_values[keyIndex][multiIndex] = value;

                size++;

                return VALUE_ADDED;
            }
        }
#end

        // if we got here, this is a completely new multivalues

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.normalizeBinarySearchPosition(keyIndex);
#end
        if (local_size >= local_keys.length) // need to expand
        {
            if (keyIndex == local_size) // if at end, then just arrayclone, and append later
            {
                keys[bucketIndex]   = CollectionHelper.arrayclone(local_keys,   0, local_keys.length, local_keys.length << 1);
                values[bucketIndex] = CollectionHelper.arrayclone(local_values, 0, local_keys.length, local_keys.length << 1);
            }
            else
            {
                keys[bucketIndex]   = CollectionHelper.arraycloneExpandGap(local_keys,   0, local_keys.length, local_keys.length << 1, keyIndex, 1);
                values[bucketIndex] = CollectionHelper.arraycloneExpandGap(local_values, 0, local_keys.length, local_keys.length << 1, keyIndex, 1);
            }
        }
        else
        {
            if (keyIndex < local_size)
            {
                System.arraycopy(local_values, keyIndex, local_values, keyIndex + 1, local_size - keyIndex);
                System.arraycopy(local_keys,   keyIndex, local_keys,   keyIndex + 1, local_size - keyIndex);
            }
        }

        keys[bucketIndex][keyIndex]   = key;
        values[bucketIndex][keyIndex] = new ${VALUE_TYPE}[] {value};

        numberKeys[bucketIndex]++;
        size++;

        return VALUE_ADDED;
    }

    public int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, ${__dont_fill_in_policy} policy)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (keys[bucketIndex] == null)
        {
            if (!policy.canInsert(key, value))
            {
                return VALUE_UNCHANGED;
            }

            keys[bucketIndex]       = new ${KEY_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY];
            values[bucketIndex]     = new ${VALUE_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY][];
            keys[bucketIndex][0]    = key;
            values[bucketIndex][0]  = new ${VALUE_TYPE}[] {value};
            numberKeys[bucketIndex] = 1;
            size++;

            return VALUE_ADDED;
        }

        ${KEY_TYPE}[]     local_keys   = keys[bucketIndex];
        ${VALUE_TYPE}[][] local_values = values[bucketIndex];
        int        local_size   = numberKeys[bucketIndex];
        int        keyIndex     = -1;

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.binarySearch(local_keys, key, local_size);
        if (keyIndex >= 0)
        {
            ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
            int multiIndex;

            for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    return VALUE_UNCHANGED;
                }
            }

            if (!policy.canInsert(key, value))
            {
                return VALUE_UNCHANGED;
            }

            local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

            local_values[keyIndex][multiIndex] = value;

            size++;

            return VALUE_ADDED;
	    }
#else
        for (keyIndex = 0; keyIndex < local_size; keyIndex++)
        {
            if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
            {
                ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
                int multiIndex;

                for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
                {
                    ${__dont_fill_in_value_equality}
                    {
                        return VALUE_UNCHANGED;
                    }
                }

                if (!policy.canInsert(key, value))
                {
                    return VALUE_UNCHANGED;
                }

                local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

                local_values[keyIndex][multiIndex] = value;

                size++;

                return VALUE_ADDED;
            }
        }
#end

        // if we got here, this is a completely new multivalues

        if (!policy.canInsert(key, value))
        {
            return VALUE_UNCHANGED;
        }

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.normalizeBinarySearchPosition(keyIndex);
#end
        if (local_size >= local_keys.length) // need to expand
        {
            if (keyIndex == local_size) // if at end, then just arrayclone, and append later
            {
                keys[bucketIndex]   = CollectionHelper.arrayclone(local_keys,   0, local_keys.length, local_keys.length << 1);
                values[bucketIndex] = CollectionHelper.arrayclone(local_values, 0, local_keys.length, local_keys.length << 1);
            }
            else
            {
                keys[bucketIndex]   = CollectionHelper.arraycloneExpandGap(local_keys,   0, local_keys.length, local_keys.length << 1, keyIndex, 1);
                values[bucketIndex] = CollectionHelper.arraycloneExpandGap(local_values, 0, local_keys.length, local_keys.length << 1, keyIndex, 1);
            }
        }
        else
        {
            if (keyIndex < local_size)
            {
                System.arraycopy(local_values, keyIndex, local_values, keyIndex + 1, local_size - keyIndex);
                System.arraycopy(local_keys,   keyIndex, local_keys,   keyIndex + 1, local_size - keyIndex);
            }
        }

        keys[bucketIndex][keyIndex]   = key;
        values[bucketIndex][keyIndex] = new ${VALUE_TYPE}[] {value};

        numberKeys[bucketIndex]++;
        size++;

        return VALUE_ADDED;
    }

    public int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, MutableInteger mutableInteger)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (keys[bucketIndex] == null)
        {
            keys[bucketIndex]       = new ${KEY_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY];
            values[bucketIndex]     = new ${VALUE_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY][];
            keys[bucketIndex][0]    = key;
            values[bucketIndex][0]  = new ${VALUE_TYPE}[] {value};
            numberKeys[bucketIndex] = 1;
            size++;

            mutableInteger.integer = 1;
            return VALUE_ADDED;
        }

        ${KEY_TYPE}[]     local_keys   = keys[bucketIndex];
        ${VALUE_TYPE}[][] local_values = values[bucketIndex];
        int        local_size   = numberKeys[bucketIndex];
        int        keyIndex     = -1;

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.binarySearch(local_keys, key, local_size);
        if (keyIndex >= 0)
        {
            ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
            int multiIndex;

            for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    mutableInteger.integer = local_multivalues.length;
                    return VALUE_UNCHANGED;
                }
            }

            local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

            local_values[keyIndex][multiIndex] = value;

            size++;

            mutableInteger.integer = local_values[keyIndex].length;
            return VALUE_ADDED;
	    }
#else
        for (keyIndex = 0; keyIndex < local_size; keyIndex++)
        {
            if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
            {
                ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
                int multiIndex;

                for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
                {
                    ${__dont_fill_in_value_equality}
                    {
                        mutableInteger.integer = local_multivalues.length;
                        return VALUE_UNCHANGED;
                    }
                }

                local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

                local_values[keyIndex][multiIndex] = value;

                size++;

                mutableInteger.integer = local_values[keyIndex].length;
                return VALUE_ADDED;
            }
        }
#end

        // if we got here, this is a completely new multivalues

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.normalizeBinarySearchPosition(keyIndex);
#end
        if (local_size >= local_keys.length) // need to expand
        {
            if (keyIndex == local_size) // if at end, then just arrayclone, and append later
            {
                keys[bucketIndex]   = CollectionHelper.arrayclone(local_keys,   0, local_keys.length, local_keys.length << 1);
                values[bucketIndex] = CollectionHelper.arrayclone(local_values, 0, local_keys.length, local_keys.length << 1);
            }
            else
            {
                keys[bucketIndex]   = CollectionHelper.arraycloneExpandGap(local_keys,   0, local_keys.length, local_keys.length << 1, keyIndex, 1);
                values[bucketIndex] = CollectionHelper.arraycloneExpandGap(local_values, 0, local_keys.length, local_keys.length << 1, keyIndex, 1);
            }
        }
        else
        {
            if (keyIndex < local_size)
            {
                System.arraycopy(local_values, keyIndex, local_values, keyIndex + 1, local_size - keyIndex);
                System.arraycopy(local_keys,   keyIndex, local_keys,   keyIndex + 1, local_size - keyIndex);
            }
        }

        keys[bucketIndex][keyIndex]   = key;
        values[bucketIndex][keyIndex] = new ${VALUE_TYPE}[] {value};

        numberKeys[bucketIndex]++;
        size++;

        mutableInteger.integer = 1;
        return VALUE_ADDED;
    }

    public int putKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, ${__dont_fill_in_policy} policy, MutableInteger mutableInteger)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (keys[bucketIndex] == null)
        {
            if (!policy.canInsert(key, value))
            {
                mutableInteger.integer = 0;
                return VALUE_UNCHANGED;
            }

            keys[bucketIndex]       = new ${KEY_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY];
            values[bucketIndex]     = new ${VALUE_TYPE}[DEFAULT_ENTRY_LIST_CAPACITY][];
            keys[bucketIndex][0]    = key;
            values[bucketIndex][0]  = new ${VALUE_TYPE}[] {value};
            numberKeys[bucketIndex] = 1;
            size++;

            mutableInteger.integer = 1;
            return VALUE_ADDED;
        }

        ${KEY_TYPE}[]     local_keys   = keys[bucketIndex];
        ${VALUE_TYPE}[][] local_values = values[bucketIndex];
        int        local_size   = numberKeys[bucketIndex];
        int        keyIndex     = -1;

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.binarySearch(local_keys, key, local_size);
        if (keyIndex >= 0)
        {
            ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
            int multiIndex;

            for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    mutableInteger.integer = local_multivalues.length;
                    return VALUE_UNCHANGED;
                }
            }

            if (!policy.canInsert(key, value))
            {
                mutableInteger.integer = local_values[keyIndex].length;
                return VALUE_UNCHANGED;
            }

            local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

            local_values[keyIndex][multiIndex] = value;

            size++;

            mutableInteger.integer = local_values[keyIndex].length;
            return VALUE_ADDED;
	    }
#else
        for (keyIndex = 0; keyIndex < local_size; keyIndex++)
        {
            if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
            {
                ${VALUE_TYPE}[] local_multivalues = local_values[keyIndex];
                int multiIndex;

                for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
                {
                    ${__dont_fill_in_value_equality}
                    {
                        mutableInteger.integer = local_multivalues.length;
                        return VALUE_UNCHANGED;
                    }
                }

                if (!policy.canInsert(key, value))
                {
                    mutableInteger.integer = local_values[keyIndex].length;
                    return VALUE_UNCHANGED;
                }

                local_values[keyIndex] = CollectionHelper.arrayclone(local_multivalues, 0, local_multivalues.length, local_multivalues.length + 1);

                local_values[keyIndex][multiIndex] = value;

                size++;

                mutableInteger.integer = local_values[keyIndex].length;
                return VALUE_ADDED;
            }
        }
#end

        // if we got here, this is a completely new multivalues

        if (!policy.canInsert(key, value))
        {
            mutableInteger.integer = 0;
            return VALUE_UNCHANGED;
        }

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
        keyIndex = CollectionHelper.normalizeBinarySearchPosition(keyIndex);
#end
        if (local_size >= local_keys.length) // need to expand
        {
            if (keyIndex == local_size) // if at end, then just arrayclone, and append later
            {
                keys[bucketIndex]   = CollectionHelper.arrayclone(local_keys,   0, local_keys.length, local_keys.length << 1);
                values[bucketIndex] = CollectionHelper.arrayclone(local_values, 0, local_keys.length, local_keys.length << 1);
            }
            else
            {
                keys[bucketIndex]   = CollectionHelper.arraycloneExpandGap(local_keys,   0, local_keys.length, local_keys.length << 1, keyIndex, 1);
                values[bucketIndex] = CollectionHelper.arraycloneExpandGap(local_values, 0, local_keys.length, local_keys.length << 1, keyIndex, 1);
            }
        }
        else
        {
            if (keyIndex < local_size)
            {
                System.arraycopy(local_values, keyIndex, local_values, keyIndex + 1, local_size - keyIndex);
                System.arraycopy(local_keys,   keyIndex, local_keys,   keyIndex + 1, local_size - keyIndex);
            }
        }

        keys[bucketIndex][keyIndex]   = key;
        values[bucketIndex][keyIndex] = new ${VALUE_TYPE}[] {value};

        numberKeys[bucketIndex]++;
        size++;

        mutableInteger.integer = 1;
        return VALUE_ADDED;
    }

    public boolean containsKey(${KEY_TYPE} key)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            return CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]) >= 0;
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];

            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    return true;
                }
            }
#end
        }

        return false;
    }

    public boolean containsValue(${VALUE_TYPE} value)
    {
        int        bucketSize;
        int        keyIndex;
        int        multiIndex;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    local_multivalues = local_values[keyIndex];

                    for (multiIndex = local_multivalues.length; --multiIndex >= 0; )
                    {
                        ${__dont_fill_in_value_equality}
                        {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    public int countValues(${KEY_TYPE} key)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]);
            if (keyIndex >= 0)
            {
                return values[bucketIndex][keyIndex].length;
            }
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    return values[bucketIndex][keyIndex].length;
                }
            }
#end
        }

        return 0;
    }

    public ${VALUE_TYPE} getValueForKeyAt(${KEY_TYPE} key, int multiIndex)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]);
            if (keyIndex >= 0)
            {
                ${VALUE_TYPE}[] local_multimap = values[bucketIndex][keyIndex];

                if (local_multimap != null && multiIndex < local_multimap.length)
                {
                    return local_multimap[multiIndex];
                }
            }
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    if (multiIndex >= values[bucketIndex][keyIndex].length)
                    {
                        return ValueNotFound;
                    }

                    return values[bucketIndex][keyIndex][multiIndex];
                }
            }
#end
        }

        return ValueNotFound;
    }

    public void getValuesForKey(${KEY_TYPE} key, ${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]);
            if (keyIndex >= 0)
            {
                arrayHolder.add(values[bucketIndex][keyIndex]);
	        }
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    arrayHolder.add(values[bucketIndex][keyIndex]);
                }
            }
#end
        }
    }

    public void getKeysForValue(${VALUE_TYPE} value, ${__dont_fill_in_key_holder_name}ArrayHolderIF arrayHolder)
    {
        int        bucketSize;
        int        keyIndex;
        int        multiIndex;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    local_multivalues = local_values[keyIndex];

                    for (multiIndex = local_multivalues.length; --multiIndex >= 0; )
                    {
                        ${__dont_fill_in_value_equality}
                        {
                            arrayHolder.add(keys[bucketIndex][keyIndex]);
                            break;
                        }
                    }
                }
            }
        }
    }

    public void getData(${__dont_fill_in_key_holder_name}${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
    {
        int               bucketSize;
        int               keyIndex;
        int               multiIndex;
        ${KEY_TYPE}       key;
        ${KEY_TYPE}[]     local_keys;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = 0; bucketIndex < keys.length; bucketIndex++)
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];
                local_keys   = keys[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    key               = local_keys[keyIndex];
                    local_multivalues = local_values[keyIndex];

                    for (multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
                    {
                        arrayHolder.add(key, local_multivalues[multiIndex]);
                    }
                }
            }
        }
    }

//TODO:  ADD POLICIES TO REMOVE

    public int removeKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(local_keys, key, numberKeys[bucketIndex]);
#else
            int keyIndex;
            for (keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    break;
                }
            }
#end

            if (keyIndex < 0)
            {
                return VALUE_UNCHANGED;
            }

            ${VALUE_TYPE}[][] local_values   = values[bucketIndex];
            ${VALUE_TYPE}[]   local_multivalues = local_values[keyIndex];

            for (int multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    if (local_multivalues.length == 1)
                    {
                        int highest_index = numberKeys[bucketIndex] - 1;

                        System.arraycopy(local_keys,   keyIndex + 1, local_keys,   keyIndex, highest_index);
                        System.arraycopy(local_values, keyIndex + 1, local_values, keyIndex, highest_index);

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                        local_keys[highest_index]   = 0;
#else
                        local_keys[highest_index]   = null;
#end
                        local_values[highest_index] = null;

                        numberKeys[bucketIndex]--;
                    }
                    else
                    {
                        local_values[keyIndex] = CollectionHelper.arraycloneShrinkGap(local_multivalues, multiIndex, 1);
                    }

                    size--;

                    return VALUE_REMOVED;
    	        }
	        }
        }

        return VALUE_UNCHANGED;
    }

    public int removeKeyValue(${KEY_TYPE} key, ${VALUE_TYPE} value, MutableInteger mutableInteger)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(local_keys, key, numberKeys[bucketIndex]);
#else
            int keyIndex;
            for (keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
                    break;
                }
            }
#end

            if (keyIndex < 0)
            {
                mutableInteger.integer = 0;
                return VALUE_UNCHANGED;
            }

            ${VALUE_TYPE}[][] local_values   = values[bucketIndex];
            ${VALUE_TYPE}[]   local_multivalues = local_values[keyIndex];

            for (int multiIndex = 0; multiIndex < local_multivalues.length; multiIndex++)
            {
                ${__dont_fill_in_value_equality}
                {
                    if (local_multivalues.length == 1)
                    {
                        int highest_index = numberKeys[bucketIndex] - 1;

                        System.arraycopy(local_keys,   keyIndex + 1, local_keys,   keyIndex, highest_index);
                        System.arraycopy(local_values, keyIndex + 1, local_values, keyIndex, highest_index);

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                        local_keys[highest_index]   = 0;
#else
                        local_keys[highest_index]   = null;
#end
                        local_values[highest_index] = null;

                        numberKeys[bucketIndex]--;
                    }
                    else
                    {
                        local_values[keyIndex] = CollectionHelper.arraycloneShrinkGap(local_multivalues, multiIndex, 1);
                    }

                    size--;

                    mutableInteger.integer = local_multivalues.length - 1;
                    return VALUE_REMOVED;
    	        }
	        }
        }

        mutableInteger.integer = 0;
        return VALUE_UNCHANGED;
    }

    public void removeKey(${KEY_TYPE} key)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]);
            if (keyIndex >= 0)
            {
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
#end
                    int removed = values[bucketIndex][keyIndex].length;
                    int highest_index = numberKeys[bucketIndex] - 1;

                    System.arraycopy(keys[bucketIndex],   keyIndex + 1, keys[bucketIndex],   keyIndex, numberKeys[bucketIndex] - keyIndex);
                    System.arraycopy(values[bucketIndex], keyIndex + 1, values[bucketIndex], keyIndex, numberKeys[bucketIndex] - keyIndex);

                    numberKeys[bucketIndex]--;
                    size -= removed;

                    values[bucketIndex][highest_index] = null;
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                    keys[bucketIndex][highest_index]   = 0;
#else
                    keys[bucketIndex][highest_index]   = null;
                }
#end
            }
        }
    }

    public void removeKey(${KEY_TYPE} key, ${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
    {
        int bucketIndex = (int) (${__dont_fill_in_key_hashcode} & tableHighestIndex);

        if (numberKeys[bucketIndex] > 0)
        {
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
            int keyIndex = CollectionHelper.binarySearch(keys[bucketIndex], key, numberKeys[bucketIndex]);
            if (keyIndex >= 0)
            {
#else
            ${KEY_TYPE}[] local_keys = keys[bucketIndex];
            for (int keyIndex = numberKeys[bucketIndex]; --keyIndex >= 0; )
            {
                if (key == local_keys[keyIndex] || key.equals(local_keys[keyIndex]))
                {
#end
                    arrayHolder.add(values[bucketIndex][keyIndex]);

                    int removed = values[bucketIndex][keyIndex].length;
                    int highest_index = numberKeys[bucketIndex] - 1;

                    System.arraycopy(keys[bucketIndex],   keyIndex + 1, keys[bucketIndex],   keyIndex, numberKeys[bucketIndex] - keyIndex);
                    System.arraycopy(values[bucketIndex], keyIndex + 1, values[bucketIndex], keyIndex, numberKeys[bucketIndex] - keyIndex);

                    numberKeys[bucketIndex]--;
                    size -= removed;

                    values[bucketIndex][highest_index] = null;
#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                    keys[bucketIndex][highest_index]   = 0;
#else
                    keys[bucketIndex][highest_index]   = null;
                }
#end
            }
        }
    }

    public void removeValue(${VALUE_TYPE} value)
    {
        int        bucketSize;
        int        keyIndex;
        int        multiIndex;
        ${KEY_TYPE}[]     local_keys;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];
                local_keys   = keys[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    local_multivalues = local_values[keyIndex];

                    for (multiIndex = local_multivalues.length; --multiIndex >= 0; )
                    {
                        ${__dont_fill_in_value_equality}
                        {
                            if (local_multivalues.length == 1)
                            {
                                int highest_index = numberKeys[bucketIndex] - 1;

                                System.arraycopy(local_keys,   keyIndex + 1, local_keys,   keyIndex, highest_index);
                                System.arraycopy(local_values, keyIndex + 1, local_values, keyIndex, highest_index);

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                                local_keys[highest_index]   = 0;
#else
                                local_keys[highest_index]   = null;
#end
                                local_values[highest_index] = null;

                                numberKeys[bucketIndex]--;
                            }
                            else
                            {
                                local_values[keyIndex] = CollectionHelper.arraycloneShrinkGap(local_multivalues, multiIndex, 1);
                            }

                            size--;
                        }
                    }
                }
            }
        }
    }

    public void removeValue(${VALUE_TYPE} value, ${__dont_fill_in_key_holder_name}ArrayHolderIF arrayHolder)
    {
        int        bucketSize;
        int        keyIndex;
        int        multiIndex;
        ${KEY_TYPE}[]     local_keys;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];
                local_keys   = keys[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    local_multivalues = local_values[keyIndex];

                    for (multiIndex = local_multivalues.length; --multiIndex >= 0; )
                    {
                        ${__dont_fill_in_value_equality}
                        {
                            arrayHolder.add(keys[bucketIndex][keyIndex]);

                            if (local_multivalues.length == 1)
                            {
                                int highest_index = numberKeys[bucketIndex] - 1;

                                System.arraycopy(local_keys,   keyIndex + 1, local_keys,   keyIndex, highest_index);
                                System.arraycopy(local_values, keyIndex + 1, local_values, keyIndex, highest_index);

#if ( ${KEY_TYPE} == "int" || ${KEY_TYPE} == "long" )
                                local_keys[highest_index]   = 0;
#else
                                local_keys[highest_index]   = null;
#end
                                local_values[highest_index] = null;

                                numberKeys[bucketIndex]--;
                            }
                            else
                            {
                                local_values[keyIndex] = CollectionHelper.arraycloneShrinkGap(local_multivalues, multiIndex, 1);
                            }

                            size--;
                        }
                    }
                }
            }
        }
    }

    public ${__dont_fill_in_visitor} acceptVisitor(${__dont_fill_in_visitor} visitor)
    {
        int               bucketSize;
        int               keyIndex;
        int               multiIndex;
        ${KEY_TYPE}       key;
        int               multiLength;
        int               rc;
        ${KEY_TYPE}[]     local_keys;
        ${VALUE_TYPE}[][] local_values;
        ${VALUE_TYPE}[]   local_multivalues;

        for (int bucketIndex = 0; bucketIndex < keys.length; bucketIndex++)
        {
            bucketSize = numberKeys[bucketIndex];

            if (bucketSize > 0)
            {
                local_values = values[bucketIndex];
                local_keys   = keys[bucketIndex];

                for (keyIndex = 0; keyIndex < bucketSize; keyIndex++)
                {
                    local_multivalues = local_values[keyIndex];
                    multiLength       = local_multivalues.length;
                    key               = local_keys[keyIndex];

                    for (multiIndex = 0; multiIndex < multiLength; multiIndex++)
                    {
                        rc = visitor.visit(key, local_multivalues[multiIndex]);

                        if (rc == ${__dont_fill_in_visitor}.CONTINUE)
                        {
                             continue;
                        }

                        if (rc == ${__dont_fill_in_visitor}.SKIP)
                        {
                            break;
                        }

                        if (rc == ${__dont_fill_in_visitor}.ABORT)
                        {
                             return visitor;
                        }
                    }
                }
            }
        }

        return visitor;
    }

    public ${__dont_fill_in_class_name} clear()
    {
        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            keys[bucketIndex]       = null;
            values[bucketIndex]     = null;
            numberKeys[bucketIndex] = 0;
        }

        size = 0;

        return this;
    }

    public ${__dont_fill_in_class_name} clear(${__dont_fill_in_key_holder_name}${__dont_fill_in_value_holder_name}ArrayHolderIF arrayHolder)
    {
        getData(arrayHolder);

        for (int bucketIndex = keys.length; --bucketIndex >= 0; )
        {
            keys[bucketIndex]       = null;
            values[bucketIndex]     = null;
            numberKeys[bucketIndex] = 0;
        }

        size = 0;

        return this;
    }
}
