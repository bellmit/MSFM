<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fix="http://www.cboe.com/fix/xslt"
                >

<!-- @author Dmitry Volpyansky

     must be built with JDK 1.4.1 and Saxon XSLT version 7.4 from http://saxon.sourceforge.net/

     classpath needs to include /client/cfix/generator/saxon7.jar and /client/cfix/generator/saxon7_jdom.jar

     command line example: java net.sf.saxon.Transform CboeFIX42.xml Fix_Class_Message_Main.xsl IMPLS_DIRECTORY="/client/cfix/impls"

     the IMPLS_DIRECTORY parameter specifies the output directory
-->

<xsl:param name="IMPLS_DIRECTORY">/tmp</xsl:param>

<xsl:output method="text" encoding="UTF-8" indent="no" name="text"/>

<xsl:strip-space elements="*"/>

<xsl:template match="text()"/>

<xsl:include href="Fix_Helper.xsl"/>

<xsl:template match="/fix/header|/fix/trailer">
<xsl:result-document href="file://{$IMPLS_DIRECTORY}/com/cboe/cfix/fix/fix{/fix/@versiontag}/generated/messages/FixMessage.java" format="text">
<xsl:text/>package com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.generated.messages;

/**
 * FixMessage.java
 *
 * @author Dmitry Volpyansky
 *
 */

/**
 * This GENERATED file implements FIX Protocol's Base Message, consisting of just the header and trailer fields
 *
 * WARNING: This entire file is completely generated by XSLT stylesheets from CboeFIX<xsl:value-of select="/fix/@versiontag"/>.xml file.
 *
 */

import java.util.*;

import com.cboe.cfix.interfaces.*;
import com.cboe.cfix.util.*;
import com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.generated.fields.*;
import com.cboe.cfix.fix.util.*;
import com.cboe.client.util.*;
import com.cboe.infrastructureServices.foundationFramework.utilities.*;

public abstract class FixMessage implements FixMessageIF
{   <xsl:text/>
    <xsl:variable name="longestFieldName" select="fix:findLongestString(../header/field/@name|../trailer/field/@name)+8"/>
    // START FIX Header Fields<xsl:text/>

    <xsl:for-each select="../header/field">
           <xsl:call-template name="fix:FixMessageClass_Fields">
                <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
           </xsl:call-template><xsl:text/>
    </xsl:for-each>

    // START FIX Trailer Fields<xsl:text/>
    <xsl:for-each select="../trailer/field">
           <xsl:call-template name="fix:FixMessageClass_Fields">
                <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
           </xsl:call-template><xsl:text/>
    </xsl:for-each><xsl:text/>

    protected static final int STATE_Header = 0;<xsl:text/>
    protected static final int STATE_Field  = 1;<xsl:text/>

    <xsl:for-each select="/fix/header/field | /fix/trailer/field">
        <xsl:call-template name="fix:FixMessageClass_Function_Header_ToString"/><xsl:text/>
    </xsl:for-each>

    <xsl:for-each select="/fix/header/field | /fix/trailer/field">
        <xsl:call-template name="fix:FixMessageClass_Function_Header_AcceptFixMessageBuilder"/>
    </xsl:for-each>

    public int getMsgSeqNum()       {return fieldMsgSeqNum.intValue();}
    public String getSenderCompID() {return fieldSenderCompID.getValue();}
    public String getTargetCompID() {return fieldTargetCompID.getValue();}
    public Date getSendingTime()    {return fieldSendingTime.dateValue();}
    public boolean isPossDup()      {return fieldPossDupFlag != null &amp;&amp; fieldPossDupFlag.booleanValue();}<xsl:text/>

    <xsl:for-each select="/fix/messages/message[@cboe_uses='Y']">
    public boolean isFix<xsl:value-of select="@name"/>Message()  {return false;}<xsl:text/>
    </xsl:for-each>

    public boolean buildHeaderTrailer(char[] array, int tag, int offset, int length, int currentState, int currentPosition, PackedIntArrayIF foundErrors, int validationFlags, int debugFlags)
    {
        switch (tag)
        {<xsl:text/>
    <xsl:for-each select="/fix/header/field | /fix/trailer/field">
        <xsl:call-template name="fix:FixMessageClass_Function_Header_CreateField"/><xsl:text/>
    </xsl:for-each>
        }<xsl:text/>

        return false;
    }

    public Object clone() throws CloneNotSupportedException
    {
        return super.clone();
    }<xsl:text/>
    <xsl:apply-templates/><xsl:text/>
}
</xsl:result-document>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Fields">
<xsl:param name="longestFieldName"/>
<xsl:text>&#xA;    </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(fix:buildFixFieldName(@name), $longestFieldName)"/> field<xsl:value-of select="@name"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Groups">
<xsl:param name="longestFieldName"/>
<xsl:text>&#xA;    </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(fix:buildFixFieldName(@name), $longestFieldName)"/> field<xsl:value-of select="@name"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
<xsl:text>&#xA;    </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(concat(fix:removePrefix(@name, 'No'), 'Group[]'), $longestFieldName)"/> group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_GroupFields">
<xsl:param name="longestFieldName"/>
<xsl:text>&#xA;        </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(fix:buildFixFieldName(@name), $longestFieldName)"/> field<xsl:value-of select="@name"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_GroupGroups">
<xsl:param name="longestFieldName"/>
<xsl:text>&#xA;        </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(fix:buildFixFieldName(@name), $longestFieldName)"/> field<xsl:value-of select="@name"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
<xsl:text>&#xA;        </xsl:text><xsl:value-of select="if (@not_used_by_cboe = 'Y') then '//     ' else 'public '"/> <xsl:value-of select="fix:rightPad(concat(fix:removePrefix(@name, 'No'), 'Group[]'), $longestFieldName)"/> group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>;<xsl:value-of select="if (@not_used_by_cboe = 'Y') then '// NOT GENERATED (marked as unused_by_cboe in the XML file)' else ''"/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_DefineGroup">
<xsl:param name="longestFieldName"/>
    <xsl:variable name="groupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>
    public static class <xsl:value-of select="$groupWithoutNoPrefix"/>Group implements PrettyPrintWriterVisitorIF
    {   <xsl:text/>
        <xsl:for-each select="field">
            <xsl:call-template name="fix:FixMessageClass_GroupFields">
                <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:for-each select="group">
            <xsl:call-template name="fix:FixMessageClass_GroupGroups">
                <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:if test="@allow_user_fields = 'Y'">
        public <xsl:value-of select="fix:rightPad('List', $longestFieldName)"/> additionalUserFields;<xsl:text/>
        </xsl:if>
        <xsl:text>&#xA;</xsl:text>
        <xsl:for-each select="field|group">
            <xsl:call-template name="fix:FixMessageClass_Function_GroupToString">
                <xsl:with-param name="groupWithoutNoPrefix" select="$groupWithoutNoPrefix"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:text>&#xA;</xsl:text>
        <xsl:for-each select="field|group">
            <xsl:call-template name="fix:FixMessageClass_Function_GroupAcceptFixMessageBuilder">
                <xsl:with-param name="groupWithoutNoPrefix" select="$groupWithoutNoPrefix"/>
            </xsl:call-template><xsl:text/>
        </xsl:for-each>
    }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Const_MsgType"><xsl:text/>
    public static final String MsgType        = "<xsl:value-of select="@msgtype"/>";
    public static final char   MsgTypeAsChar  = '<xsl:value-of select="@msgtype"/>';
    public static final char[] MsgTypeAsChars = {<xsl:value-of select="fix:splitIntoChars(@msgtype)"/>};
    public static final String MsgTypeName    = "<xsl:value-of select="@name"/>";
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Header_ToString">
                                                                                                       <xsl:if test="position() = 1">
    public String toString()
    {
        PrettyPrintWriter prettyPrintWriter = new PrettyPrintWriter();

        accept(prettyPrintWriter);

        return prettyPrintWriter.toString();
    }

    public void accept(PrettyPrintWriterIF prettyPrintWriter)
    {                                                                                                 </xsl:if>
        <xsl:if test="not(@not_used_by_cboe = 'Y')">
        prettyPrintWriter.printGroupItem(field<xsl:value-of select="@name"/>);<xsl:text/>
        </xsl:if>

                                                                                                      <xsl:if test="position() = last()">
    }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_ToString">
<xsl:param name="groupWithoutNoPrefix"/>
                                                                                                       <xsl:if test="position() = 1">
    public String toString()
    {
        PrettyPrintWriter prettyPrintWriter = new PrettyPrintWriter();

        accept(prettyPrintWriter);

        return prettyPrintWriter.toString();
    }

    public void accept(PrettyPrintWriterIF prettyPrintWriter)
    {
        prettyPrintWriter.startPrintingGroup(MsgTypeName);

        super.accept(prettyPrintWriter);
                                                                                                      </xsl:if>
                                                                                                      <xsl:if test="not(@not_used_by_cboe = 'Y')">
        prettyPrintWriter.printGroupItem(field<xsl:value-of select="@name"/>);<xsl:text/>             </xsl:if>
                                                                                                      <xsl:if test="name() = 'group' and not(@not_used_by_cboe = 'Y')">
        if (group<xsl:value-of select="$groupWithoutNoPrefix"/> != null)
        {
            for (int i = 0; i &lt; group<xsl:value-of select="$groupWithoutNoPrefix"/>.length; i++)
            {
                if (group<xsl:value-of select="$groupWithoutNoPrefix"/>[i] != null) group<xsl:value-of select="$groupWithoutNoPrefix"/>[i].accept(prettyPrintWriter);
            }
        }                                                                                             </xsl:if>
                                                                                                      <xsl:if test="position() = last()">

        <xsl:if test="@allow_user_fields = 'Y'">
        if (additionalUserFields != null)
        {
            for (Iterator iterator = additionalUserFields.iterator(); iterator.hasNext(); )
            {
                prettyPrintWriter.printGroupItem(iterator.next().toString());
            }
        }
        </xsl:if>

        prettyPrintWriter.endPrintingGroup();
    }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_GroupToString">
<xsl:param name="groupWithoutNoPrefix"/>
                                                                                                           <xsl:if test="position() = 1">
        public String toString()
        {
            PrettyPrintWriter prettyPrintWriter = new PrettyPrintWriter();

            accept(prettyPrintWriter);

            return prettyPrintWriter.toString();
        }

        public void accept(PrettyPrintWriterIF prettyPrintWriter)
        {
            prettyPrintWriter.startPrintingGroup("<xsl:value-of select="$groupWithoutNoPrefix"/>Group");  </xsl:if>
                                                                                                          <xsl:if test="name() = 'field'">
            <xsl:if test="not(@not_used_by_cboe = 'Y')">
            prettyPrintWriter.printGroupItem(field<xsl:value-of select="@name"/>);<xsl:text/>
            </xsl:if>                                                                                     </xsl:if>
                                                                                                          <xsl:if test="name() = 'group'">
            <xsl:if test="not(@not_used_by_cboe = 'Y')">
            prettyPrintWriter.printGroupItem(field<xsl:value-of select="@name"/>);<xsl:text/>
            </xsl:if>

            <xsl:variable name="subGroupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>

            if (group<xsl:value-of select="$subGroupWithoutNoPrefix"/> != null)
            {
                for (int i = 0; i &lt; group<xsl:value-of select="$subGroupWithoutNoPrefix"/>.length; i++)
                {
                    if (group<xsl:value-of select="$subGroupWithoutNoPrefix"/>[i] != null) group<xsl:value-of select="$subGroupWithoutNoPrefix"/>[i].accept(prettyPrintWriter);
                }
            }                                                                                             </xsl:if>
                                                                                                          <xsl:if test="position() = last()">

            <xsl:if test="@allow_user_fields = 'Y'">
            if (additionalUserFields != null)
            {
                for (Iterator iterator = additionalUserFields.iterator(); iterator.hasNext(); )
                {
                    prettyPrintWriter.printGroupItem(iterator.next().toString());
                }
            }
            </xsl:if>

            prettyPrintWriter.endPrintingGroup();
        }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Header_AcceptFixMessageBuilder">
                                                                                                       <xsl:if test="position() = 1">
    public void accept(FixMessageBuilderIF fixMessageBuilder)
    {                                                                                                 </xsl:if>
        <xsl:if test="not(@not_used_by_cboe = 'Y')">
        fixMessageBuilder.append(field<xsl:value-of select="@name"/>);<xsl:text/>
        </xsl:if>
                                                                                                      <xsl:if test="position() = last()">
    }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_AcceptFixMessageBuilder">
<xsl:param name="groupWithoutNoPrefix"/>
                                                                                                       <xsl:if test="position() = 1">
    public void accept(FixMessageBuilderIF fixMessageBuilder)
    {
        super.accept(fixMessageBuilder);
                                                                                                      </xsl:if>
                                                                                                      <xsl:if test="name() = 'field' or name() = 'group'">
        <xsl:if test="not(@not_used_by_cboe = 'Y')">
        fixMessageBuilder.append(field<xsl:value-of select="@name"/>);<xsl:text/>
        </xsl:if>                                                                                     </xsl:if>
                                                                                                      <xsl:if test="name() = 'group'">
        if (group<xsl:value-of select="$groupWithoutNoPrefix"/> != null)
        {
            for (int i = 0; i &lt; group<xsl:value-of select="$groupWithoutNoPrefix"/>.length; i++)
            {
                if (group<xsl:value-of select="$groupWithoutNoPrefix"/>[i] != null) group<xsl:value-of select="$groupWithoutNoPrefix"/>[i].accept(fixMessageBuilder);
            }
        }                                                                                             </xsl:if>
                                                                                                      <xsl:if test="position() = last()">

        if (additionalUserFields != null)
        {
            for (Iterator iterator = additionalUserFields.iterator(); iterator.hasNext(); )
            {
                fixMessageBuilder.append((FixFieldIF) iterator.next());
            }
        }
    }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_GroupAcceptFixMessageBuilder">
<xsl:param name="groupWithoutNoPrefix"/>
                                                                                                      <xsl:if test="position() = 1">
        public void accept(FixMessageBuilderIF fixMessageBuilder)
        {                                                                                             </xsl:if>
                                                                                                      <xsl:if test="name() = 'field' or name() = 'group'">
            <xsl:if test="not(@not_used_by_cboe = 'Y')">
            fixMessageBuilder.append(field<xsl:value-of select="@name"/>);<xsl:text/>
            </xsl:if>                                                                                     </xsl:if>
                                                                                                      <xsl:if test="name() = 'group'">

            <xsl:variable name="subGroupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>

            if (group<xsl:value-of select="$subGroupWithoutNoPrefix"/> != null)
            {
                for (int i = 0; i &lt; group<xsl:value-of select="$subGroupWithoutNoPrefix"/>.length; i++)
                {
                    if (group<xsl:value-of select="$subGroupWithoutNoPrefix"/>[i] != null) group<xsl:value-of select="$subGroupWithoutNoPrefix"/>[i].accept(fixMessageBuilder);
                }
            }                                                                                             </xsl:if>
                                                                                                          <xsl:if test="position() = last()">

            <xsl:if test="@allow_user_fields = 'Y'">
            if (additionalUserFields != null)
            {
                for (Iterator iterator = additionalUserFields.iterator(); iterator.hasNext();
                {
                    fixMessageBuilder.append((FixFieldIF) iterator.next());
                }
            }
            </xsl:if>
        }                                                                                                 </xsl:if>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Build_States">
    private static final int STATE_<xsl:value-of select="fix:removePrefix(@name, 'No')"/>Group = <xsl:value-of select="position() + 1"/>;<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Build_StatesToString">
            case STATE_<xsl:value-of select="fix:removePrefix(@name, 'No')"/>Group: return "State[<xsl:value-of select="fix:removePrefix(@name, 'No')"/>Group]";<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Validate_Begin">
    public PackedIntArrayIF validate(FixPacketIF fixPacket, PackedIntArrayIF foundErrors, int validationFlags, int debugFlags)
    {<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Validate_Body_Required">
       <xsl:choose>
               <xsl:when test="name() = 'field'">
        if (field<xsl:value-of select="@name"/> == null)
        {
            foundErrors.add(BitHelper.packInt(FixException.MISSING_REQUIRED_TAG, Fix<xsl:value-of select="@name"/>Field.TagID));
            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }
               </xsl:when>
               <xsl:when test="name() = 'group'">
        <xsl:variable name="groupName" select="concat('group', fix:removePrefix(@name, 'No'))"/>
        if (field<xsl:value-of select="@name"/> == null)
        {
            foundErrors.add(BitHelper.packInt(FixException.MISSING_REQUIRED_TAG, Fix<xsl:value-of select="@name"/>Field.TagID));
            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }

        for (int i = 0; i &lt; <xsl:value-of select="$groupName"/>.length; i++)
        {<xsl:text/>
    <xsl:for-each select="field[@required='Y']">
            if (<xsl:value-of select="$groupName"/>[i].field<xsl:value-of select="@name"/> == null)
            {
                foundErrors.add(BitHelper.packInt(FixException.MISSING_REQUIRED_TAG, Fix<xsl:value-of select="@name"/>Field.TagID));
                if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                {
                    return foundErrors;
                }
            }
    </xsl:for-each>
    <xsl:for-each select="group/field[@required='Y']">
            if (<xsl:value-of select="$groupName"/>[i].group<xsl:value-of select="fix:removePrefix(../@name, 'No')"/> != null)
            {
                for (int j = 0; j &lt; <xsl:value-of select="$groupName"/>[i].group<xsl:value-of select="fix:removePrefix(../@name, 'No')"/>.length; j++)
                {
                    if (<xsl:value-of select="$groupName"/>[i].group<xsl:value-of select="fix:removePrefix(../@name, 'No')"/>[j].field<xsl:value-of select="@name"/> == null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.MISSING_REQUIRED_TAG, Fix<xsl:value-of select="@name"/>Field.TagID));
                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }
                    }
                }
            }
    </xsl:for-each>
        }
               </xsl:when>
    </xsl:choose>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Validate_Body_Conditional">
    <xsl:choose>
       <xsl:when test="@type = 'standalone'">
           <xsl:variable name="fieldName" select="@name"/>
           <xsl:choose>

               <xsl:when test="count(value/@required) &gt; 0">
        if (field<xsl:value-of select="$fieldName"/> == null)
        {
            foundErrors.add(BitHelper.packInt(FixException.MISSING_CONDITIONALLY_REQUIRED_TAG, Fix<xsl:value-of select="@name"/>Field.TagID));
            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }
               </xsl:when>

               <xsl:when test="count(value/@enum) &gt; 0">
        if (field<xsl:value-of select="$fieldName"/> != null &amp;&amp;<xsl:text/>
                   <xsl:for-each select="value/@enum">
           !field<xsl:value-of select="$fieldName"/>.is<xsl:value-of select="."/>()<xsl:value-of select="if (position() = last()) then ')' else ' ||'"/>
                   </xsl:for-each>
        {
            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, 0));
            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }
               </xsl:when>

               <xsl:when test="count(value/@number) &gt; 0">
        if (field<xsl:value-of select="$fieldName"/> != null &amp;&amp;<xsl:text/>
                   <xsl:for-each select="value/@number">
          !(field<xsl:value-of select="$fieldName"/>.intValue() == <xsl:value-of select="."/><xsl:value-of select="if (position() = last()) then '))' else ' ||'"/>
                   </xsl:for-each>
        {
            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, 0));
            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }
               </xsl:when>
           </xsl:choose>
       </xsl:when>
    </xsl:choose>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Validate_End"><xsl:text/>
        return foundErrors;
    }
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Build_Begin">
    public PackedIntArrayIF build(FixPacketIF fixPacket, PackedIntArrayIF foundErrors, int validationFlags, int debugFlags)
    {
        char[] array          = fixPacket.getArray();
        int    numTags        = fixPacket.getTagPositionLength();
        int    currentState   = STATE_Header;<xsl:text/>
        int    tag;
        int    offset;
        int    length;<xsl:text/>
        <xsl:if test="group">
        int    numInGroup;
        int    group;</xsl:if>
        int    currentPosition;<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Build_BeginGroups">
    <xsl:choose>
       <xsl:when test="count(field[@starts_group]) &gt; 0">
        int    current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/> = -1; // this group has a starting field which we have to find first<xsl:text/>
       </xsl:when>
       <xsl:otherwise>
        int    current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/> = 0; // this group does not have a starting field, so we want to populate it as we find its objects<xsl:text/>
       </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_CreateField">
                case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:
                {
                    if (currentState != STATE_Field)
                    {
                        currentState = STATE_Field;
                    }
                  <xsl:choose>
                    <xsl:when test="not(@not_used_by_cboe = 'Y')">
                    if (field<xsl:value-of select="@name"/> != null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (field<xsl:value-of select="@name"/> == null || !field<xsl:value-of select="@name"/>.hasValue())
                    {
                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>
                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                    {
                        <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                        if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                        {
                            unusedByCboeField = null;

                            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                            {
                                return foundErrors;
                            }

                            continue;
                        }

                        unusedByCboeField = null;
                    }<xsl:text/>
                    </xsl:otherwise>
                  </xsl:choose>

                    continue;<xsl:text/>
                }
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Header_CreateField">
            case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:<xsl:text/>
            {<xsl:text/>
                <xsl:if test="name(..) = 'header'">
                if (currentState != STATE_Header)
                {
                    foundErrors.add(BitHelper.packInt(FixException.HEADER_TAG_OUTSIDE_OF_HEADER, currentPosition));

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                    {
                        return false;
                    }

                    return true;
                }
                </xsl:if>
                <xsl:choose>
                <xsl:when test="not(@not_used_by_cboe = 'Y')">
                if (field<xsl:value-of select="@name"/> != null)
                {
                    foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                    {
                        return false;
                    }

                    return true;
                }

                field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                if (field<xsl:value-of select="@name"/> == null || !field<xsl:value-of select="@name"/>.hasValue())
                {
                    foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                    {
                        return false;
                    }

                    return true;
                }<xsl:text/>
                </xsl:when>
                <xsl:otherwise>
                if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                {
                    <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                    {
                        unusedByCboeField = null;

                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return false;
                        }

                        return true;
                    }

                    unusedByCboeField = null;
                }<xsl:text/>
                </xsl:otherwise>
              </xsl:choose>

                return true;
            }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_CreateGroup">
<xsl:variable name="groupWithoutNoPrefix">
    <xsl:if test="name() = 'group'">
            <xsl:call-template name="fix:FixHelper_removePrefix">
                <xsl:with-param name="string" select="@name"/>
                <xsl:with-param name="prefix" select="'No'"/>
            </xsl:call-template>
    </xsl:if>
</xsl:variable>
                case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:
                {
                    if (field<xsl:value-of select="@name"/> != null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    if (group<xsl:value-of select="$groupWithoutNoPrefix"/> != null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG_WITHIN_GROUP, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                  <xsl:choose>
                    <xsl:when test="not(@not_used_by_cboe = 'Y')">

                    field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (field<xsl:value-of select="@name"/> == null || !field<xsl:value-of select="@name"/>.hasValue())
                    {
                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                    {
                        <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                        if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                        {
                            unusedByCboeField = null;

                            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                            {
                                return foundErrors;
                            }

                            continue;
                        }

                        unusedByCboeField = null;
                    }<xsl:text/>
                    </xsl:otherwise>
                  </xsl:choose>

                    currentState = STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group;

                    numInGroup = field<xsl:value-of select="@name"/>.intValue();

                    group<xsl:value-of select="$groupWithoutNoPrefix"/> = new <xsl:value-of select="$groupWithoutNoPrefix"/>Group[numInGroup];
                    for (group = 0; group &lt; numInGroup; group++)
                    {
                        group<xsl:value-of select="$groupWithoutNoPrefix"/>[group] = new <xsl:value-of select="$groupWithoutNoPrefix"/>Group();
                    }

                    continue;
                }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_CreateGroupSubFields">
<xsl:param name="groupWithoutNoPrefix"/>
                case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:
                {<xsl:text/>
                    <xsl:choose>
                    <xsl:when test="@starts_group = 'Y' and name(..) = 'group' and count(..//group) = 1">
<!-- <xsl:message>Processing Message(<xsl:value-of select="../../@name"/>) with a Group(<xsl:value-of select="../@name"/>) with a Subgroup(<xsl:value-of select="../group/@name"/>)</xsl:message> -->
                    if (currentState != STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group &amp;&amp;
                        currentState != STATE_<xsl:value-of select="fix:removePrefix(..//group/@name, 'No')"/>Group)<xsl:text/>
                    </xsl:when>
                    <xsl:when test="@starts_group = 'Y' and name(..) = 'group' and count(..//group) = 2">
<!-- <xsl:message>Processing Message(<xsl:value-of select="../../@name"/>) with a Group(<xsl:value-of select="../@name"/>) with a Subgroup(<xsl:value-of select="../group[1]/@name"/>) and Subgroup(<xsl:value-of select="../group[2]/@name"/>)</xsl:message> -->
                    if (currentState != STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group &amp;&amp;
                        currentState != STATE_<xsl:value-of select="fix:removePrefix(..//group[1]/@name, 'No')"/>Group &amp;&amp;<xsl:text/>
                        currentState != STATE_<xsl:value-of select="fix:removePrefix(..//group[2]/@name, 'No')"/>Group)<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>
                    if (currentState != STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group)<xsl:text/>
                    </xsl:otherwise>
                    </xsl:choose>
                    {
                        foundErrors.add(BitHelper.packInt(FixException.TAG_IN_INVALID_POSITION, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>

                    <xsl:if test="@starts_group = 'Y'">

                    current_group<xsl:value-of select="$groupWithoutNoPrefix"/>++;

                    currentState = STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group;<xsl:text/>
                    </xsl:if>

                    <xsl:choose>
                     <xsl:when test="count(../field[@starts_group]) &gt; 0 and count(@starts_group) = 0">

                    if (current_group<xsl:value-of select="$groupWithoutNoPrefix"/> &lt; 0 || current_group<xsl:value-of select="$groupWithoutNoPrefix"/> &gt;= group<xsl:value-of select="$groupWithoutNoPrefix"/>.length)<xsl:text/>
                       </xsl:when>
                       <xsl:otherwise>

                    if (current_group<xsl:value-of select="$groupWithoutNoPrefix"/> &gt;= group<xsl:value-of select="$groupWithoutNoPrefix"/>.length)<xsl:text/>
                       </xsl:otherwise>
                    </xsl:choose>
                    {
                        foundErrors.add(BitHelper.packInt(FixException.TAG_OUT_OF_ORDER_WITHIN_GROUP, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                  <xsl:choose>
                    <xsl:when test="not(@not_used_by_cboe = 'Y')">

                    if (group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>].field<xsl:value-of select="@name"/> != null)
                    {<xsl:text/>
                        <xsl:choose>
                           <xsl:when test="count(../field[@starts_group]) &gt; 0">
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;<xsl:text/>
                           </xsl:when>
                           <xsl:otherwise>
                        current_group<xsl:value-of select="$groupWithoutNoPrefix"/>++;<xsl:text/>
                           </xsl:otherwise>
                        </xsl:choose>
                    }

                    group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>].field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>].field<xsl:value-of select="@name"/> == null || !group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>].field<xsl:value-of select="@name"/>.hasValue())
                    {
                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                    {
                        <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                        if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                        {
                            unusedByCboeField = null;

                            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                            {
                                return foundErrors;
                            }

                            continue;
                        }

                        unusedByCboeField = null;
                    }<xsl:text/>
                    </xsl:otherwise>
                  </xsl:choose>

                    continue;
                }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_CreateSubGroup">
<xsl:variable name="groupWithoutNoPrefix">
    <xsl:if test="name() = 'group'">
            <xsl:call-template name="fix:FixHelper_removePrefix">
                <xsl:with-param name="string" select="@name"/>
                <xsl:with-param name="prefix" select="'No'"/>
            </xsl:call-template>
    </xsl:if>
</xsl:variable>
<xsl:variable name="parentGroupWithoutNoPrefix">
    <xsl:if test="name() = 'group'">
            <xsl:call-template name="fix:FixHelper_removePrefix">
                <xsl:with-param name="string" select="../@name"/>
                <xsl:with-param name="prefix" select="'No'"/>
            </xsl:call-template>
    </xsl:if>
</xsl:variable>
<xsl:variable name="indexedParentGroup">group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>[current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>]</xsl:variable>
<xsl:variable name="indexedCurrentGroup">group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>]</xsl:variable>
                case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:
                {
                    if (current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/> &lt; 0 || current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/> &gt;= group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>.length)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.TAG_OUT_OF_ORDER_WITHIN_GROUP, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    if (<xsl:value-of select="$indexedParentGroup"/>.field<xsl:value-of select="@name"/> != null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    if (<xsl:value-of select="$indexedParentGroup"/>.group<xsl:value-of select="$groupWithoutNoPrefix"/> != null)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG_WITHIN_GROUP, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    <xsl:choose>
                    <xsl:when test="not(@not_used_by_cboe = 'Y')">
                    <xsl:value-of select="$indexedParentGroup"/>.field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (<xsl:value-of select="$indexedParentGroup"/>.field<xsl:value-of select="@name"/> == null || !<xsl:value-of select="$indexedParentGroup"/>.field<xsl:value-of select="@name"/>.hasValue())
                    {
                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>
                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                    {
                        <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                        if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                        {
                            unusedByCboeField = null;

                            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                            {
                                return foundErrors;
                            }

                            continue;
                        }

                        unusedByCboeField = null;
                    }<xsl:text/>
                    </xsl:otherwise>
                    </xsl:choose>

                    currentState = STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group;

                    current_group<xsl:value-of select="$groupWithoutNoPrefix"/> = -1;

                    numInGroup = <xsl:value-of select="$indexedParentGroup"/>.field<xsl:value-of select="@name"/>.intValue();

                    <xsl:value-of select="$indexedParentGroup"/>.group<xsl:value-of select="$groupWithoutNoPrefix"/> = new <xsl:value-of select="$groupWithoutNoPrefix"/>Group[numInGroup];
                    for (group = 0; group &lt; numInGroup; group++)
                    {
                        <xsl:value-of select="$indexedParentGroup"/>.group<xsl:value-of select="$groupWithoutNoPrefix"/>[group] = new <xsl:value-of select="$groupWithoutNoPrefix"/>Group();
                    }

                    continue;
                }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_CreateSubGroupSubFields">
<xsl:param name="groupWithoutNoPrefix"/>
<xsl:variable name="parentGroupWithoutNoPrefix">
    <xsl:call-template name="fix:FixHelper_removePrefix">
        <xsl:with-param name="string" select="../../@name"/>
        <xsl:with-param name="prefix" select="'No'"/>
    </xsl:call-template>
</xsl:variable>
<xsl:variable name="indexedParentGroup">group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>[current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>]</xsl:variable>
<xsl:variable name="indexedCurrentGroup">group<xsl:value-of select="$groupWithoutNoPrefix"/>[current_group<xsl:value-of select="$groupWithoutNoPrefix"/>]</xsl:variable>
<xsl:variable name="curGroup">curGroup<xsl:value-of select="$groupWithoutNoPrefix"/></xsl:variable>
                case <xsl:value-of select="fix:buildFixFieldNameDotTagID(@name)"/>:
                {
                    if (currentState != STATE_<xsl:value-of select="$groupWithoutNoPrefix"/>Group)
                    {
                        foundErrors.add(BitHelper.packInt(FixException.TAG_IN_INVALID_POSITION, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>

                    <xsl:if test="@starts_group = 'Y'">

                    current_group<xsl:value-of select="$groupWithoutNoPrefix"/>++;<xsl:text/>
                    </xsl:if>

                    if (current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/> &lt; 0 ||
                        current_group<xsl:value-of select="$parentGroupWithoutNoPrefix"/> &gt;= group<xsl:value-of select="$parentGroupWithoutNoPrefix"/>.length ||<xsl:text/>
                    <xsl:choose>
                     <xsl:when test="count(../field[@starts_group]) &gt; 0 and count(@starts_group) = 0">
                        current_group<xsl:value-of select="$groupWithoutNoPrefix"/> &lt; 0 ||<xsl:text/>
                     </xsl:when>
                    </xsl:choose>
                        current_group<xsl:value-of select="$groupWithoutNoPrefix"/> &gt;= <xsl:value-of select="$indexedParentGroup"/>.group<xsl:value-of select="$groupWithoutNoPrefix"/>.length)<xsl:text/>
                    {
                        foundErrors.add(BitHelper.packInt(FixException.TAG_OUT_OF_ORDER_WITHIN_GROUP, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }

                    <xsl:value-of select="$groupWithoutNoPrefix"/>Group <xsl:value-of select="$curGroup"/> = <xsl:value-of select="$indexedParentGroup"/>.<xsl:value-of select="$indexedCurrentGroup"/>;<xsl:text/>

                  <xsl:choose>
                    <xsl:when test="not(@not_used_by_cboe = 'Y')">

                    if (<xsl:value-of select="$curGroup"/>.field<xsl:value-of select="@name"/> != null)
                    {<xsl:text/>
                        <xsl:choose>
                           <xsl:when test="count(../field[@starts_group]) &gt; 0">
                        foundErrors.add(BitHelper.packInt(FixException.DUPLICATE_TAG, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;<xsl:text/>
                           </xsl:when>
                           <xsl:otherwise>
                        current_group<xsl:value-of select="$groupWithoutNoPrefix"/>++;<xsl:text/>
                           </xsl:otherwise>
                        </xsl:choose>
                    }

                    <xsl:value-of select="$curGroup"/>.field<xsl:value-of select="@name"/> = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                    if (<xsl:value-of select="$curGroup"/>.field<xsl:value-of select="@name"/> == null || !<xsl:value-of select="$curGroup"/>.field<xsl:value-of select="@name"/>.hasValue())
                    {
                        foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                        if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                        {
                            return foundErrors;
                        }

                        continue;
                    }<xsl:text/>
                    </xsl:when>
                    <xsl:otherwise>

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.VALIDATE_UNUSED_FIELDS))
                    {
                        <xsl:value-of select="fix:buildFixFieldName(@name)"/> unusedByCboeField = <xsl:value-of select="fix:buildFixFieldName(@name)"/>.create(array, offset, length);
                        if (unusedByCboeField == null || !unusedByCboeField.hasValue())
                        {
                            unusedByCboeField = null;

                            foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG_VALUE, currentPosition));

                            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                            {
                                return foundErrors;
                            }

                            continue;
                        }

                        unusedByCboeField = null;
                    }<xsl:text/>
                    </xsl:otherwise>
                  </xsl:choose>

                    continue;
                }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Group_AdditionalUserFields">

                if (currentState == STATE_<xsl:value-of select="fix:removePrefix(@name, 'No')"/>Group)
                {<xsl:text/>
                  <xsl:choose>
                    <xsl:when test="@allow_user_fields = 'Y'">
                    if (group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>[current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>].additionalUserFields == null)
                    {
                        group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>[current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>].additionalUserFields = new ArrayList();
                    }

                    group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>[current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>].additionalUserFields.add(new AdditionalUserField(tag, array, offset, length));
                    </xsl:when>
                    <xsl:otherwise>
                    if (current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/> == group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>.length - 1)
                    {
                        if (additionalUserFields == null)
                        {
                            additionalUserFields = new ArrayList();
                        }

                        additionalUserFields.add(new AdditionalUserField(tag, array, offset, length));
                        continue;
                    }

                    foundErrors.add(BitHelper.packInt(FixException.UNEXPECTED_USER_DEFINED_TAG_WITHIN_GROUP, currentPosition));<xsl:text/>

                    if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                    {
                        return foundErrors;
                    }<xsl:text/>
                    </xsl:otherwise>
                  </xsl:choose>
                    continue;
                }<xsl:text/>
</xsl:template>

<xsl:template name="fix:FixMessageClass_Function_Group_CreateLengthChecks">
        if (group<xsl:value-of select="fix:removePrefix(@name, 'No')"/> != null &amp;&amp; current_group<xsl:value-of select="fix:removePrefix(@name, 'No')"/> != group<xsl:value-of select="fix:removePrefix(@name, 'No')"/>.length - 1)
        {
            foundErrors.add(BitHelper.packInt(FixException.FEWER_GROUPS_THAN_SPECIFIED, currentPosition));

            if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                return foundErrors;
            }
        }<xsl:text/>
</xsl:template>



<xsl:template match="/fix/messages/message[@cboe_uses='Y']">
<xsl:result-document href="file://{$IMPLS_DIRECTORY}/com/cboe/cfix/fix/fix{/fix/@versiontag}/generated/messages/Fix{@name}Message.java" format="text">
<xsl:text/>package com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.generated.messages;

/**
 * Fix<xsl:value-of select="@name"/>Message.java
 *
 * @author Dmitry Volpyansky
 *
 */

/**
 * This GENERATED file implements FIX Protocol's <xsl:value-of select="@name"/> Message.
 *
 * WARNING: This entire file is completely generated by XSLT stylesheets from CboeFIX<xsl:value-of select="/fix/@versiontag"/>.xml file.
 *
 */

import java.util.*;

import com.cboe.cfix.interfaces.*;
import com.cboe.cfix.util.*;
import com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.field.*;
import com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.generated.fields.*;
import com.cboe.cfix.fix.fix<xsl:value-of select="/fix/@versiontag"/>.generated.helpers.*;
import com.cboe.cfix.fix.util.*;
import com.cboe.client.util.*;
import com.cboe.infrastructureServices.foundationFramework.utilities.*;

public class Fix<xsl:value-of select="@name"/>Message extends FixMessage
{   <xsl:text/>
    <xsl:variable name="longestFieldName" select="fix:findLongestString(field/@name|group/@name)+11"/>
    <xsl:call-template name="fix:FixMessageClass_Const_MsgType"/>
    <xsl:for-each select="field|group">
        <xsl:choose>
           <xsl:when test="name() = 'field'">
               <xsl:call-template name="fix:FixMessageClass_Fields">
                    <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
               </xsl:call-template><xsl:text/>
           </xsl:when>
           <xsl:otherwise>
               <xsl:call-template name="fix:FixMessageClass_Groups">
                    <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
               </xsl:call-template><xsl:text/>
           </xsl:otherwise>
        </xsl:choose>
    </xsl:for-each>
    public <xsl:value-of select="fix:rightPad('List', $longestFieldName)"/> additionalUserFields;<xsl:text/>
    <xsl:for-each select=".//group">
        <xsl:text>&#xA;</xsl:text>
        <xsl:call-template name="fix:FixMessageClass_DefineGroup">
            <xsl:with-param name="longestFieldName" select="$longestFieldName"/>
        </xsl:call-template><xsl:text/>
    </xsl:for-each>

    public Fix<xsl:value-of select="@name"/>Message()
    {

    }

    public boolean isFix<xsl:value-of select="@name"/>Message() {return true;}
    public String getMsgType()        {return MsgType;}
    public char   getMsgTypeAsChar()  {return MsgTypeAsChar;}
    public char[] getMsgTypeAsChars() {return MsgTypeAsChars;}
    public String getMsgTypeName()    {return MsgTypeName;}
    <xsl:for-each select="field|group">
        <xsl:call-template name="fix:FixMessageClass_Function_ToString">
            <xsl:with-param name="groupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>
        </xsl:call-template>
    </xsl:for-each>
    <xsl:text>&#xA;</xsl:text>
    <xsl:for-each select="field|group">
        <xsl:call-template name="fix:FixMessageClass_Function_AcceptFixMessageBuilder">
            <xsl:with-param name="groupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>
        </xsl:call-template><xsl:text/>
    </xsl:for-each>
    <xsl:text>&#xA;</xsl:text>
    <xsl:call-template name="fix:FixMessageClass_Function_Validate_Begin"/>
    <xsl:for-each select="field[@required='Y']|group[@required='Y']|/fix/header/field[@required='Y' and not(@name = 'BeginString') and not(@name = 'BodyLength') and not(@name = 'MsgType')]">
        <xsl:call-template name="fix:FixMessageClass_Function_Validate_Body_Required"/>
    </xsl:for-each>
    <xsl:for-each select="validation/validate">
        <xsl:call-template name="fix:FixMessageClass_Function_Validate_Body_Conditional"/>
    </xsl:for-each>
    <xsl:call-template name="fix:FixMessageClass_Function_Validate_End"/>
    <xsl:for-each select=".//group">
        <xsl:call-template name="fix:FixMessageClass_Function_Build_States"/>
    </xsl:for-each>

    private String toStateString(int state)
    {
        switch (state)
        {
            case STATE_Header: return "State[Header]";<xsl:text/>
            case STATE_Field:  return "State[Field]";<xsl:text/>
    <xsl:for-each select=".//group">
        <xsl:call-template name="fix:FixMessageClass_Function_Build_StatesToString"/>
    </xsl:for-each>
        }

        return "???";
    }
    <xsl:call-template name="fix:FixMessageClass_Function_Build_Begin"/>
    <xsl:for-each select=".//group">
        <xsl:call-template name="fix:FixMessageClass_Function_Build_BeginGroups"/>
    </xsl:for-each>

        for (currentPosition = 0; currentPosition &lt; numTags; currentPosition++)
        {
            if (!foundErrors.isEmpty() &amp;&amp; BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
            {
                break;
            }

            tag    = fixPacket.getTag(currentPosition);
            offset = fixPacket.getValueOffset(currentPosition);
            length = fixPacket.getValueLength(currentPosition);

            if ((BitHelper.isBitMaskSet(debugFlags, FixSessionDebugIF.MESSAGE_SHOW_BUILD_TRANSITIONS)))
            {
                String threadName = Thread.currentThread().getName();
                String stateString = toStateString(currentState);
                StringBuilder sb = new StringBuilder(threadName.length()+stateString.length()+50);
                if (currentPosition > 0)
                {
                    sb.append(threadName).append(" --> ").append(stateString);
                    Log.information(sb.toString());
                    sb.setLength(0);
                }

                sb.append(threadName).append("Tag[").append(currentPosition).append("] = ").append(FixFieldHelper.getTagName(tag)).append("(").append(tag).append(") ").append(stateString);
                Log.information(sb.toString());
            }

            switch (tag)
            {<xsl:text/>
    <xsl:for-each select="field">
        <xsl:call-template name="fix:FixMessageClass_Function_CreateField"/><xsl:text/>
    </xsl:for-each>
    <xsl:for-each select="group">
        <xsl:call-template name="fix:FixMessageClass_Function_CreateGroup"/><xsl:text/>
    </xsl:for-each>
    <xsl:for-each select="group">
        <xsl:variable name="groupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>
        <xsl:for-each select="field">
            <xsl:call-template name="fix:FixMessageClass_Function_CreateGroupSubFields">
                <xsl:with-param name="groupWithoutNoPrefix" select="$groupWithoutNoPrefix"/>
            </xsl:call-template><xsl:text/>
        </xsl:for-each>
    </xsl:for-each>
    <xsl:for-each select="group/group">
        <xsl:call-template name="fix:FixMessageClass_Function_CreateSubGroup"/><xsl:text/>
    </xsl:for-each>
    <xsl:for-each select="group/group">
        <xsl:variable name="groupWithoutNoPrefix" select="fix:removePrefix(@name, 'No')"/>
        <xsl:for-each select="field">
            <xsl:call-template name="fix:FixMessageClass_Function_CreateSubGroupSubFields">
                <xsl:with-param name="groupWithoutNoPrefix" select="$groupWithoutNoPrefix"/>
            </xsl:call-template><xsl:text/>
        </xsl:for-each>
    </xsl:for-each>
            }

            if (tag >= FixMessageIF.USER_DEFINED_TAGS_START)
            {
                if (currentState == STATE_Field || currentState == STATE_Header)
                {
                    if (additionalUserFields == null)
                    {
                        additionalUserFields = new ArrayList();
                    }

                    additionalUserFields.add(new AdditionalUserField(tag, array, offset, length));
                    continue;
                }<xsl:text/>
    <xsl:for-each select="group">
        <xsl:call-template name="fix:FixMessageClass_Function_Group_AdditionalUserFields"/>
    </xsl:for-each>
            }

            if (!buildHeaderTrailer(array, tag, offset, length, currentState, currentPosition, foundErrors, validationFlags, debugFlags))
            {
                foundErrors.add(BitHelper.packInt(FixException.INVALID_TAG, currentPosition));

                if (BitHelper.isBitMaskSet(validationFlags, FixMessageIF.STOP_ON_FIRST_ERROR))
                {
                    return foundErrors;
                }

                continue;
            }
        }<xsl:text/>
    <xsl:for-each select="group">
        <xsl:text>&#xA;</xsl:text>
        <xsl:call-template name="fix:FixMessageClass_Function_Group_CreateLengthChecks"/>
    </xsl:for-each>

        if ((BitHelper.isBitMaskSet(debugFlags, FixSessionDebugIF.MESSAGE_SHOW_BUILD_TRANSITIONS)))
        {
            String threadName = Thread.currentThread().getName();
            String stateString = toStateString(currentState);
            StringBuilder sb = new StringBuilder(threadName.length()+stateString.length()+10);
            sb.append(threadName).append(" --> ").append(stateString);
            Log.information(sb.toString());
        }

        return foundErrors;
    }<xsl:text/>
    <xsl:apply-templates/><xsl:text/>
}
</xsl:result-document>
</xsl:template>


</xsl:stylesheet>

<!--
<xsl:message>Processing Group(<xsl:value-of select="@name"/>)</xsl:message>
-->
