package com.cboe.infrastructureUtility;

import java.sql.SQLException;

/**
 *  This is a generic class which handles the Orcale and JDBC Fatal Error Situations.
 *  @author Sridhar Nimmagadda
 */

public class SQLExceptionHelper {


	/** Error Code Returned from JDBC Driver for When the Instance goes down.
	 *
 	 * 	ORA-17002  Io exception: Connection reset by peer.
 	 */
	 static int CONN_RESET_ERROR_CODE = 17002;

	/**	Error Code Returned from the JDBC Driver when there is no data to read from the Socket. ???
     *
     * 	ORA-17410  No more data to read from socket
     */
	public static int NO_DATA_READ_SOCKET = 17410;

 	/**	All session state objects are in use.
     *
     * 	ORA-00018 maximum number of sessions exceeded
     */
	public static int MAX_SESSIONS_EXCEEDED = 18;

 	/**	All licenses are in use.
     *
     * 	ORA-00019 maximum number of session licenses exceeded
     */
	public static int MAX_LICENSES_EXCEEDED = 19;

 	/**	All process state objects are in use.
     *
     * 	 ORA-00020 maximum number of processes (string) exceeded
     */
	public static int MAX_PROCESSES_EXCEEDED = 20;

 	/**	A privileged user killed the session and it is no longer logged in to the database.
     *
     * 	ORA-00028 your session has been killed
     */
	public static int ORACLE_SESSION_KILLED = 28;

 	/** Ran out of enqueue resources.
     *
     * 	ORA-00052 maximum number of enqueue resources (string) exceeded.
     */
 	public static int MAX_ENQUEUE_RESOURCES_EXCEEDED = 52;

 	/** Ran out of enqueue state objects.
   	 *
     * 	ORA-00053 maximum number of enqueues exceeded.
     */
 	public static int MAX_ENQUEUE_OBJECTS_EXCEEDED = 53;

 	/** The NOWAIT keyword forced a return to the command prompt because a resource was
     * 	unavailable for a LOCK TABLE or SELECT FOR UPDATE command.
     *
     * 	ORA-00054 resource busy and acquire with NOWAIT specified
     */
 	public static int RESOURCE_UNAVAIL_LOCKTABLE = 54;

	/** An error occurred during archiving.
	 *  Check the archive string used to make sure it refers to a valid online device.
   	 *
     * 	ORA-00255 error archiving log string of thread string, sequence # string
     */
 	public static int ARCHIVE_ERROR = 255;

	/** An I/O error occurred while archiving a redo log file.
	 *  Check that the output device is still available and correct any device errors that may have occurred.
	 *  Also, make certain that sufficient space for archiving is available on the output device.
   	 *
     * 	ORA-00272 error writing archive log string
     */
 	public static int IO_ARCHIVE_ERROR = 272;

	/** A foreground process needing service from a background process has discovered the process died.
   	 *  Refer to the message code given in the message and the trace file for the foreground and the background processes.
     *
     *  ORA-00449 background process 'string' unexpectedly terminated with error string
     */
 	public static int BACKGROUND_PROCESS_TERMINATED = 449;


	/** This is the generic internal error number for Oracle program exceptions.
	 *  It indicates that a process has encountered a low-level, unexpected condition. Causes of this message include:
	 *  timeouts, file corruption, failed data checks in memory, hardware, memory, or I/O errors, incorrectly restored
	 *  files etc.The first argument is the internal message number. Other arguments are various numbers, names, and
	 *  character strings. The numbers may change meanings between different versions of Oracle.
	 *  Report this error to Oracle Customer Support after gathering the following information: events that led up to the error,
	 *  the operations that were attempted that led to the error, the conditions of the operating system and databases
	 *  at the time of the error, any unusual circumstances that occurred before receiving the ORA-00600 message,
	 *  contents of any trace files generated by the error, the relevant portions of the Alter files
	 *
     *  Note: The cause of this message may manifest itself as different errors at different times.
     *  Be aware of the history of errors that occurred before this internal error.

     * 	ORA-00600 internal error code, arguments: [string], [string], [string], [string], [string], [string], [string], [string]
     */
 	public static int ORACLE_INTERNAL_ERROR = 600;

	/** An Oracle Server session is in an unrecoverable state.
	 *
     * 	ORA-00603 ORACLE server session terminated by fatal error
     */
 	public static int ORACLE_SESSION_TERMINATED = 603;

	/** An Oracle Server session is in an unrecoverable state due to recursive error.
	 *  More specific information will be provided in embedded SQL Message 
     * 	ORA-00604 error occurred at recursive SQL level 1 
     */
 	public static int ORACLE_RECURSIVE_ERROR = 604;

   /** There are not enough row cache enqueues.
    *
    * 	ORA-00703 maximum number of row cache instance locks exceeded
    */
 	public static int  MAX_ROWCACHE_QUEUES_EXCEEDED = 703;

   /** A host language program attempted to open too many cursors.
    * 	The initialization parameter OPEN_CURSORS determines the maximum number of cursors per user.
    *  The number of cursors one client can open at a time on a connection is limited
    * (50 is the default value). You do need to explicitly close the statement,by using the method
    *  stmt.close() in order to close and freeup the cursors. If you dont close these cursors explicitly,
    *  you will get this error eventually. Simply increasing the "OPEN_CURSORS" limit can help you avoid the
    * problem for a while, but that just hides the problem, not solve it. It is your responsibilty to
    * explicitly close out cursors that you no longer need.
    *
    * ORA-01000 maximum open cursors exceeded
    */
 	public static int MAX_OPEN_CURSORS_EXCEEDED = 1000;

   /** A host language program call referenced a cursor with no associated parsed SQL statement.
    *  This is a Fatal Error.
    *
    *  ORA-01003 no statement parsed 
    */
        public static int NO_STATEMENT_PARSED = 1003;

   /** An attempt was made to log on while Oracle is being started or shut down. I don't suppose we need to shutdown the Application. Wait a few minutes
	*  and then try the Application. This is not a Fatal Error.
    *
    *  ORA-01033 ORACLE initialization or shutdown in progress
    */
 	public static int INIT_OR_SHUTDOWN_INPROGRESS = 1033;

	/** Oracle was not started Or the Instance Name in the JDBC Url is pointing to one which is not running.
 	 *
 	 * ORA-01034 ORACLE not available
 	 */
	public static int ORACLE_NOT_AVAILABLE	= 1034;

	/** The application program interface could not insert or update a LONG column
	 *  because of an internal error when a TTCGETV call fails.
	 *  For example, a network read error or one of the parameters passed to the call is invalid.
	 *
	 * 	ORA-01098 program Interface error during Long Insert
	 */
	 public static int LONG_UPDATE_FAILED = 1098;

	/**
	 *  Failed to allocate an extent for temporary segment in tablespace.
	 *  Use ALTER TABLESPACE ADD DATAFILE statement to add one or more files to the tablespace indicated.
	 *
	 *	ORA-01652 unable to extend temp segment by string in tablespace string
	 */
	 public static int ALLOCATE_EXTENT_TEMP_SEGMENT_FAILED = 1652;

	/**
	 *  Failed to allocate an extent for table segment in tablespace.
	 *  Use ALTER TABLESPACE ADD DATAFILE statement to add one or more files to the tablespace indicated.
	 *
	 *	ORA-01653 unable to extend table string.string by string in tablespace string
	 */
	 public static int ALLOCATE_EXTENT_TABLE_SEGMENT_FAILED = 1653;

	/**
	 *  Failed to allocate an extent for index segment in tablespace.
	 *  Use ALTER TABLESPACE ADD DATAFILE statement to add one or more files to the tablespace indicated.
	 *
	 *	ORA-01654 unable to extend index string.string by string in tablespace string
	 */
	 public static int ALLOCATE_EXTENT_INDEX_SEGMENT_FAILED = 1654;

	/**
	 *  Failed to allocate an extent for index segment in tablespace.
	 *  Use ALTER TABLESPACE ADD DATAFILE statement to add one or more files to the tablespace indicated.
	 *
	 *	ORA-01683 unable to extend index string.string partition string by string in tablespace string
	 */
	 public static int ALLOCATE_EXTENT_INDEX_PARTITION_SEGMENT_FAILED = 1683;

	/**
	 *  A table tried to extend past MAXEXTENTS.
	 *  If MAXEXTENTS is less than the system maximum, raise it. Otherwise, you must re-create with larger initial, next or PCTINCREASE parameters.
	 *
	 *	ORA-01684 max # extents (string) reached in table string.string partition string
	 */
	 public static int MAX_EXTENTS_TABLE_EXCEEDED = 1684;

	/**
	 *  Failed to allocate an extent for table segment in tablespace.
	 *  Use ALTER TABLESPACE ADD DATAFILE statement to add one or more files to the tablespace indicated.
	 *
	 *	ORA-01688 unable to extend table string.string partition string by string in tablespace string
	 */
	 public static int ALLOCATE_EXTENT_TABLE_PARTITION_SEGMENT_FAILED= 1688;

	/**
	 *  An unexpected end-of-file was processed on the communication channel
	 *	ORA-03113 end-of-file on communication channel
	 */
	 public static int  EOF_COMM_CHANNEL = 3113;

        /**
         *   Fragmentation of shared pool memory is a common problem and ORA-04031 is commonly 
         *   a result of such fragmentation. Application programmers usually get this error 
         *   while attempting to load a big package or while executing a very large procedure 
         *   and there is not sufficient contiguous free memory available in the shared pool. 
         *   This may be due to fragmentation of the shared pool memory or insufficient memory 
         *   in the shared pool.  Ask the DBA to increase the initialisation parameter 
         *   SHARED_POOL_SIZE if possible. This is to be treated as FATAL error to application
         *   This is generally embedded in the message of the ORA-00604 error so might not be
         *   called directly
         *
         *    ORA-04031: unable to allocate nnn bytes of shared memory
         */ 
         public static int  INSUFFICIENT_SHARED_MEM = 4031;

	/**
	 *  SEMOP system call returned an error. Semaphore set may not exist.
	 *	ORA-07265 sppst: semop error, unable to increment semaphore.
	 */
	 public static int  SEMOP_ERROR = 7265;

	/**
	 *  An operating system exception occurred which should result in the creation of a core file. This is an internal error
	 *  Contact Oracle Customer Support.
	 *
	 *	ORA-07445 exception encountered: core dump [string] [string] [string] [string] [string] [string]
	 */
	 public static int  CORE_DUMP_EXCEPTION = 7445;




	/**
	 *  This error code indicates that the Instance name in the URL being used to connected to the database is either wrong or is
	 *  not up and running.
	 */
 	public static int CONNECTION_REFUSED = 12505;


  /* Error Code Ranking */

  /**
   *  This is indicatior of a Fatal SQL Exception. In most cases, the process would be in a invalid State and should be shutdown.
   */
	 static public final int FATAL_SQL_ERROR = 1 ;

  /**
   *  This is indicatior of a SQL Exception which could have happened due to a resource contention or Resource overflow
   *  or high Network Activity. In most cases, the process would not be in a invalid State.
   */
	static public final int NORMAL_SQL_ERROR = 0 ;

   /**
   *  This is indicatior of a SQL Exception which is not handled by this class and leaves it to the Application developer
   *  to deal with it.
   */
	static public final int UNKNOWN_SQL_ERROR = -1 ;




	public SQLExceptionHelper ( ) {
  }

  /**
   *  This is static method which can be called by the applications to
   *  determine the Fatality of the SQLException that has been Caught.
   *  The application needs to take the appropriate action based on the
   *  Ranking Level. In almost all cases, the Process would be in
   *  an invalid state when a Fatal Exception is caught. It is advisable
   *  to shut it down and failover to the backup process using the Locator.
   */

  static public int RankSQLException( SQLException sqe ) {

  	int retCode;

  	//com.cboe.common.log.Logger.sysAlarm("SQL Exception Caught:\n Message: "+ sqe.getMessage() + "\nError(Vendor) Code : " + sqe.getErrorCode());
  	//com.cboe.common.log.Logger.sysAlarm("\nSQL Exception:  ", sqe ) ;

    switch (sqe.getErrorCode()) {

		// JDBC Vendor (Oracle Thin Driver) Error Codes
    	case  17002 : //CONN_RESET_ERROR_CODE
	     				//com.cboe.common.log.Logger.sysAlarm("JDBC Error Code 17002 is considered to be fatal.  The Process will be shutdown.  ", sqe ) ;
	     				//ShutDownProcess();
	           			retCode = FATAL_SQL_ERROR;
	     				break;
    	case 17410 : //NO_DATA_READ_SOCKET
     					retCode = FATAL_SQL_ERROR;
     					break;

     	// Oracle Error Codes
    	case 18 	 : //MAX_SESSIONS_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 19 	 : //MAX_LICENSES_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 20 	 : //MAX_PROCESSES_EXCEEDED
		     			retCode = FATAL_SQL_ERROR;
		     			break;
    	case 28 	 : //ORACLE_SESSION_KILLED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 52 	 : //MAX_ENQUEUE_RESOURCES_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 53 	 : //MAX_ENQUEUE_OBJECTS_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 54 	 : //RESOURCE_UNAVAIL_LOCKTABLE
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 255 	 : //ARCHIVE_ERROR
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 272 	 : //IO_ARCHIVE_ERROR
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 449 	 : //BACKGROUND_PROCESS_TERMINATED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 600 	 : //ORACLE_INTERNAL_ERROR
 	     				retCode = FATAL_SQL_ERROR;
 	     				break;
 	case 603 	 : //ORACLE_SESSION_TERMINATED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
 	case 604 	 : //ORACLE_RECURSIVE_ERROR
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 703   : //MAX_ROWCACHE_QUEUES_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 1000  : //MAX_OPEN_CURSORS_EXCEEDED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 1003  : //NO_STATEMENT_PARSED
	     				retCode = FATAL_SQL_ERROR;
	     				break;
    	case 1033  : //INIT_OR_SHUTDOWN_INPROGRESS
     					retCode = FATAL_SQL_ERROR;
     					break;
		case 1034  : //ORACLE_NOT_AVAILABLE
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1098  : //LONG_UPDATE_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1652  : //ALLOCATE_EXTENT_TEMP_SEGMENT_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1653  : //ALLOCATE_EXTENT_TABLE_SEGMENT_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1654  : //ALLOCATE_EXTENT_INDEX_SEGMENT_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1683  : //ALLOCATE_EXTENT_INDEX_PARTITION_SEGMENT_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 1688  : //ALLOCATE_EXTENT_TABLE_PARTITION_SEGMENT_FAILED
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 4031: //INSUFFICIENT_SHARED_MEM
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 3113  : //EOF_COMM_CHANNEL
    					retCode = FATAL_SQL_ERROR;
      					break;
 		case 7265  : //SEMOP_ERROR
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 7445  : //CORE_DUMP_EXCEPTION
     					retCode = FATAL_SQL_ERROR;
     					break;
    	case 12505  : //CONNECTION_REFUSED
     					retCode = FATAL_SQL_ERROR;
     					break;
      default :
      					retCode = UNKNOWN_SQL_ERROR;
      					break;
    }

    return retCode;

  }

}
